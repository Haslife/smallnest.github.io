<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://colobu.com/"/>
  <updated>2018-09-11T03:08:28.106Z</updated>
  <id>https://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[图像相似性比较实践]]></title>
    <link href="https://colobu.com/2018/09/07/image-similarity-algorithms-in-go/"/>
    <id>https://colobu.com/2018/09/07/image-similarity-algorithms-in-go/</id>
    <published>2018-09-07T03:37:48.000Z</published>
    <updated>2018-09-07T11:48:11.401Z</updated>
    <content type="html"><![CDATA[<p>2008年TinEye上线了图片搜索，开始是注册制，后来逐步放开。2011年， Google也上线了相似图片搜索，通过用户上传的图片，可以搜索相似的图片。<br>参考文档中提供了一些介绍图像搜索的一些文章， 尤其是阮一峰2011年和2013年两篇普及性的文章，可以帮助你了解图像相似搜索的原理。</p>
<p>图像相似性搜索应用广泛、除了使用搜索引擎搜索类似图片外，像淘宝可以让顾客直接拍照搜索类似的商品信息、应用在商品购物上。也可以应用物体识别比如拍图识花等领域。目前我在调研图片鉴权的方案，通过一张图片和图片库中的图片进行比对，来确定这张图片是否侵权，或者退一步讲，图片库中是否包含和这张图片类似。 这个需求和目前深度学习应用中的图像识别还不一样， 图像识别是需要将图像中的物体识别出来， 猫啊狗啊什么的，而我所要做的就是一个查找相似图片的东西。</p>
<p>Neal Krawetz博士看到了一些关于TinEye原理的询问， 虽然他并不知道TinEye是怎么实现的，但是根据搜索结果，他判断是基于感知哈希算法(Perceptual hash algorithm)的变种，他于2011年5月写了一篇文章，介绍相关的技术。</p>
<a id="more"></a>
<h2 id="背景知识">背景知识</h2>
<p>感知哈希算法根据图像的特征生成一个确定的指纹，这些指纹可以用来比较。指纹越接近，说明图片越接近。在文章中他介绍了一个非常简单的感知哈希算法， <code>Average Hash algorithm</code>，以美女Alyson Hannigan照片为例,计算指纹(hash)的步骤如下：</p>
<p><img src="Alyson_Hannigan_200512.jpg" alt=""></p>
<p>1、减小图像的尺寸<br>生成一个<code>8 X 8</code>的缩略图，一共64个像素。<br><img src="Alyson_Hannigan_200512-8x8.png" alt=""></p>
<p>2、编程灰度图像<br>这样就从64个像素(64 Red, 64 Green, 64 Blue)变为64中颜色。</p>
<p>3、计算颜色的平均值</p>
<p>4、计算64位中的每一位<br>简单和平均值比较，根据大小设置1和0</p>
<p>5、计算hash值<br>把这64bit赋值给一个64bit的整数，顺序是无关的，只要保持一致即可。</p>
<p><img src="Alyson_Hannigan_200512-dhash.png" alt="8f373714acfcf4d0"></p>
<p>这样，这个图片的指纹就通过一个64位的整数表示出来了。图像放大缩小、旋转、对比度、饱和度的变换不会显著改变指纹。其实最大的好处就是<strong>快</strong>。</p>
<blockquote>
<p>天下武功，无坚不摧，唯快不破</p>
</blockquote>
<p>当你比较两张图片的时候，计算它们的hash值，然后再计算它们的汉明距离即可。</p>
<p>虽然平均散列是快速和容易的，但是photoshop的力量是无穷的，如果你对图片进行伽玛校正或者直方图的调整，对颜色进行非线性的改变，上述算法可能就不太准确了。</p>
<p>博士又介绍了<a href="http://www.phash.org" target="_blank" rel="external">pHash</a>算法, 它扩展了<code>Average Hash algorithm</code>,使用DCT(离散余弦变换)减少图像的高频数据。</p>
<p>博士又动手写了一个工具，搜索了一批图片进行测试。研究发现， Average Hash非常快，在特定场景下是一个非常好的算法。</p>
<p>这篇文章非常值得你阅读，也引起了广泛的讨论，以及一些编程语言的实现。 博士在2013年又介绍了第三种算法：difference hash，准确性和aHash（<code>Average Hash algorithm</code>）查不多，但是更快。 aHash基于平均值，pHash基于图像频率，而dHash基于直方图。</p>
<p>阅读博士的文章的时候我在想，对于aHash, 分别计算RGB的指纹，用这三个指纹比较是不是会更好？</p>
<p>这里再介绍另外一种技术: SIFT，即尺度不变特征变换（Scale-invariant feature transform，SIFT），是用于图像处理领域的一种描述。这种描述具有尺度不变性，可在图像中检测出关键点，是一种局部特征描述子。 该方法于1999年由David Lowe首先发表于计算机视觉国际会议（International Conference on Computer Vision，ICCV），2004年再次经David Lowe整理完善后发表于International journal of computer vision（IJCV。截止2014年8月，该论文单篇被引次数达25000余次。SIFT在数字图像的特征描述方面当之无愧可称之为最红最火的一种，许多人对SIFT进行了改进，诞生了SIFT的一系列变种。SIFT已经申请了专利。</p>
<p>SIFT好是好，但是是有专利保护的，并且也慢。</p>
<p>这是雷经纬的整理的算法比较:<br><img src="a.png" alt=""></p>
<h2 id="Go语言实践">Go语言实践</h2>
<p>以上是图片比对的背景知识，这一节我们介绍一个计算图像指纹，并且和对象进行比较的例子。</p>
<p>这次，我们使用的库是<a href="github.com/corona10/goimagehash">goimagehash</a>,它实现了aHash、dHash、pHash算法， wHash正准备实现。</p>
<p>例子中我们使用的三张图片分别是：</p>
<p><img src="Alyson_Hannigan_200512.jpg" alt=""></p>
<p><img src="Alyson_Hannigan2.jpg" alt=""></p>
<p><img src="Lena.jpg" alt=""></p>
<p>分别使用三种算法，计算第一张图片和第二张、第三张图片的汉明距离。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"image/jpeg"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/corona10/goimagehash"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	queryFile, _ := os.Open(<span class="string">"Alyson_Hannigan.jpg"</span>)</div><div class="line">	file1, _ := os.Open(<span class="string">"Alyson_Hannigan2.jpg"</span>)</div><div class="line">	file2, _ := os.Open(<span class="string">"Lena.jpg"</span>)</div><div class="line">	<span class="keyword">defer</span> queryFile.Close()</div><div class="line">	<span class="keyword">defer</span> file1.Close()</div><div class="line">	<span class="keyword">defer</span> file2.Close()</div><div class="line"></div><div class="line">	imgQuery, _ := jpeg.Decode(queryFile)</div><div class="line">	img1, _ := jpeg.Decode(file1)</div><div class="line">	img2, _ := jpeg.Decode(file2)</div><div class="line">	queryHash, _ := goimagehash.AverageHash(imgQuery)</div><div class="line">	hash1, _ := goimagehash.AverageHash(img1)</div><div class="line">	hash2, _ := goimagehash.AverageHash(img2)</div><div class="line">	distance1, _ := queryHash.Distance(hash1)</div><div class="line">	distance2, _ := queryHash.Distance(hash2)</div><div class="line">	fmt.Printf(<span class="string">"Distance between images: %d %d\n"</span>, distance1, distance2)</div><div class="line"></div><div class="line">	queryHash, _ = goimagehash.DifferenceHash(imgQuery)</div><div class="line">	hash1, _ = goimagehash.DifferenceHash(img1)</div><div class="line">	hash2, _ = goimagehash.DifferenceHash(img2)</div><div class="line">	distance1, _ = queryHash.Distance(hash1)</div><div class="line">	distance2, _ = queryHash.Distance(hash2)</div><div class="line">	fmt.Printf(<span class="string">"Distance between images: %d %d\n"</span>, distance1, distance2)</div><div class="line"></div><div class="line">	queryHash, _ = goimagehash.PerceptionHash(imgQuery)</div><div class="line">	hash1, _ = goimagehash.PerceptionHash(img1)</div><div class="line">	hash2, _ = goimagehash.PerceptionHash(img2)</div><div class="line">	distance1, _ = queryHash.Distance(hash1)</div><div class="line">	distance2, _ = queryHash.Distance(hash2)</div><div class="line">	fmt.Printf(<span class="string">"Distance between images: %d %d\n"</span>, distance1, distance2)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Distance between image<span class="variable">s:</span> <span class="number">2</span> <span class="number">46</span></div><div class="line">Distance between image<span class="variable">s:</span> <span class="number">3</span> <span class="number">41</span></div><div class="line">Distance between image<span class="variable">s:</span> <span class="number">6</span> <span class="number">36</span></div></pre></td></tr></table></figure>

<p>可以看到，三种方法都能正确的识别出第一张和第二张图片是类似的(&lt;= 6), 而和第三张图片的差别比较大。</p>
<p>对于这次测试，第二个图片我调整了一下饱和度，加了一个小小的水印。 而aHash表现最好。</p>
<p>对于简单的图像查重和相似图片的查找，使用这三种算法就可以了，要是你想根据一个人的正脸，去搜索这个人的侧脸图片，那可能就需要使用SIFT或者其他的算法了。</p>
<h2 id="参考文档">参考文档</h2>
<ol>
<li><a href="http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html" target="_blank" rel="external">http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/07/principle_of_similar_image_search.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/07/principle_of_similar_image_search.html</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1006121" target="_blank" rel="external">https://cloud.tencent.com/developer/article/1006121</a></li>
<li><a href="https://fullstackml.com/wavelet-image-hash-in-python-3504fdd282b5" target="_blank" rel="external">https://fullstackml.com/wavelet-image-hash-in-python-3504fdd282b5</a></li>
<li><a href="http://www.infoq.com/cn/articles/image-similarity-algorithm-on-mobile-client" target="_blank" rel="external">http://www.infoq.com/cn/articles/image-similarity-algorithm-on-mobile-client</a></li>
<li><a href="https://github.com/nivance/image-similarity" target="_blank" rel="external">https://github.com/nivance/image-similarity</a></li>
<li><a href="https://www.cnblogs.com/wangyaning/p/7854046.html" target="_blank" rel="external">https://www.cnblogs.com/wangyaning/p/7854046.html</a></li>
<li><a href="https://github.com/facebookresearch/faiss" target="_blank" rel="external">https://github.com/facebookresearch/faiss</a></li>
<li><a href="https://en.wikipedia.org/wiki/Perceptual_hashing" target="_blank" rel="external">https://en.wikipedia.org/wiki/Perceptual_hashing</a></li>
<li><a href="https://www.zhihu.com/question/19606748" target="_blank" rel="external">https://www.zhihu.com/question/19606748</a></li>
<li><a href="https://baike.baidu.com/item/SIFT/1396275" target="_blank" rel="external">https://baike.baidu.com/item/SIFT/1396275</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>2008年TinEye上线了图片搜索，开始是注册制，后来逐步放开。2011年， Google也上线了相似图片搜索，通过用户上传的图片，可以搜索相似的图片。<br>参考文档中提供了一些介绍图像搜索的一些文章， 尤其是阮一峰2011年和2013年两篇普及性的文章，可以帮助你了解图像相似搜索的原理。</p>
<p>图像相似性搜索应用广泛、除了使用搜索引擎搜索类似图片外，像淘宝可以让顾客直接拍照搜索类似的商品信息、应用在商品购物上。也可以应用物体识别比如拍图识花等领域。目前我在调研图片鉴权的方案，通过一张图片和图片库中的图片进行比对，来确定这张图片是否侵权，或者退一步讲，图片库中是否包含和这张图片类似。 这个需求和目前深度学习应用中的图像识别还不一样， 图像识别是需要将图像中的物体识别出来， 猫啊狗啊什么的，而我所要做的就是一个查找相似图片的东西。</p>
<p>Neal Krawetz博士看到了一些关于TinEye原理的询问， 虽然他并不知道TinEye是怎么实现的，但是根据搜索结果，他判断是基于感知哈希算法(Perceptual hash algorithm)的变种，他于2011年5月写了一篇文章，介绍相关的技术。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go http2 和 h2c]]></title>
    <link href="https://colobu.com/2018/09/06/Go-http2-%E5%92%8C-h2c/"/>
    <id>https://colobu.com/2018/09/06/Go-http2-和-h2c/</id>
    <published>2018-09-06T10:10:40.000Z</published>
    <updated>2018-09-06T11:21:16.156Z</updated>
    <content type="html"><![CDATA[<p>了解一下http2和h2c (HTTP/2 over TCP,HTTP/2 without TLS)。</p>
<a id="more"></a>
<h3 id="http/1-1_的服务器">http/1.1 的服务器</h3>
<p>我们经常会在代码中启动一个http服务器，最简单的http/1.1服务器如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">http.Handle(<span class="string">"/foo"</span>, fooHandler)</div><div class="line"></div><div class="line">http.HandleFunc(<span class="string">"/bar"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">	fmt.Fprintf(w, <span class="string">"Hello, %q"</span>, html.EscapeString(r.URL.Path))</div><div class="line">})</div><div class="line"></div><div class="line">log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="constant">nil</span>))</div></pre></td></tr></table></figure>

<p>使用Go开发web服务非常的简单，快速。</p>
<h3 id="http/1-1_的服务器_with_TLS">http/1.1 的服务器 with TLS</h3>
<p>如果想让http/1.1服务器支持TLS, 可以使用如下的代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">http.Handle(<span class="string">"/foo"</span>, fooHandler)</div><div class="line"></div><div class="line">http.HandleFunc(<span class="string">"/bar"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">	fmt.Fprintf(w, <span class="string">"Hello, %q"</span>, html.EscapeString(r.URL.Path))</div><div class="line">})</div><div class="line"></div><div class="line">log.Fatal(http.http.ListenAndServeTLS(<span class="string">":443"</span>, <span class="string">"server.crt"</span>, <span class="string">"server.key"</span>,<span class="constant">nil</span>))</div></pre></td></tr></table></figure>

<p>至于<code>server.crt</code> 和 <code>server.key</code>，你可以使用你从CA购买的证书，你也可以使用下面的测试证书。</p>
<p>为了测试，你可以创建CA证书和你的服务器使用的证书。</p>
<p><strong>1、 创建CA证书</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ openssl genrsa -out rootCA.key <span class="number">2048</span></div><div class="line">$ openssl req -x509 -new -nodes -key rootCA.key -days <span class="number">1024</span> -out rootCA.pem</div></pre></td></tr></table></figure>

<p>然后把<code>rootCA.pem</code>加到你的浏览器的证书中</p>
<p><strong>2、 创建证书</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ openssl genrsa -out server.key <span class="number">2048</span></div><div class="line">$ openssl req -new -key server.key -out server.csr</div><div class="line">$ openssl x509 -req -in server.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out server.crt -days <span class="number">500</span></div></pre></td></tr></table></figure>

<h3 id="免费证书">免费证书</h3>
<p>如果你不想从CA花钱购买证书， 也不想配置测试证书，那么你可以使用<code>let&#39;s encrypt</code>的免费证书, 而且<code>let&#39;s encrypt</code>目前支持通配符证书，使用也是很方便的。</p>
<p>Go的扩展包中提供了<code>let&#39;s encrypt</code>的支持。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"crypto/tls"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"net/http"</span></div><div class="line"></div><div class="line">    <span class="string">"golang.org/x/crypto/acme/autocert"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    certManager := autocert.Manager{</div><div class="line">        Prompt:     autocert.AcceptTOS,</div><div class="line">        HostPolicy: autocert.HostWhitelist(<span class="string">"example.com"</span>), </div><div class="line">        Cache:      autocert.DirCache(<span class="string">"certs"</span>),</div><div class="line">    }</div><div class="line"></div><div class="line">    http.HandleFunc(<span class="string">"/"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">        w.Write([]<span class="typename">byte</span>(<span class="string">"Hello world"</span>))</div><div class="line">    })</div><div class="line"></div><div class="line">    server := &http.Server{</div><div class="line">        Addr: <span class="string">":443"</span>,</div><div class="line">        TLSConfig: &tls.Config{</div><div class="line">            GetCertificate: certManager.GetCertificate,</div><div class="line">        },</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">go</span> http.ListenAndServe(<span class="string">":80"</span>, certManager.HTTPHandler(<span class="constant">nil</span>))</div><div class="line"></div><div class="line">    log.Fatal(server.ListenAndServeTLS(<span class="string">""</span>, <span class="string">""</span>)) <span class="comment">//Key and cert are coming from Let's Encrypt</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>或者更简单的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">log.Fatal(http.Serve(autocert.NewListener(<span class="string">"example.com"</span>), handler))</div></pre></td></tr></table></figure>

<p>看上面的例子, 把<code>example.com</code>换成你的域名，证书暂存在<code>certs</code>文件夹。autocert会定期自动刷新，避免证书过期。它会自动申请证书，并进行验证。</p>
<p>不过比较遗憾的是， autocert目前不支持通配符域名。</p>
<blockquote>
<p>HostWhitelist returns a policy where only the specified host names are allowed. Only exact matches are currently supported. Subdomains, regexp or wildcard will not match.</p>
</blockquote>
<p>通配符(ACME v2)的支持也已经完成了，但是迟迟未通过review,所以你暂时还不能使用这个特性。 (<a href="https://github.com/golang/go/issues/21081" target="_blank" rel="external">issue#21081</a>)</p>
<h3 id="HTTP/2">HTTP/2</h3>
<p>Go 在 1.6的时候已经支持 <code>HTTP/2</code> 了， 1.8 开始支持<code>PUSH</code>功能，你什么时候开始采用<code>HTTP/2</code>的呢？</p>
<p>Go的http/2使用也非常简单，但是必须和TLS一起使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"golang.org/x/net/http2"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> idleTimeout =<span class="number"> 5</span> * time.Minute</div><div class="line"><span class="keyword">const</span> activeTimeout =<span class="number"> 10</span> * time.Minute</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> srv http.Server</div><div class="line">	<span class="comment">//http2.VerboseLogs = true</span></div><div class="line">	srv.Addr = <span class="string">":8972"</span></div><div class="line"></div><div class="line">	http.HandleFunc(<span class="string">"/"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">		w.Write([]<span class="typename">byte</span>(<span class="string">"hello http2"</span>))</div><div class="line">	})</div><div class="line"></div><div class="line">	http2.ConfigureServer(&srv, &http2.Server{})</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		log.Fatal(srv.ListenAndServeTLS(<span class="string">"server.crt"</span>, <span class="string">"server.key"</span>))</div><div class="line">	}()</div><div class="line">	<span class="keyword">select</span> {}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>http2</code>封装并隐藏了http/2的处理逻辑，对于用户来说，可以不必关心内部的具体实现，想http/1.1一样简单的使用即可。</p>
<p>这里的证书可以使用上面提到证书，或者你购买的1证书，或者免费<code>let&#39;s encrypt</code>证书。</p>
<h3 id="h2c">h2c</h3>
<p>上面我们说Go的http/2必须使用TLS是不严谨的，如果你想不使用TLS,你可以使用最近添加的h2c功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line"></div><div class="line">	<span class="string">"golang.org/x/net/http2"</span></div><div class="line">	<span class="string">"golang.org/x/net/http2/h2c"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	mux := http.NewServeMux()</div><div class="line">	mux.HandleFunc(<span class="string">"/"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">		fmt.Fprint(w, <span class="string">"Hello h2c"</span>)</div><div class="line">	})</div><div class="line">	s := &http.Server{</div><div class="line">        Addr:    <span class="string">":8972"</span>,</div><div class="line">        Handler: mux,</div><div class="line">    }</div><div class="line">    http2.ConfigureServer(s, &http2.Server{})</div><div class="line">    log.Fatal(s.ListenAndServe())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用起来也很简单，单数目前浏览器对http/2都是采用TLS的方式，所以用浏览器访问这个服务的话会退化为http/1.1的协议，测试的话你可以使用Go实现客户端的h2c访问。</p>
<p>客户端代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"crypto/tls"</span></div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"net"</span></div><div class="line">    <span class="string">"net/http"</span></div><div class="line"></div><div class="line">    <span class="string">"golang.org/x/net/http2"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    client := http.Client{</div><div class="line">        <span class="comment">// Skip TLS dial</span></div><div class="line">        Transport: &http2.Transport{</div><div class="line">            AllowHTTP: <span class="constant">true</span>,</div><div class="line">            DialTLS: <span class="keyword">func</span>(network, addr <span class="typename">string</span>, cfg *tls.Config) (net.Conn, error) {</div><div class="line">                <span class="keyword">return</span> net.Dial(network, addr)</div><div class="line">            },</div><div class="line">        },</div><div class="line">    }</div><div class="line"></div><div class="line">    resp, err := client.Get(<span class="string">"http://localhost:8972"</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        log.Fatal(fmt.Errorf(<span class="string">"error making request: %v"</span>, err))</div><div class="line">    }</div><div class="line">    fmt.Println(resp.StatusCode)</div><div class="line">    fmt.Println(resp.Proto)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个功能的讨论2016年就开始了(<a href="https://github.com/golang/go/issues/14141" target="_blank" rel="external">issue#14141</a>)，最终5月份的这个功能加上了，这样你就可以在没有TLS使用http/2高性能的特性了。</p>
<p>虽然有一些第三方的实现，但是显然使用官方库是更好的选择。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>了解一下http2和h2c (HTTP/2 over TCP,HTTP/2 without TLS)。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[区块链中的共识算法]]></title>
    <link href="https://colobu.com/2018/09/05/consensus-mechanisms-in-blockchain/"/>
    <id>https://colobu.com/2018/09/05/consensus-mechanisms-in-blockchain/</id>
    <published>2018-09-05T02:17:56.000Z</published>
    <updated>2018-09-05T03:01:18.203Z</updated>
    <content type="html"><![CDATA[<p>先占个坑， 慢慢整理。</p>
<blockquote>
<p>本文是正在整理，当你看不到这句话的时候，意味着整理完成了。</p>
</blockquote>
<p>最近<a href="https://101blockchains.com/consensus-algorithms-blockchain/" target="_blank" rel="external">101blockchains</a> 列举了常用的区块链的公式算法，并且详细介绍了这些算法的思想、好处和坏处，当然其它文章中还介绍了一些公式算法。正如文章中所说，没有一个共识算法是完美的，采用哪种算法是一个tradeoff的过程。</p>
<p>本文整理了区块链的公式算法，包括算法思想介绍、好处和不好的地方。<br><a id="more"></a></p>
<p><img src="Different_Consensus_Algorithms.png" alt="来自101blockchains"></p>
<h3 id="POW">POW</h3>
<p><code>Proof of Work</code><br>区块链网络中第一个引入的公式算法，基于算了的共识算法。</p>
<h3 id="POS">POS</h3>
<p><code>Proof of Stake</code></p>
<h3 id="DPOS">DPOS</h3>
<p><code>Delegated Proof-of-Stake</code></p>
<h3 id="LPOS">LPOS</h3>
<p><code>Leased Proof-Of-Stake</code></p>
<h3 id="POE">POE</h3>
<p><code>Proof of Elapsed Time</code></p>
<h3 id="BFT">BFT</h3>
<p><code>Byzantine Fault Tolerance</code></p>
<h4 id="PBFT">PBFT</h4>
<p><code>Practical Byzantine Fault Tolerance</code></p>
<h4 id="SBFT">SBFT</h4>
<p><code>Simplified Byzantine Fault Tolerance</code></p>
<h4 id="DBFT">DBFT</h4>
<p><code>Delegated Byzantine Fault Tolerance</code></p>
<h3 id="DAG">DAG</h3>
<p><code>Directed Acyclic Graphs</code></p>
<h3 id="POA">POA</h3>
<p><code>Proof-of-Activity</code></p>
<h3 id="POI">POI</h3>
<p><code>Proof-of-Importance</code></p>
<h3 id="POC">POC</h3>
<p><code>Proof-of-Capacity</code></p>
<h3 id="POB">POB</h3>
<p><code>Proof-of-Burn</code></p>
<h3 id="POW-1">POW</h3>
<p><code>Proof-of-Weight</code></p>
<h3 id="POA-1">POA</h3>
<p><code>Proof-of-Authority</code></p>
<p>维基百科上有一些区块链公式算法的介绍，但是不多，甚至这个词条还没有被创建。</p>
<p><img src="consensus-mechanisms.png" alt=""></p>
<h3 id="参考资料">参考资料</h3>
<ol>
<li><a href="https://101blockchains.com/consensus-algorithms-blockchain/" target="_blank" rel="external">https://101blockchains.com/consensus-algorithms-blockchain/</a></li>
<li><a href="https://hackernoon.com/a-hitchhikers-guide-to-consensus-algorithms-d81aae3eb0e3" target="_blank" rel="external">https://hackernoon.com/a-hitchhikers-guide-to-consensus-algorithms-d81aae3eb0e3</a></li>
<li><a href="https://medium.com/coinmonks/blockchain-consensus-algorithms-an-early-days-overview-2973f0cf49c6" target="_blank" rel="external">https://medium.com/coinmonks/blockchain-consensus-algorithms-an-early-days-overview-2973f0cf49c6</a></li>
<li><a href="http://jips-k.org/file/down?pn=530" target="_blank" rel="external">http://jips-k.org/file/down?pn=530</a></li>
<li><a href="https://www.logicsolutions.com/5-types-blockchain-consensus-mechanisms/" target="_blank" rel="external">https://www.logicsolutions.com/5-types-blockchain-consensus-mechanisms/</a></li>
<li><a href="https://www.coindesk.com/short-guide-blockchain-consensus-protocols/" target="_blank" rel="external">https://www.coindesk.com/short-guide-blockchain-consensus-protocols/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Proof-of-stake" target="_blank" rel="external">https://en.wikipedia.org/wiki/Proof-of-stake</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>先占个坑， 慢慢整理。</p>
<blockquote>
<p>本文是正在整理，当你看不到这句话的时候，意味着整理完成了。</p>
</blockquote>
<p>最近<a href="https://101blockchains.com/consensus-algorithms-blockchain/" target="_blank" rel="external">101blockchains</a> 列举了常用的区块链的公式算法，并且详细介绍了这些算法的思想、好处和坏处，当然其它文章中还介绍了一些公式算法。正如文章中所说，没有一个共识算法是完美的，采用哪种算法是一个tradeoff的过程。</p>
<p>本文整理了区块链的公式算法，包括算法思想介绍、好处和不好的地方。<br>]]>
    
    </summary>
    
      <category term="区块链" scheme="https://colobu.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[给 iTerm 设置代理]]></title>
    <link href="https://colobu.com/2018/09/05/set-proxy-for-iterm/"/>
    <id>https://colobu.com/2018/09/05/set-proxy-for-iterm/</id>
    <published>2018-09-05T01:11:26.000Z</published>
    <updated>2018-09-05T01:24:13.958Z</updated>
    <content type="html"><![CDATA[<p>如果你用SS FQ的话， Shadow-Socks设置的系统代理是socks5代理，在iTerm中访问一些https还是不能用， 比如用<code>go get</code>下载一些依赖的库。一个办法就是使用Privoxy将socks5代理转换成http代理。</p>
<h3 id="Privoxy">Privoxy</h3>
<p>MacOS安装Privoxy比较简单。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">-&gt; brew install privoxy</div><div class="line"></div><div class="line"></div><div class="line">==&gt; Downloading https://homebrew.bintray.com/bottles/privoxy-<span class="number">3.0</span>.<span class="number">26</span>.sierra.bottl</div><div class="line"><span class="comment">######################################################################## 100.0%</span></div><div class="line">==&gt; Pouring privoxy-<span class="number">3.0</span>.<span class="number">26</span>.sierra.bottle.<span class="number">1</span>.tar.gz</div><div class="line">==&gt; Caveats</div><div class="line">To have launchd start privoxy now and restart at login:</div><div class="line">  brew services start privoxy</div><div class="line">Or, <span class="keyword">if</span> you don<span class="string">'t want/need a background service you can just run:</span></div><div class="line">  privoxy /usr/local/etc/privoxy/config</div><div class="line">==&gt; Summary</div><div class="line">?  /usr/local/Cellar/privoxy/3.0.26: 52 files, 1.8MB</div></pre></td></tr></table></figure>

<p>你可以使用<code>brew services start privoxy</code>启动privoxy服务，或者手工临时启动<code>privoxy /usr/local/etc/privoxy/config</code>也可以。</p>
<p>如果中间需要<code>brew link privoxy</code>按照提示创建文件夹，比如<code>/usr/local/sbin</code>，设置对应的权限即可。</p>
<p>启动服务前先编辑<code>vim /usr/local/etc/privoxy/config</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">listen-address 127.0.0.1:8118</div><div class="line">forward-socks5 / 127.0.0.1:1080 .</div><div class="line"></div><div class="line">forward 192.168.<span class="keyword">*</span>.<span class="keyword">*</span>/ .</div><div class="line">forward 10.<span class="keyword">*</span>.<span class="keyword">*</span>.<span class="keyword">*</span>/ .</div><div class="line">forward 127.<span class="keyword">*</span>.<span class="keyword">*</span>.<span class="keyword">*</span>/</div></pre></td></tr></table></figure>

<p><code>8118</code>是本机要监听的http代理地址， <code>1080</code>是SS的socks5代理地址,还设置本地地址。</p>
<h3 id="配置http代理">配置http代理</h3>
<p>通过下面的环境变量就可以设置http代理。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> http_proxy=http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8087</span></div><div class="line"><span class="keyword">export</span> https_proxy=<span class="variable">$http_proxy</span></div></pre></td></tr></table></figure>

<p>你可以把它们写在 <code>~/.zshrc</code> 或者 <code>~/.bash_profile</code>中，随时切换。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alias goproxy=<span class="string">'export http_proxy=http://127.0.0.1:8087 https_proxy=http://127.0.0.1:8087'</span></div><div class="line">alias disproxy=<span class="string">'unset http_proxy https_proxy'</span></div></pre></td></tr></table></figure>

<p><strong>参考</strong></p>
<ol>
<li><a href="https://segmentfault.com/a/1190000008848001" target="_blank" rel="external">https://segmentfault.com/a/1190000008848001</a></li>
<li><a href="https://honglu.me/2015/11/06/给iTerm终端设置代理/" target="_blank" rel="external">https://honglu.me/2015/11/06/给iTerm终端设置代理/</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果你用SS FQ的话， Shadow-Socks设置的系统代理是socks5代理，在iTerm中访问一些https还是不能用， 比如用<code>go get</code>下载一些依赖的库。一个办法就是使用Privoxy将socks5代理转换成http代理。</p>
<h]]>
    </summary>
    
      <category term="工具" scheme="https://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[快速产生一个随机字符串]]></title>
    <link href="https://colobu.com/2018/09/02/generate-random-string-in-Go/"/>
    <id>https://colobu.com/2018/09/02/generate-random-string-in-Go/</id>
    <published>2018-09-02T06:41:49.000Z</published>
    <updated>2018-09-03T02:23:27.838Z</updated>
    <content type="html"><![CDATA[<p>如何高效的产生一个随机字符串？这看似是一个简单的问题，但是icza却通过例子，逐步优化，实现了一个更高效的随机字符串的算法。这是来自的来自stackoverflow上的一个问题：<a href="https://stackoverflow.com/questions/22892120/how-to-generate-a-random-string-of-a-fixed-length-in-go" target="_blank" rel="external">How to generate a random string of a fixed length in Go?</a>, 大家群策群力，提出了很好的方案和反馈，尤其是icza的回答。 本文翻译和整理自这条问答。</p>
<a id="more"></a>
<p>问题是这样的：</p>
<blockquote>
<p>我想要一个Go实现的固定长度的随机字符串(包括大小写字母，但是没有数字)，哪种方式最快最简单？</p>
</blockquote>
<p>优化基于Paul Hankin提出的一种方案(第一种方案)，也就是最基本最容易理解的一种方案， icza基于这个方案逐步优化。</p>
<h3 id="最通用的方案">最通用的方案</h3>
<p>最普通方案就是随机产生每个字符，所以整体字符串也是随机的。这样的好处是可以控制要使用的字符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> init() {</div><div class="line">    rand.Seed(time.Now().UnixNano())</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> letterRunes = []<span class="typename">rune</span>(<span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>)</div><div class="line"></div><div class="line"><span class="keyword">func</span> RandStringRunes(n <span class="typename">int</span>) <span class="typename">string</span> {</div><div class="line">    b := <span class="built_in">make</span>([]<span class="typename">rune</span>, n)</div><div class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> b {</div><div class="line">        b[i] = letterRunes[rand.Intn(<span class="built_in">len</span>(letterRunes))]</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="typename">string</span>(b)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="字节替换rune">字节替换rune</h3>
<p>如果需求是只使用英语字母字符(包括大小写)，那么我们可以使用byte替换rune,因为UTF-8编码中英语字母和byte是一一对应的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> letterBytes = <span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> RandStringBytes(n <span class="typename">int</span>) <span class="typename">string</span> {</div><div class="line">    b := <span class="built_in">make</span>([]<span class="typename">byte</span>, n)</div><div class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> b {</div><div class="line">        b[i] = letterBytes[rand.Intn(<span class="built_in">len</span>(letterBytes))]</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="typename">string</span>(b)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="使用余数">使用余数</h3>
<p>上一步中我们使用<code>rand.Intn</code>来随机选择一个字符， <code>rand.Intn</code>会调用<code>Rand.Intn</code>, 而<code>Rand.Intn</code>会调用<code>Rand.Int31n</code>，它会比直接调用<code>rand.Int63</code>慢，后者会产生一个63bit的随机整数。</p>
<p>我们可以使用<code>rand.Int63</code>,然后除以<code>len(letterBytes)</code>的余数来选择字符：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> RandStringBytesRmndr(n <span class="typename">int</span>) <span class="typename">string</span> {</div><div class="line">    b := <span class="built_in">make</span>([]<span class="typename">byte</span>, n)</div><div class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> b {</div><div class="line">        b[i] = letterBytes[rand.Int63() % <span class="typename">int64</span>(<span class="built_in">len</span>(letterBytes))]</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="typename">string</span>(b)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个实现明显会比上面的解决方案快，但是有一点小小的瑕疵：那就是字符被选择的概率并不是完全一样。但是这个差别是非常非常的小(字符的数量52远远小于1&lt;&lt;63 -1),<br>只是理论上会有差别，实践中可以忽略不计。</p>
<h3 id="掩码">掩码</h3>
<p>通过前面的方案，我们可以看到我们并不需要太多的bit来决定字符的平均分布，事实上我们只需要随机整数的后几个bit就可以来选择字母。对于52个英语字母(大小写)， 只需要6个bit就可以实现均匀分布(<code>52=110100b</code>)，所以我们可以使用<code>rand.Int63</code>后6个bit来实现，我们只接受后六位在<code>0..len(letterBytes)-1</code>的随机数，如果不在这个范围，丢弃重选。 通过掩码就可以得到一个整数的后6个bit。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> letterBytes = <span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    letterIdxBits =<span class="number"> 6</span>                    <span class="comment">// 6 bits to represent a letter index</span></div><div class="line">    letterIdxMask =<span class="number"> 1</span>&lt;&lt;letterIdxBits -<span class="number"> 1</span> <span class="comment">// All 1-bits, as many as letterIdxBits</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> RandStringBytesMask(n <span class="typename">int</span>) <span class="typename">string</span> {</div><div class="line">    b := <span class="built_in">make</span>([]<span class="typename">byte</span>, n)</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; n; {</div><div class="line">        <span class="keyword">if</span> idx := <span class="typename">int</span>(rand.Int63() & letterIdxMask); idx &lt; <span class="built_in">len</span>(letterBytes) {</div><div class="line">            b[i] = letterBytes[idx]</div><div class="line">            i++</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="typename">string</span>(b)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="掩码加强版">掩码加强版</h3>
<p>上面有个不好的地方，会产生大量的丢弃的case,造成重选和浪费。<code>rand.Int63</code>会产生63bit的随机数，如果我们把它分成6份，那么一次就可以产生10个6bit的随机数。这样就减少了浪费。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">const</span> letterBytes = <span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    letterIdxBits =<span class="number"> 6</span>                    <span class="comment">// 6 bits to represent a letter index</span></div><div class="line">    letterIdxMask =<span class="number"> 1</span>&lt;&lt;letterIdxBits -<span class="number"> 1</span> <span class="comment">// All 1-bits, as many as letterIdxBits</span></div><div class="line">    letterIdxMax  =<span class="number"> 63</span> / letterIdxBits   <span class="comment">// # of letter indices fitting in 63 bits</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> RandStringBytesMaskImpr(n <span class="typename">int</span>) <span class="typename">string</span> {</div><div class="line">    b := <span class="built_in">make</span>([]<span class="typename">byte</span>, n)</div><div class="line">    <span class="comment">// A rand.Int63() generates 63 random bits, enough for letterIdxMax letters!</span></div><div class="line">    <span class="keyword">for</span> i, cache, remain := n<span class="number">-1</span>, rand.Int63(), letterIdxMax; i &gt;=<span class="number"> 0</span>; {</div><div class="line">        <span class="keyword">if</span> remain ==<span class="number"> 0</span> {</div><div class="line">            cache, remain = rand.Int63(), letterIdxMax</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> idx := <span class="typename">int</span>(cache & letterIdxMask); idx &lt; <span class="built_in">len</span>(letterBytes) {</div><div class="line">            b[i] = letterBytes[idx]</div><div class="line">            i--</div><div class="line">        }</div><div class="line">        cache &gt;&gt;= letterIdxBits</div><div class="line">        remain--</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="typename">string</span>(b)</div><div class="line">}</div></pre></td></tr></table></figure>



<h3 id="Source">Source</h3>
<p>上面的代码的确好，没有太多可以改进的地方，即使可以提升，也得花费很大的复杂度。</p>
<p>我们可以从另外一个方面进行优化，那就是提高随机数的产生(source)。</p>
<p><code>crypto/rand</code>包提供了<code>Read(b []byte)</code>的方法，它可以随机生成我们所需bit的字节，但是因为处于安全方面的设计和检查，它的随机数产生比较慢。</p>
<p>我们再转回<code>math/rand</code>，<code>rand.Rand</code>使用<code>rand.Source</code>来产生随机bit。<code>rand.Source</code>是一个接口，提供了<code>Int63() int64</code>,正是我们所需要的。</p>
<p>所以我们可以直接使用<code>rand.Source</code>，而不是全局或者共享的随机源。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> src = rand.NewSource(time.Now().UnixNano())</div><div class="line"></div><div class="line"><span class="keyword">func</span> RandStringBytesMaskImprSrc(n <span class="typename">int</span>) <span class="typename">string</span> {</div><div class="line">    b := <span class="built_in">make</span>([]<span class="typename">byte</span>, n)</div><div class="line">    <span class="comment">// A src.Int63() generates 63 random bits, enough for letterIdxMax characters!</span></div><div class="line">    <span class="keyword">for</span> i, cache, remain := n<span class="number">-1</span>, src.Int63(), letterIdxMax; i &gt;=<span class="number"> 0</span>; {</div><div class="line">        <span class="keyword">if</span> remain ==<span class="number"> 0</span> {</div><div class="line">            cache, remain = src.Int63(), letterIdxMax</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> idx := <span class="typename">int</span>(cache & letterIdxMask); idx &lt; <span class="built_in">len</span>(letterBytes) {</div><div class="line">            b[i] = letterBytes[idx]</div><div class="line">            i--</div><div class="line">        }</div><div class="line">        cache &gt;&gt;= letterIdxBits</div><div class="line">        remain--</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="typename">string</span>(b)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>全局的(默认的)随机源是线程安全，里面用到了锁，所以没有我们直接<code>rand.Source</code>更好。</p>
<p>下面的代码是全局的随机源，可以看到<code>Lock/Unlock</code>的使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Int63() <span class="typename">int64</span> { <span class="keyword">return</span> globalRand.Int63() }</div><div class="line"></div><div class="line"><span class="keyword">var</span> globalRand = New(&lockedSource{src: NewSource<span class="number">(1</span>).(Source64)})</div><div class="line"></div><div class="line"><span class="keyword">type</span> lockedSource <span class="keyword">struct</span> {</div><div class="line"></div><div class="line">	lk  sync.Mutex</div><div class="line"></div><div class="line">	src Source64</div><div class="line"></div><div class="line">}</div><div class="line"><span class="keyword">func</span> (r *lockedSource) Int63() (n <span class="typename">int64</span>) {</div><div class="line"></div><div class="line">	r.lk.Lock()</div><div class="line"></div><div class="line">	n = r.src.Int63()</div><div class="line"></div><div class="line">	r.lk.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">return</span></div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>Go1.7中增加了<code>rand.Read()</code>方法和<code>Rand.Read()</code>函数，我们可以尝试使用它得到一组随机bit,用来获取更高的性能。</p>
<p>一个小问题就是取多少字节的随机数比较好？我们可以说: 和输出字符一样多的。这是一个上限估计，因为字符的索引会少于8bit。<br>为了维护字符的均匀分布，我们不得不丢弃一些随机数，这可能会获取更多的随机数，所以只能预估大约需要<code>n * letterIdxBits / 8.0</code>字节的随机byte。</p>
<p>当然最好的验证方法就是写一个Benchmark,附录是benchmark的代码，以下是测试的结果:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="title">BenchmarkRunes</span>                   <span class="number">1000000</span>              <span class="number">1703</span> ns/op</div><div class="line">BenchmarkBytes                   <span class="number">1000000</span>              <span class="number">1328</span> ns/op</div><div class="line">BenchmarkBytesRmndr              <span class="number">1000000</span>              <span class="number">1012</span> ns/op</div><div class="line">BenchmarkBytesMask               <span class="number">1000000</span>              <span class="number">1214</span> ns/op</div><div class="line">BenchmarkBytesMaskImpr           <span class="number">5000000</span>               <span class="number">395</span> ns/op</div><div class="line">BenchmarkBytesMaskImprSrc        <span class="number">5000000</span>               <span class="number">303</span> ns/op</div></pre></td></tr></table></figure>

<h3 id="Benchmark代码">Benchmark代码</h3>
<figure class="highlight go"><figcaption><span>BenchmarkRandomString_test.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"math/rand"</span></div><div class="line">	<span class="string">"testing"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Implementations</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> init() {</div><div class="line">	rand.Seed(time.Now().UnixNano())</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> letterRunes = []<span class="typename">rune</span>(<span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>)</div><div class="line"></div><div class="line"><span class="keyword">func</span> RandStringRunes(n <span class="typename">int</span>) <span class="typename">string</span> {</div><div class="line">	b := <span class="built_in">make</span>([]<span class="typename">rune</span>, n)</div><div class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> b {</div><div class="line">		b[i] = letterRunes[rand.Intn(<span class="built_in">len</span>(letterRunes))]</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="typename">string</span>(b)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> letterBytes = <span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	letterIdxBits =<span class="number"> 6</span>                    <span class="comment">// 6 bits to represent a letter index</span></div><div class="line">	letterIdxMask =<span class="number"> 1</span>&lt;&lt;letterIdxBits -<span class="number"> 1</span> <span class="comment">// All 1-bits, as many as letterIdxBits</span></div><div class="line">	letterIdxMax  =<span class="number"> 63</span> / letterIdxBits   <span class="comment">// # of letter indices fitting in 63 bits</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> RandStringBytes(n <span class="typename">int</span>) <span class="typename">string</span> {</div><div class="line">	b := <span class="built_in">make</span>([]<span class="typename">byte</span>, n)</div><div class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> b {</div><div class="line">		b[i] = letterBytes[rand.Intn(<span class="built_in">len</span>(letterBytes))]</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="typename">string</span>(b)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> RandStringBytesRmndr(n <span class="typename">int</span>) <span class="typename">string</span> {</div><div class="line">	b := <span class="built_in">make</span>([]<span class="typename">byte</span>, n)</div><div class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> b {</div><div class="line">		b[i] = letterBytes[rand.Int63()%<span class="typename">int64</span>(<span class="built_in">len</span>(letterBytes))]</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="typename">string</span>(b)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> RandStringBytesMask(n <span class="typename">int</span>) <span class="typename">string</span> {</div><div class="line">	b := <span class="built_in">make</span>([]<span class="typename">byte</span>, n)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; n; {</div><div class="line">		<span class="keyword">if</span> idx := <span class="typename">int</span>(rand.Int63() & letterIdxMask); idx &lt; <span class="built_in">len</span>(letterBytes) {</div><div class="line">			b[i] = letterBytes[idx]</div><div class="line">			i++</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="typename">string</span>(b)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> RandStringBytesMaskImpr(n <span class="typename">int</span>) <span class="typename">string</span> {</div><div class="line">	b := <span class="built_in">make</span>([]<span class="typename">byte</span>, n)</div><div class="line">	<span class="comment">// A rand.Int63() generates 63 random bits, enough for letterIdxMax letters!</span></div><div class="line">	<span class="keyword">for</span> i, cache, remain := n<span class="number">-1</span>, rand.Int63(), letterIdxMax; i &gt;=<span class="number"> 0</span>; {</div><div class="line">		<span class="keyword">if</span> remain ==<span class="number"> 0</span> {</div><div class="line">			cache, remain = rand.Int63(), letterIdxMax</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> idx := <span class="typename">int</span>(cache & letterIdxMask); idx &lt; <span class="built_in">len</span>(letterBytes) {</div><div class="line">			b[i] = letterBytes[idx]</div><div class="line">			i--</div><div class="line">		}</div><div class="line">		cache &gt;&gt;= letterIdxBits</div><div class="line">		remain--</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="typename">string</span>(b)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> src = rand.NewSource(time.Now().UnixNano())</div><div class="line"></div><div class="line"><span class="keyword">func</span> RandStringBytesMaskImprSrc(n <span class="typename">int</span>) <span class="typename">string</span> {</div><div class="line">	b := <span class="built_in">make</span>([]<span class="typename">byte</span>, n)</div><div class="line">	<span class="comment">// A src.Int63() generates 63 random bits, enough for letterIdxMax characters!</span></div><div class="line">	<span class="keyword">for</span> i, cache, remain := n<span class="number">-1</span>, src.Int63(), letterIdxMax; i &gt;=<span class="number"> 0</span>; {</div><div class="line">		<span class="keyword">if</span> remain ==<span class="number"> 0</span> {</div><div class="line">			cache, remain = src.Int63(), letterIdxMax</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> idx := <span class="typename">int</span>(cache & letterIdxMask); idx &lt; <span class="built_in">len</span>(letterBytes) {</div><div class="line">			b[i] = letterBytes[idx]</div><div class="line">			i--</div><div class="line">		}</div><div class="line">		cache &gt;&gt;= letterIdxBits</div><div class="line">		remain--</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="typename">string</span>(b)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Benchmark functions</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> n =<span class="number"> 16</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkRunes(b *testing.B) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		RandStringRunes(n)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkBytes(b *testing.B) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		RandStringBytes(n)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkBytesRmndr(b *testing.B) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		RandStringBytesRmndr(n)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkBytesMask(b *testing.B) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		RandStringBytesMask(n)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkBytesMaskImpr(b *testing.B) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		RandStringBytesMaskImpr(n)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkBytesMaskImprSrc(b *testing.B) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		RandStringBytesMaskImprSrc(n)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="其它提升">其它提升</h3>
<p>其实如果能替换一个性能更好的随机数生成算法，可能性能会更好，我使用<a href="https://en.wikipedia.org/wiki/Xorshift" target="_blank" rel="external">Xorshift</a>算法实现了一个快速的随机数生成器， 和前面的实现做了比较，发觉性能会更好一点。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BenchmarkRunes-4                         1000000              1396 ns/op</div><div class="line">BenchmarkBytes-4                         2000000               799 ns/op</div><div class="line">BenchmarkBytesRmndr-4                    3000000               627 ns/op</div><div class="line">BenchmarkBytesMask-4                     2000000               719 ns/op</div><div class="line">BenchmarkBytesMaskImpr-4                10000000               260 ns/op</div><div class="line">BenchmarkBytesMaskImprSrc-4             10000000               227 ns/op</div><div class="line">BenchmarkBytesMaskImprXorshiftSrc-4     10000000               205 ns/op</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>如何高效的产生一个随机字符串？这看似是一个简单的问题，但是icza却通过例子，逐步优化，实现了一个更高效的随机字符串的算法。这是来自的来自stackoverflow上的一个问题：<a href="https://stackoverflow.com/questions/22892120/how-to-generate-a-random-string-of-a-fixed-length-in-go" target="_blank" rel="external">How to generate a random string of a fixed length in Go?</a>, 大家群策群力，提出了很好的方案和反馈，尤其是icza的回答。 本文翻译和整理自这条问答。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C和Go相互调用]]></title>
    <link href="https://colobu.com/2018/08/28/c-and-go-calling-interaction/"/>
    <id>https://colobu.com/2018/08/28/c-and-go-calling-interaction/</id>
    <published>2018-08-28T11:45:46.000Z</published>
    <updated>2018-08-30T03:37:31.115Z</updated>
    <content type="html"><![CDATA[<p>C可以调用Go，并且Go可以调用C， 如果更进一步呢， <code>C--&gt;Go--&gt;C</code> 或者 <code>Go--&gt;C--&gt;Go</code>的调用如何实现？</p>
<p>本文通过两个简单的例子帮助你了解这两种复杂的调用关系。本文不涉及两者之间的复杂的数据转换，官方文章<a href="https://blog.golang.org/c-go-cgo" target="_blank" rel="external">C? Go? Cgo!</a>、<a href="https://github.com/golang/go/wiki/cgo" target="_blank" rel="external">wiki/cgo</a>和<a href="http://golang.org/cmd/cgo" target="_blank" rel="external">cmd/cgo</a>有一些介绍。</p>
<a id="more"></a>
<h2 id="Go-&gt;C-&gt;Go">Go--&gt;C--&gt;Go</h2>
<p>Go程序调用C实现的函数，然后C实现的函数又调用Go实现的函数。</p>
<p>1、首先，我们新建一个<code>hello.go</code>的文件：</p>
<figure class="highlight go"><figcaption><span>hello.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="comment">//export HelloFromGo</span></div><div class="line"><span class="keyword">func</span> HelloFromGo() {</div><div class="line">	fmt.Printf(<span class="string">"Hello from Go!\n"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>它定义了一个<code>HelloFromGo</code>函数，注意这个函数是一个纯的Go函数，我们定义它的输出符号为<code>HelloFromGo</code>。</p>
<p>2、接着我们新建一个<code>hello.c</code>的文件：</p>
<figure class="highlight c"><figcaption><span>hello.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "_cgo_export.h"</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> helloFromC() {</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hi from C\n"</span>);</div><div class="line">    <span class="comment">//call Go function</span></div><div class="line">    HelloFromGo();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个c文件定义了一个C函数<code>helloFromC</code>,内部它会调用我们刚才定义的<code>HelloFromGo</code>函数。</p>
<p>这样，我们实现了<code>C</code>调用<code>Go</code>: <code>C--&gt;Go</code>,下面我们再实现Go调用C。</p>
<p>3、最后新建一个<code>main.go</code>文件：</p>
<figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">extern int helloFromC();</div><div class="line">*/</div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">//call c function</span></div><div class="line">	C.helloFromC()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>它调用第二步实现的C函数<code>helloFromC</code>。</p>
<p>运行测试一下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ go run .</div><div class="line">Hi from C</div><div class="line">Hello from Go!</div></pre></td></tr></table></figure>

<p>可以看到，期望的函数调用正常的运行。第一行是C函数的输出，第二行是Go函数的输出。</p>
<h2 id="C-&gt;Go-&gt;C">C--&gt;Go--&gt;C</h2>
<p>第二个例子演示了C程序调用Go实现的函数，然后Go实现的函数又调用C实现的函数。</p>
<p>1、首先新建一个<code>hello.c</code>文件：</p>
<figure class="highlight c"><figcaption><span>hello.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> helloFromC() {</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hi from C\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>它定义了一个纯C实现的函数。</p>
<p>2、接着新建一个<code>hello.go</code>文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// go build -o hello.so -buildmode=c-shared .</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">extern int helloFromC();</div><div class="line">*/</div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="comment">//export HelloFromGo</span></div><div class="line"><span class="keyword">func</span> HelloFromGo() {</div><div class="line">	fmt.Printf(<span class="string">"Hello from Go!\n"</span>)</div><div class="line">	C.helloFromC()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>它实现了一个Go函数<code>HelloFromGo</code>,内部实现调用了C实现的函数<code>helloFromC</code>,这样我们就实现了<code>Go--&gt;C</code>。</p>
<p>注意包名设置为<code>package main</code>，并且增加一个空的<code>main</code>函数。</p>
<p>运行<code>go build -o hello.so -buildmode=c-shared .</code>生成一个C可以调用的库，这调命令执行完后会生成<code>hello.so</code>文件和<code>hello.h</code>文件。</p>
<p>3、最后新建一个文件夹，随便起个名字，比如<code>main</code></p>
<p>将刚才生成的<code>hello.so</code>文件和<code>hello.h</code>文件复制到<code>main</code>文件夹，并在<code>main</code>文件夹中新建一个文件<code>main.c</code>:</p>
<figure class="highlight c"><figcaption><span>main.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "hello.h"</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"use hello lib from C:\n"</span>);</div><div class="line">   </div><div class="line">    HelloFromGo();</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行<code>gcc -o main main.c hello.so</code>生成可执行文件<code>main</code>, 运行<code>main</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ./main</div><div class="line">use hello lib from C:</div><div class="line">Hello from Go!</div><div class="line">Hi from C</div></pre></td></tr></table></figure>

<p>第一行输出来自<code>main.c</code>,第二行来自Go函数，第三行来自<code>hello.c</code>中的C函数，这样我们就实现了<code>C--&gt;Go--C</code>的复杂调用。</p>
<h3 id="C-&gt;Go-&gt;C的状态变量"><code>C--&gt;Go--&gt;C</code>的状态变量</h3>
<p>我们来分析第二步中的一个特殊的场景， 为了下面我们好区分，我们给程序标记一下， 记为<code>C1--&gt;Go--&gt;C2</code>, C2的程序修改一下，加入一个状态变量<code>a</code>,并且函数<code>helloFromC</code>中会打印<code>a</code>的地址和值，也会将<code>a</code>加一。</p>
<figure class="highlight c"><figcaption><span>hello.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span>  a = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> helloFromC() {</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hi from C: %p, %d\n"</span>, &a, a++);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后修改<code>main.c</code>程序,让它既通过Go嗲用<code>C1.helloFromC</code>,又直接调用<code>C1.helloFromC</code>,看看多次调用的时候<code>a</code>的指针是否一致，并且<code>a</code>的值是否有变化。</p>
<figure class="highlight c"><figcaption><span>main.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "hello.h"</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"use hello lib from C:\n"</span>);</div><div class="line">   </div><div class="line">    <span class="comment">// 1. 直接调用C函数</span></div><div class="line">    helloFromC();</div><div class="line"></div><div class="line">    <span class="comment">// 2. 调用Go函数</span></div><div class="line">    HelloFromGo();</div><div class="line">    </div><div class="line">    <span class="comment">// 3. 直接调用C函数</span></div><div class="line">    helloFromC();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>激动人心的时候到了。我们不同的编译方式会产生不同的结果。</p>
<p>1、<code>gcc -o main main.c hello.so</code></p>
<p>和第二步相同的编译方式，编译出<code>main</code>并执行， 因为<code>hello.so</code>中包含<code>C1.helloFromC</code>实现，所以可以正常执行。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">./main</div><div class="line">use hello lib from C:</div><div class="line">Hi from C: <span class="number">0</span>x10092a370, <span class="number">1</span></div><div class="line">Hello from Go!</div><div class="line">Hi from C: <span class="number">0</span>x10092a370, <span class="number">2</span></div><div class="line">Hi from C: <span class="number">0</span>x10092a370, <span class="number">3</span></div></pre></td></tr></table></figure>

<p>可以看到<code>a</code>的指针是同一个值，无论通过Go函数改变还是通过C函数改变都是更改的同一个变量。</p>
<p>nm可以查看生成的<code>main</code>的符号：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">nm main</div><div class="line">                 U _HelloFromGo</div><div class="line"><span class="number">0000000100000000</span> T __mh_execute_header</div><div class="line">                 U _helloFromC</div><div class="line"><span class="number">0000000100000</span>f10 T _main</div><div class="line">                 U _<span class="built_in">printf</span></div><div class="line">                 U dyld_stub_binder</div></pre></td></tr></table></figure>

<p><code>U</code>代表这个符号是未定义的符号，通过动态库链接进来。</p>
<p>2、 <code>gcc -o main main.c hello.so ../hello.c</code></p>
<p>我们编译的时候直接链接<code>hello.c</code>的实现，然后运行<code>main</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">./main</div><div class="line">use hello lib from C:</div><div class="line">Hi from C: <span class="number">0</span>x104888020, <span class="number">1</span></div><div class="line">Hello from Go!</div><div class="line">Hi from C: <span class="number">0</span>x1049f7370, <span class="number">1</span></div><div class="line">Hi from C: <span class="number">0</span>x104888020, <span class="number">2</span></div></pre></td></tr></table></figure>

<p>可以看到<code>a</code>是不同的两个变量。</p>
<p>nm可以查看生成的<code>main</code>的符号：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">nm main</div><div class="line">                 U _HelloFromGo</div><div class="line"><span class="number">0000000100000000</span> T __mh_execute_header</div><div class="line"><span class="number">0000000100001020</span> D _a</div><div class="line"><span class="number">0000000100000</span>f10 T _helloFromC</div><div class="line"><span class="number">0000000100000</span>ec0 T _main</div><div class="line">                 U _<span class="built_in">printf</span></div><div class="line">                 U dyld_stub_binder</div></pre></td></tr></table></figure>

<p>可以看到<code>_a</code>是初始化的环境变量，<code>_helloFromC</code>的类型是<code>T</code>而不是<code>U</code>,代表它是一个全局的Text符号,这和上一步是不一样的。</p>
<h3 id="参考文档">参考文档</h3>
<ol>
<li><a href="https://medium.com/using-go-in-mobile-apps/using-go-in-mobile-apps-part-1-calling-go-functions-from-c-be1ecf7dfbc6" target="_blank" rel="external">https://medium.com/using-go-in-mobile-apps/using-go-in-mobile-apps-part-1-calling-go-functions-from-c-be1ecf7dfbc6</a></li>
<li><a href="https://github.com/vladimirvivien/go-cshared-examples" target="_blank" rel="external">https://github.com/vladimirvivien/go-cshared-examples</a></li>
<li><a href="http://golang.org/cmd/cgo" target="_blank" rel="external">http://golang.org/cmd/cgo</a></li>
<li><a href="https://gist.github.com/zchee/b9c99695463d8902cd33" target="_blank" rel="external">https://gist.github.com/zchee/b9c99695463d8902cd33</a></li>
<li><a href="https://medium.com/@liamkelly17/working-with-packed-c-structs-in-cgo-224a0a3b708b" target="_blank" rel="external">https://medium.com/@liamkelly17/working-with-packed-c-structs-in-cgo-224a0a3b708b</a></li>
<li><a href="https://groups.google.com/forum/#!topic/golang-nuts/EhndTzcPJxQ" target="_blank" rel="external">https://groups.google.com/forum/#!topic/golang-nuts/EhndTzcPJxQ</a></li>
<li><a href="https://docs.google.com/document/d/1nr-TQHw_er6GOQRsF6T43GGhFDelrAP0NqSS_00RgZQ/edit#" target="_blank" rel="external">https://docs.google.com/document/d/1nr-TQHw_er6GOQRsF6T43GGhFDelrAP0NqSS_00RgZQ/edit#</a></li>
<li><a href="https://www.mkssoftware.com/docs/man1/nm.1.asp" target="_blank" rel="external">https://www.mkssoftware.com/docs/man1/nm.1.asp</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>C可以调用Go，并且Go可以调用C， 如果更进一步呢， <code>C--&gt;Go--&gt;C</code> 或者 <code>Go--&gt;C--&gt;Go</code>的调用如何实现？</p>
<p>本文通过两个简单的例子帮助你了解这两种复杂的调用关系。本文不涉及两者之间的复杂的数据转换，官方文章<a href="https://blog.golang.org/c-go-cgo" target="_blank" rel="external">C? Go? Cgo!</a>、<a href="https://github.com/golang/go/wiki/cgo" target="_blank" rel="external">wiki/cgo</a>和<a href="http://golang.org/cmd/cgo" target="_blank" rel="external">cmd/cgo</a>有一些介绍。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[翻译]15个最常用的GCC编译器参数]]></title>
    <link href="https://colobu.com/2018/08/28/15-Most-Frequently-Used-GCC-Compiler-Command-Line-Options/"/>
    <id>https://colobu.com/2018/08/28/15-Most-Frequently-Used-GCC-Compiler-Command-Line-Options/</id>
    <published>2018-08-28T08:50:24.000Z</published>
    <updated>2018-08-28T10:35:39.734Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://www.thegeekstuff.com/2012/10/gcc-compiler-options/" target="_blank" rel="external">15 Most Frequently Used GCC Compiler Command Line Options</a> 以及评论中大家提供的一些参数。</p>
<p>GCC编译器是一个日常流行的 C 编译器， 很多Linux的发布版本中都带有这个编译器。这篇文章列举了一些最常用的编译参数。</p>
<p>本文中使用下面的C语言实现的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">   <span class="built_in">printf</span>(<span class="string">"\n The Geek Stuff\n"</span>);</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="指定编译输出的名字">指定编译输出的名字</h3>
<p>gcc编译器最常用的使用格式是:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc main.c</div></pre></td></tr></table></figure>

<p>上面的命令执行完整的编译过程，并且生成一个<code>a.out</code>文件。</p>
<p>使用参数<code>-o</code>, 可以指定输出的文件名。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc main.c -o main</div></pre></td></tr></table></figure>

<p>上面的命令会产生输出文件<code>main</code>。</p>
<p>为了理解GCC编译器的完整的编译过程，可以阅读 <a href="https://www.thegeekstuff.com/2011/10/c-program-to-an-executable/" target="_blank" rel="external">Journey of a C Program to Linux Executable in 4 Stages</a>。</p>
<h3 id="通过-Wall参数启用所有警告">通过<code>-Wall</code>参数启用所有警告</h3>
<p>这个参数可以启用所有警告。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">   <span class="keyword">int</span> i;</div><div class="line">   <span class="built_in">printf</span>(<span class="string">"\n The Geek Stuff [%d]\n"</span>, i);</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码编译时，会出现<code>未初始化的i</code>类似的警告。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ gcc -Wall main.c -o main</div><div class="line">main.c: <span class="keyword">In</span> <span class="function"><span class="keyword">function</span> ‘<span class="title">main</span>’:</span></div><div class="line">main.c:<span class="number">6</span>:<span class="number">10</span>: warning: ‘i’ <span class="keyword">is</span> used uninitialized <span class="keyword">in</span> this <span class="function"><span class="keyword">function</span> [-<span class="title">Wuninitialized</span>]</span></div></pre></td></tr></table></figure>

<h3 id="使用-E参数只产生预处理输出">使用<code>-E</code>参数只产生预处理输出</h3>
<p><code>-E</code>参数是产生预处理阶段的输出。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gcc -E main.c &gt; main.i</div></pre></td></tr></table></figure>

<p>gcc命令将结果输出在<code>stdout</code>中，所以你可以把它重定向到任意的文件中，在上面的例子中，重定向到<code>main.i</code>文件中。</p>
<h3 id="使用-S参数只产生汇编代码">使用<code>-S</code>参数只产生汇编代码</h3>
<p><code>-S</code> 参数产生汇编级别的代码。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -S main.c &gt; main.s</div></pre></td></tr></table></figure>

<p>文件<code>main.s</code>包含汇编代码。</p>
<h3 id="使用-C参数只产生编译的代码">使用<code>-C</code>参数只产生编译的代码</h3>
<p><code>-C</code>参数只产生编译的代码(没有链接link)。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -C main.c</div></pre></td></tr></table></figure>

<p>上面的代码产生<code>main.o</code>, 包含机器级别的代码或者编译的代码。</p>
<h3 id="使用-save-temps参数产生所有的中间步骤的文件">使用<code>-save-temps</code>参数产生所有的中间步骤的文件</h3>
<p><code>-save-temps</code>可以做4,5,6步骤的工作。通过这个参数，所有中间阶段的文件都会存储在当前文件夹中，注意它也会产生可执行文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ gcc -save-temps main.c</div><div class="line"></div><div class="line">$ ls</div><div class="line">a.out  main.c  main.i  main.o  main.s</div></pre></td></tr></table></figure>

<p>从例子中我们可以看到各个中间文件以及可执行文件。</p>
<h3 id="使用-l参数链接共享库">使用<code>-l</code>参数链接共享库</h3>
<p><code>-l</code>可以用作链接共享库，例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc  -Wall main.c -o main <span class="operator">-l</span>CPPfile</div></pre></td></tr></table></figure>

<p>上面的代码会链接<code>libCPPfile.so</code>，产生可执行文件<code>main</code>。</p>
<h3 id="使用-fPIC产生位置无关的代码">使用<code>-fPIC</code>产生位置无关的代码</h3>
<p>当产生共享库的时候，应该创建位置无关的代码，这会让共享库使用任意的地址而不是固定的地址，要实现这个功能，需要使用<code>-fPIC</code>参数。</p>
<p>下面的例子产生<code>libCfile.so</code>动态库。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>gcc -c -<span class="constant">Wall</span> -<span class="constant">Werror</span> -fPIC <span class="constant">Cfile</span>.c</div><div class="line"><span class="variable">$ </span>gcc -shared -o libCfile.so <span class="constant">Cfile</span>.o</div></pre></td></tr></table></figure>

<p>产生共享库的时候使用了<code>-fPIC</code>参数。</p>
<p>注意<code>-shared</code>产生共享库。</p>
<h3 id="使用-V打印所有的执行命令">使用<code>-V</code>打印所有的执行命令</h3>
<p>参数<code>-V</code>提供详细的信息，打印出gcc编译一个文件的时候所有的步骤。</p>
<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ gcc -Wall -v main.c -o main</div><div class="line">Using built-in specs.</div><div class="line">COLLECT_GCC=gcc</div><div class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/i686-linux-gnu/<span class="number">4.6</span>/lto-wrapper</div><div class="line">Target: i686-linux-gnu</div><div class="line">Configured with: ../src/configure -v --with-pkgversion=<span class="string">'Ubuntu/Linaro 4.6.3-1ubuntu5'</span> --with-bugurl=file:///usr/share/doc/gcc-<span class="number">4.6</span>/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-<span class="number">4.6</span> --enable-shared --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/<span class="number">4.6</span> --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --enable-plugin --enable-objc-gc --enable-targets=all --disable-werror --with-arch-<span class="number">32</span>=i686 --with-tune=generic --enable-checking=release --build=i686-linux-gnu --host=i686-linux-gnu --target=i686-linux-gnu</div><div class="line">Thread model: posix</div><div class="line">gcc version <span class="number">4.6</span>.<span class="number">3</span> (Ubuntu/Linaro <span class="number">4.6</span>.<span class="number">3</span>-<span class="number">1</span>ubuntu5)</div><div class="line">...</div><div class="line">...</div><div class="line">...</div></pre></td></tr></table></figure>

<p>这样我们可以看到所有的细节。</p>
<h3 id="使用-ansi参数支持_ISO_C89程序">使用<code>-ansi</code>参数支持 ISO C89程序</h3>
<p>使用<code>-ansi</code>参数可以支持 ISO C89风格。</p>
<p>比如下面的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">  <span class="comment">// Print the string</span></div><div class="line">   <span class="built_in">printf</span>(<span class="string">"\n The Geek Stuff\n"</span>);</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用<code>-ansi</code>参数编译上面的代码会出错，因为ISO C89不支持C++风格的注释。</p>
<p>下面是输出结果:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">main.c</span>: <span class="string">In function ‘main’:</span></div><div class="line"><span class="attribute">main.c:5:3</span>: <span class="string">error: expected expression before ‘/’ token</span></div></pre></td></tr></table></figure>

<p>我们可以看待上面编译的时候抛出一个注释错误。</p>
<h3 id="使用-funsigned-char将char解释为符号的char">使用<code>-funsigned-char</code>将char解释为符号的char</h3>
<p>通过这个参数， char类型被看作为 unsigned char类型。</p>
<p>例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">  <span class="keyword">char</span> c = -<span class="number">10</span>;</div><div class="line">  <span class="comment">// Print the string</span></div><div class="line">   <span class="built_in">printf</span>(<span class="string">"\n The Geek Stuff [%d]\n"</span>, c);</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码通过这个参数编译后，输出结果为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ gcc -Wall -funsigned-char main.c -o main</div><div class="line">$ ./main</div><div class="line"></div><div class="line"> The Geek Stuff [<span class="number">246</span>]</div></pre></td></tr></table></figure>

<p>可以看到char是无符号的字节。</p>
<h3 id="使用-fsigned-char将char解释为有符号的char">使用<code>-fsigned-char</code>将char解释为有符号的char</h3>
<p>和上面的功能相反， 使用这个参数， char类型被看作是有符号的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>gcc -<span class="constant">Wall</span> -fsigned-char main.c -o main</div><div class="line"><span class="variable">$ </span>./main</div><div class="line"></div><div class="line"> <span class="constant">The</span> <span class="constant">Geek</span> <span class="constant">Stuff</span> [-<span class="number">10</span>]</div></pre></td></tr></table></figure>

<p>结果输出为负数。</p>
<h3 id="使用-D参数可以使用编译时的宏">使用<code>-D</code>参数可以使用编译时的宏</h3>
<p>参数<code>D</code>可以用作定义编译时的宏。</p>
<p>例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line"><span class="preprocessor">#ifdef MY_MACRO</span></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\n Macro defined \n"</span>);</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">  <span class="keyword">char</span> c = -<span class="number">10</span>;</div><div class="line">  <span class="comment">// Print the string</span></div><div class="line">   <span class="built_in">printf</span>(<span class="string">"\n The Geek Stuff [%d]\n"</span>, c);</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>-D</code>可以用作从命令行定义宏<code>MY_MACRO</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ gcc -Wall -DMY_MACRO main.c -o main</div><div class="line">$ ./main</div><div class="line"></div><div class="line"> Macro defined </div><div class="line"></div><div class="line"> The Geek Stuff [-<span class="number">10</span>]</div></pre></td></tr></table></figure>

<p>可以看到宏被定义了，并打印出了结果。<br>tput confirms that the macro was defined.</p>
<h3 id="使用-Werror将警告升级为错误">使用<code>-Werror</code>将警告升级为错误</h3>
<p>通过这个参数，gcc会将所有的警告转换成错误信息。<br>例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">  <span class="keyword">char</span> c;</div><div class="line">  <span class="comment">// Print the string</span></div><div class="line">   <span class="built_in">printf</span>(<span class="string">"\n The Geek Stuff [%d]\n"</span>, c);</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码编译的时候会有一个<code>undefined variable c</code>警告， <code>-Werror</code>会把这个警告升级成错误。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ gcc -Wall -Werror main.c -o main</div><div class="line">main.c: <span class="keyword">In</span> <span class="function"><span class="keyword">function</span> ‘<span class="title">main</span>’:</span></div><div class="line">main.c:<span class="number">7</span>:<span class="number">10</span>: error: ‘c’ <span class="keyword">is</span> used uninitialized <span class="keyword">in</span> this <span class="function"><span class="keyword">function</span> [-<span class="title">Werror</span>=<span class="title">uninitialized</span>]</span></div><div class="line"><span class="title">cc1</span>: all warnings being treated <span class="keyword">as</span> errors</div></pre></td></tr></table></figure>

<h3 id="使用@参数从文件中读取参数">使用<code>@</code>参数从文件中读取参数</h3>
<p>gcc参数可以从文件中读取，通过<code>@</code>后跟文件名的方式提供， 多个参数可以使用空格区隔。</p>
<p>例子:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cat opt_file </div><div class="line">-Wall -omain</div></pre></td></tr></table></figure>

<p><code>opt_file</code>包含编译参数。</p>
<p>使用<code>@</code>参数：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ gcc main.c @opt_file</div><div class="line">main.c: In function ‘main’:</div><div class="line">main.c:<span class="number">6</span>:<span class="number">11</span>: warning: ‘i’ is used uninitialized <span class="keyword">in</span> this function [-Wuninitialized]</div><div class="line"></div><div class="line">$ ls main</div><div class="line">main</div></pre></td></tr></table></figure>

<p>输出结果表明参数的确从文件中读取了，并且正确的应用到编译过程中。</p>
<blockquote>
<p>以下是附加的一些编译参数</p>
</blockquote>
<h3 id="使用参数-I指定头文件的文件夹">使用参数<code>-I</code>指定头文件的文件夹</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -I/home/codeman/include input-file.c</div></pre></td></tr></table></figure>

<p><code>-I-</code>取消前一个参数功能，一般用在<code>-Idir</code>之后。</p>
<h3 id="使用参数-std指定支持的c++/c的标准">使用参数<code>-std</code>指定支持的c++/c的标准</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -std=c++<span class="number">11</span> hello-world.cpp</div></pre></td></tr></table></figure>

<p>标准如 <code>c++11, c++14, c90, c89</code>等。</p>
<h3 id="使用-static生成静态链接的文件">使用<code>-static</code>生成静态链接的文件</h3>
<p>静态编译文件(把动态库的函数和其它依赖都编译进最终文件)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc main.c -static -o main -lpthread</div></pre></td></tr></table></figure>

<p>相反的使用<code>-shared</code>使用动态库链接。</p>
<h3 id="使用-static-libstdc++静态链接libstdc++">使用<code>-static-libstdc++</code>静态链接libstdc++</h3>
<p>如果没有使用<code>-static</code>,默认使用libstdc++共享库，而<code>-static-libstdc++</code>可以指定使用libstdc++静态库。</p>
<h3 id="使用-M生成文件关联的信息">使用<code>-M</code>生成文件关联的信息</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">gcc -M main.c</div><div class="line">main.o: main.c /usr/include/stdc-predef.h /usr/include/stdio.h \</div><div class="line"> /usr/include/features.h /usr/include/sys/cdefs.h \</div><div class="line"> /usr/include/bits/wordsize.h /usr/include/gnu/stubs.h \</div><div class="line"> /usr/include/gnu/stubs-<span class="number">64</span>.h \</div><div class="line"> /usr/lib/gcc/x86_64-redhat-linux/<span class="number">4.8</span>.<span class="number">5</span>/include/stddef.h \</div><div class="line"> /usr/include/bits/types.h /usr/include/bits/typesizes.h \</div><div class="line"> /usr/include/libio.h /usr/include/_G_config.h /usr/include/wchar.h \</div><div class="line"> /usr/lib/gcc/x86_64-redhat-linux/<span class="number">4.8</span>.<span class="number">5</span>/include/stdarg.h \</div><div class="line"> /usr/include/bits/stdio_lim.h /usr/include/bits/sys_errlist.h</div></pre></td></tr></table></figure>

<h3 id="全部参数介绍">全部参数介绍</h3>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html" target="_blank" rel="external">https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://www.thegeekstuff.com/2012/10/gcc-compiler-options/" target="_blank" rel="external">15 Most Frequently Used GCC Compiler Command Line Options</a> 以及评论中大家提供的一些参数。</p>
<p>GCC编译器是一个日常流行的 C 编译器， 很多Linux的发布版本中都带有这个编译器。这篇文章列举了一些最常用的编译参数。</p>
<p>本文中使用下面的C语言实现的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">   <span class="built_in">printf</span>(<span class="string">"\n The Geek Stuff\n"</span>);</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="C++" scheme="https://colobu.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[跳出Go module的泥潭]]></title>
    <link href="https://colobu.com/2018/08/27/learn-go-module/"/>
    <id>https://colobu.com/2018/08/27/learn-go-module/</id>
    <published>2018-08-27T11:11:34.000Z</published>
    <updated>2018-08-31T11:28:56.997Z</updated>
    <content type="html"><![CDATA[<p>Go 1.11 前天已经正式发布了，这个版本包含了两个最重要的feature就是 <code>module</code>和<code>web assembly</code>。虽然也有一些简单的教程介绍了<code>go module</code>的特性，但是基本上都是<code>hello world</code>的例子，在实践的过程中， 很多人都在“拼命的挣扎”，包括我自己， 从一些qq群、github的issue, twitter上都可以看到大家茫然或者抱怨的语句。</p>
<p>虽然有三个帮助文件<code>go help mod</code>、<code>go help modules</code>、<code>go help module-get</code>可以了解一些go module的用法，但是感觉Go开发组对<code>module</code>这一特性还是没有很好的做一个全面的介绍，很多情况还得靠大家看源代码或者去猜，比如module下载的文件夹、版本格式的完整声明，<code>module</code>的最佳实践等，并且当前Go 1.11的实现中还有一些bug,给大家在使用的过程中带来了很大的困难。</p>
<p>我也在摸索中前行， 记录了摸索过程中的一些总结，希望能给还在挣扎中的Gopher一些帮助。</p>
<p><a href="https://roberto.selbach.ca/intro-to-go-modules/" target="_blank" rel="external">Introduction to Go Modules</a> 是一篇很好的go module 入门介绍， 如果你仔细阅读了它，应该就不需要看本文了。</p>
<a id="more"></a>
<h3 id="GO111MODULE">GO111MODULE</h3>
<p>要使用<code>go module</code>,首先要设置<code>GO111MODULE=on</code>,这没什么可说的，如果没设置，执行命令的时候会有提示，这个大家应该都了解了。</p>
<h3 id="既有项目">既有项目</h3>
<p>假设你已经有了一个go 项目， 比如在<code>$GOPATH/github.com/smallnest/rpcx</code>下， 你可以使用<code>go mod init github.com/smallnest/rpcx</code>在这个文件夹下创建一个空的<code>go.mod</code> (只有第一行 <code>module github.com/smallnest/rpcx</code>)。</p>
<p>然后你可以通过 <code>go get ./...</code>让它查找依赖，并记录在<code>go.mod</code>文件中(你还可以指定 <code>-tags</code>,这样可以把tags的依赖都查找到)。</p>
<p>通过<code>go mod tidy</code>也可以用来为<code>go.mod</code>增加丢失的依赖，删除不需要的依赖，但是我不确定它怎么处理<code>tags</code>。</p>
<p>执行上面的命令会把<code>go.mod</code>的<code>latest</code>版本换成实际的最新的版本，并且会生成一个<code>go.sum</code>记录每个依赖库的版本和哈希值。</p>
<h3 id="新的项目">新的项目</h3>
<p>你可以在<code>GOPATH</code>之外创建新的项目。</p>
<p><code>go mod init packagename</code>可以创建一个空的<code>go.mod</code>,然后你可以在其中增加<code>require github.com/smallnest/rpcx latest</code>依赖，或者像上面一样让go自动发现和维护。</p>
<p><code>go mod download</code>可以下载所需要的依赖，但是依赖并不是下载到<code>$GOPATH</code>中，而是<code>$GOPATH/pkg/mod</code>中，多个项目可以共享缓存的module。</p>
<h3 id="go_mod命令">go mod命令</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">download    download modules to local cache (下载依赖的module到本地cache))</div><div class="line">edit        edit go.mod from tools or scripts (编辑go.mod文件)</div><div class="line">graph       print module requirement graph (打印模块依赖图))</div><div class="line">init        initialize new module <span class="keyword">in</span> current directory (再当前文件夹下初始化一个新的module, 创建go.mod文件))</div><div class="line">tidy        add missing and remove unused modules (增加丢失的module，去掉未用的module)</div><div class="line">vendor      make vendored copy of dependencies (将依赖复制到vendor下)</div><div class="line">verify      verify dependencies have expected content (校验依赖)</div><div class="line">why         explain why packages or modules are needed (解释为什么需要依赖)</div></pre></td></tr></table></figure>

<p>有些命令还有bug, 比如<code>go mod download -dir</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">go mod download -dir /tmp</div><div class="line">flag provided but not defined: -dir</div><div class="line">usage: go mod download [-dir] [-json] [modules]</div><div class="line">Run <span class="string">'go help mod download'</span> <span class="keyword">for</span> details.</div></pre></td></tr></table></figure>

<p>帮助里明明说可以设置<code>dir</code>,但是实际却不支持<code>dir</code>参数。</p>
<p>看这些命令的帮助已经比较容易了解命令的功能。</p>
<h3 id="翻墙">翻墙</h3>
<p>在国内访问<code>golang.org/x</code>的各个包都需要翻墙，你可以在<code>go.mod</code>中使用<code>replace</code>替换成github上对应的库。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">replace (</div><div class="line">	golang.org<span class="regexp">/x/</span>crypto v0.<span class="number">0.0</span>-<span class="number">20180820150726</span>-<span class="number">614</span>d502a4dac =&gt; github.com<span class="regexp">/golang/</span>crypto v0.<span class="number">0.0</span>-<span class="number">20180820150726</span>-<span class="number">614</span>d502a4dac</div><div class="line">	golang.org<span class="regexp">/x/</span>net v0.<span class="number">0.0</span>-<span class="number">20180821023952</span>-<span class="number">922</span>f4815f713 =&gt; github.com<span class="regexp">/golang/</span>net v0.<span class="number">0.0</span>-<span class="number">20180826012351</span>-<span class="number">8</span>a410e7b638d</div><div class="line">	golang.org<span class="regexp">/x/</span>text v0.<span class="number">3.0</span> =&gt; github.com<span class="regexp">/golang/</span>text v0.<span class="number">3.0</span></div><div class="line">)</div></pre></td></tr></table></figure>

<p>依赖库中的<code>replace</code>对你的主<code>go.mod</code>不起作用，比如<code>github.com/smallnest/rpcx</code>的<code>go.mod</code>已经增加了<code>replace</code>,但是你的<code>go.mod</code>虽然<code>require</code>了<code>rpcx</code>的库，但是没有设置<code>replace</code>的话， <code>go get</code>还是会访问<code>golang.org/x</code>。</p>
<p>所以如果想编译那个项目，就在哪个项目中增加<code>replace</code>。</p>
<h3 id="版本格式">版本格式</h3>
<p>下面的版本都是合法的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gopkg.<span class="keyword">in</span>/tomb.v1 v1<span class="number">.0</span><span class="number">.0</span>-<span class="number">20141024135613</span>-dd632973f1e7</div><div class="line">gopkg.<span class="keyword">in</span>/vmihailenco/msgpack.v2 v2<span class="number">.9</span><span class="number">.1</span></div><div class="line">gopkg.<span class="keyword">in</span>/yaml.v2 &lt;=v2<span class="number">.2</span><span class="number">.1</span></div><div class="line">github.com/tatsushid/go-fastping v0<span class="number">.0</span><span class="number">.0</span>-<span class="number">20160109021039</span>-d7bb493dee3e</div><div class="line">latest</div></pre></td></tr></table></figure>

<h3 id="go_get_升级">go get 升级</h3>
<ul>
<li>运行 <code>go get -u</code> 将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)</li>
<li>运行 <code>go get -u=patch</code> 将会升级到最新的修订版本</li>
<li>运行 <code>go get package@version</code> 将会升级到指定的版本号<code>version</code></li>
</ul>
<h3 id="go_mod_vendor">go mod vendor</h3>
<p><code>go mod vendor</code> 会复制modules下载到vendor中, 貌似只会下载你代码中引用的库，而不是go.mod中定义全部的module。</p>
<h3 id="go_module,_vendor_和_Travis_CI">go module, vendor 和 Travis CI</h3>
<p><a href="https://arslan.io/2018/08/26/using-go-modules-with-vendor-support-on-travis-ci/" target="_blank" rel="external">https://arslan.io/2018/08/26/using-go-modules-with-vendor-support-on-travis-ci/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go 1.11 前天已经正式发布了，这个版本包含了两个最重要的feature就是 <code>module</code>和<code>web assembly</code>。虽然也有一些简单的教程介绍了<code>go module</code>的特性，但是基本上都是<code>hello world</code>的例子，在实践的过程中， 很多人都在“拼命的挣扎”，包括我自己， 从一些qq群、github的issue, twitter上都可以看到大家茫然或者抱怨的语句。</p>
<p>虽然有三个帮助文件<code>go help mod</code>、<code>go help modules</code>、<code>go help module-get</code>可以了解一些go module的用法，但是感觉Go开发组对<code>module</code>这一特性还是没有很好的做一个全面的介绍，很多情况还得靠大家看源代码或者去猜，比如module下载的文件夹、版本格式的完整声明，<code>module</code>的最佳实践等，并且当前Go 1.11的实现中还有一些bug,给大家在使用的过程中带来了很大的困难。</p>
<p>我也在摸索中前行， 记录了摸索过程中的一些总结，希望能给还在挣扎中的Gopher一些帮助。</p>
<p><a href="https://roberto.selbach.ca/intro-to-go-modules/" target="_blank" rel="external">Introduction to Go Modules</a> 是一篇很好的go module 入门介绍， 如果你仔细阅读了它，应该就不需要看本文了。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[局部敏感哈希介绍]]></title>
    <link href="https://colobu.com/2018/08/16/locality-sensitive-hashing/"/>
    <id>https://colobu.com/2018/08/16/locality-sensitive-hashing/</id>
    <published>2018-08-16T09:19:25.000Z</published>
    <updated>2018-08-16T11:56:14.950Z</updated>
    <content type="html"><![CDATA[<p>传统的Hash当源数据有些许的变化的时候生成的哈希值差异也非常的大， 比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	s1 := []<span class="typename">byte</span>(<span class="string">"你好世界"</span>)</div><div class="line">	s2 := []<span class="typename">byte</span>(<span class="string">"你好,世界"</span>)</div><div class="line"></div><div class="line">	hash1 := md5.Sum(s1)</div><div class="line">	hash2 := md5.Sum(s2)</div><div class="line"></div><div class="line">	fmt.Println(hex.EncodeToString(hash1[:]))</div><div class="line">	fmt.Println(hex.EncodeToString(hash2[:]))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>s1的哈希值是<code>65396ee4aad0b4f17aacd1c6112ee364</code>、s2的哈希值是<code>27444ee2d245c3e8e11ed8b9b035c43b</code>,源数据仅仅是一个逗号的区别，但是哈希值完全不一样。这是我们使用Hash的常见的场景，输出的哈希值经常被称为消息摘要（message digest）或摘要（digest）。</p>
<p>局部敏感哈希(Locality-sensitive hashing， 简称LSH)则不同， LSH则希望相似的源数据计算出来的哈希值越相近越好。<br>LSH经常用在判重、文章摘要、聚类、相似搜索、近邻查找等场景， 用来减少高维度的数据的维度，相近的数据放在同一个桶中。 比如<a href="https://cloud.tencent.com/developer/article/1035600" target="_blank" rel="external">大规模异常滥用检测：基于局部敏感哈希算法——来自Uber Engineering的实践</a></p>
<a id="more"></a>
<p>学术定义<a href="https://en.wikipedia.org/wiki/Locality-sensitive_hashing" target="_blank" rel="external">Locality sensitive hashing</a>总是不那么容易让人理解，本文也不试图从学术的角度去介绍LSH, 而是介绍一个特定的LSH算法：simhash。</p>
<p>通用的LSH会基于某个点与点之间的某种<code>距离</code>判定相似性，相近的点距离接近，也就是说，我们可以通过计算距离来比较对象的相似性。距离之间的测量可以分为两大类：</p>
<ul>
<li>欧几里得距离(Euclidean): 基于空间中的点计算距离<ul>
<li>普通的欧几里得距离</li>
<li>曼哈顿距离(Manhattan distance)</li>
<li>闵可夫斯基距离(Minkowski Distance)</li>
</ul>
</li>
<li>非欧几里得距离: 不是根据空间中的位置，而是根据点的属性计算距离<ul>
<li>杰卡德距离(Jaccard distance): 1-杰卡德相似系数</li>
<li>余弦距离(Cosine distance)</li>
<li>编辑距离(Edit distance)</li>
<li>汉明距离(Hamming Distance)</li>
</ul>
</li>
</ul>
<p>当然还有一些距离的计算公式， 比如切比雪夫距离(Chebyshev Distance)、马氏距离(Mahalanobis distance)、Pearson距离等。<br>这些计算距离的方法会应用在不同的场景中，有时候也会使用不同的距离计算方法进行比较。</p>
<p>不同的LSH会使用不同距离计算方法：</p>
<ul>
<li><a href="http://www.cs.princeton.edu/courses/archive/spring04/cos598B/bib/CharikarEstim.pdf" target="_blank" rel="external">HyperplaneLSH</a> 使用余弦距离</li>
<li><a href="https://papers.nips.cc/paper/4847-super-bit-locality-sensitive-hashing.pdf" target="_blank" rel="external">Super-Bit Locality-Sensitive Hashing</a> 使用汉明距离</li>
<li><a href="https://en.wikipedia.org/wiki/MinHash" target="_blank" rel="external">Min Hash</a> 使用杰卡德相似系数</li>
<li><a href="http://www.cs.princeton.edu/courses/archive/spr04/cos598B/bib/BroderCFM-minwise.pdf" target="_blank" rel="external">Min-wise independent permutations</a></li>
<li><a href="https://pdfs.semanticscholar.org/7a5f/dc6e9250428a636be20643191eaf9faa1434.pdf" target="_blank" rel="external">Nilsimsa Hash</a></li>
<li><a href="http://www.ime.unicamp.br/~wanderson/Artigos/randon_projection_kdd.pdf" target="_blank" rel="external">Random projection</a></li>
</ul>
<p>simhash是Google的爬虫用来文档去重。 simhash最牛逼的一点就是将一个文档，最后转换成一个64位的字节，然后判断重复只需要判断他们的特征字的距离是不是小于n（根据经验这个n一般取值为3），就可以判断两个文档是否相似。这大大简化了文档相似性的比较。</p>
<p>Simhash由<a href="https://en.wikipedia.org/wiki/Moses_Charikar" target="_blank" rel="external">Moses Charikar</a>, google 2006年做了minhash和simhash的大规模数据的比较，2007年Google说使用simhash用作<a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/33026.pdf" target="_blank" rel="external">爬虫去重</a>，使用minhash做<a href="https://doi.org/10.1145/1242572.1242610" target="_blank" rel="external">新闻个性化</a>。</p>
<p><img src="simhash.jpg" alt=""></p>
<p>simhash的计算也很简单，</p>
<ol>
<li>首先抽取文档的关键字， 比如前10个关键字，以及它们的权重(feature, weight), 记录为[(feature1, weight1), (feature1,weight2), ..., (featuren,weightn)]</li>
<li>计算feature的hash值，记为[(hash(feature1), weight1), (hash(feature1),weight2), ..., (hash(featuren),weightn)], 如图，假设hash值的bit数为6位，图中第一个feature1的hash值为100110, 权重位weight1。</li>
<li>然后对这些值按位进行累加，如果这个位是1,则该位上加上他的权重weight,如果是0，则减去weight，最后生成一个6个数字，每个位上一个数字，例如上图中位[13, 108, -22, -5, -32, 55]</li>
<li>将数值转换成0,1即可 [13, 108, -22, -5, -32, 55] -&gt; 110001, 正值为1,负值为0即可</li>
</ol>
<p>这样，就可以将一个文档映射成一个数字了，上图中使用6bit,你可以选择合适的大小，比如64比特，可以转化成一个uint64整数。</p>
<p>下一步就是根据simhash值计算两个文档的相似度，使用汉明距离计算，可以方便的使用xor操作。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="literal">A</span> = <span class="number">100111</span><span class="comment">;</span></div><div class="line">B = <span class="number">101010</span><span class="comment">;</span></div><div class="line">hamming_distance(<span class="literal">A</span>, B) = count_1(<span class="literal">A</span> xor B) = count_1(<span class="number">001101</span>) = <span class="number">3</span><span class="comment">;</span></div></pre></td></tr></table></figure>

<p>这个例子中<code>A</code>和<code>B</code>的汉明距离为3。</p>
<p>go标准库中已经有快速计算一个整数的二进制形式中包含1个数的函数：<a href="https://golang.org/pkg/math/bits/#OnesCount64" target="_blank" rel="external">bits.OnesCount64</a>， 使用 &lt;&lt;Hacker&#39;s Delight&gt;&gt;中介绍的算法。</p>
<p>Go有几个simhash的实现， 比如<a href="https://github.com/mfonda/simhash" target="_blank" rel="external">mfonda/simhash</a>、<a href="https://github.com/AllenDang/simhash" target="_blank" rel="external">AllenDang/simhash</a>、<a href="https://github.com/fnargesian/simhash-lsh" target="_blank" rel="external">simhash-lsh</a>、<a href="https://github.com/safeie/simhash" target="_blank" rel="external">safeie/simhash</a>, 但是对于中文来说，还需要一个中文分词和抽取关键字的功能，这些库对中文不友好，中文文档的比较可以使用<a href="https://github.com/yanyiwu/gosimhash" target="_blank" rel="external">yanyiwu/gosimhash</a>以及修改版<a href="https://github.com/HaoyuHu/gosimhash" target="_blank" rel="external">HaoyuHu/gosimhash</a>。</p>
<p>不过我最后计算相似性使用的是<a href="https://github.com/rfguri/bowsi" target="_blank" rel="external">bowsim</a> + <a href="github.com/yanyiwu/gojieba">jieba</a>。</p>
<p>## </p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Locality-sensitive_hashing" target="_blank" rel="external">https://en.wikipedia.org/wiki/Locality-sensitive_hashing</a></li>
<li><a href="http://web.mit.edu/andoni/www/LSH/" target="_blank" rel="external">http://web.mit.edu/andoni/www/LSH/</a></li>
<li><a href="https://medium.com/engineering-brainly/locality-sensitive-hashing-explained-304eb39291e4" target="_blank" rel="external">https://medium.com/engineering-brainly/locality-sensitive-hashing-explained-304eb39291e4</a></li>
<li><a href="https://towardsdatascience.com/understanding-locality-sensitive-hashing-49f6d1f6134" target="_blank" rel="external">https://towardsdatascience.com/understanding-locality-sensitive-hashing-49f6d1f6134</a></li>
<li><a href="http://jacoxu.com/locality-sensitive-hashing归总/" target="_blank" rel="external">http://jacoxu.com/locality-sensitive-hashing归总/</a></li>
<li><a href="http://infolab.stanford.edu/~ullman/mining/2009/similarity3.pdf" target="_blank" rel="external">http://infolab.stanford.edu/~ullman/mining/2009/similarity3.pdf</a></li>
<li><a href="https://janzhou.org/lsh/" target="_blank" rel="external">https://janzhou.org/lsh/</a></li>
<li><a href="http://www.cs.princeton.edu/courses/archive/spring04/cos598B/bib/CharikarEstim.pdf" target="_blank" rel="external">http://www.cs.princeton.edu/courses/archive/spring04/cos598B/bib/CharikarEstim.pdf</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1082465" target="_blank" rel="external">https://cloud.tencent.com/developer/article/1082465</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>传统的Hash当源数据有些许的变化的时候生成的哈希值差异也非常的大， 比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	s1 := []<span class="typename">byte</span>(<span class="string">"你好世界"</span>)</div><div class="line">	s2 := []<span class="typename">byte</span>(<span class="string">"你好,世界"</span>)</div><div class="line"></div><div class="line">	hash1 := md5.Sum(s1)</div><div class="line">	hash2 := md5.Sum(s2)</div><div class="line"></div><div class="line">	fmt.Println(hex.EncodeToString(hash1[:]))</div><div class="line">	fmt.Println(hex.EncodeToString(hash2[:]))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>s1的哈希值是<code>65396ee4aad0b4f17aacd1c6112ee364</code>、s2的哈希值是<code>27444ee2d245c3e8e11ed8b9b035c43b</code>,源数据仅仅是一个逗号的区别，但是哈希值完全不一样。这是我们使用Hash的常见的场景，输出的哈希值经常被称为消息摘要（message digest）或摘要（digest）。</p>
<p>局部敏感哈希(Locality-sensitive hashing， 简称LSH)则不同， LSH则希望相似的源数据计算出来的哈希值越相近越好。<br>LSH经常用在判重、文章摘要、聚类、相似搜索、近邻查找等场景， 用来减少高维度的数据的维度，相近的数据放在同一个桶中。 比如<a href="https://cloud.tencent.com/developer/article/1035600" target="_blank" rel="external">大规模异常滥用检测：基于局部敏感哈希算法——来自Uber Engineering的实践</a></p>
]]>
    
    </summary>
    
      <category term="算法" scheme="https://colobu.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创建最小的Go docker 镜像]]></title>
    <link href="https://colobu.com/2018/08/13/create-minimal-docker-image-for-go-applications/"/>
    <id>https://colobu.com/2018/08/13/create-minimal-docker-image-for-go-applications/</id>
    <published>2018-08-13T10:30:10.000Z</published>
    <updated>2018-08-14T02:57:56.051Z</updated>
    <content type="html"><![CDATA[<p>虽然曾有一些文章介绍了如何创建一个最小的Go Docker镜像，我也曾写过一篇<a href="http://colobu.com/2015/10/12/create-minimal-golang-docker-images/" target="_blank" rel="external">文章</a>，但是随着Go的新的版本的发布， 以及docker本身的进化，有些技巧已经发生了变化， 本文介绍了最新的创建超小的Go镜像的方法。</p>
<a id="more"></a>
<h2 id="一个简单Go程序的镜像">一个简单Go程序的镜像</h2>
<p>首先让我们创建一个很简单的Go程序:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	fmt.Println(<span class="string">"hello world"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行下面的命令会创建一个超小的镜像, 这是我们的<strong>第一种</strong>方式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GOOS=linux CGO_ENABLED<span class="number">=0</span> <span class="keyword">go</span> build -ldflags=<span class="string">"-s -w"</span> -o app app.<span class="keyword">go</span> && tar c app | docker <span class="keyword">import</span> - app:latest</div></pre></td></tr></table></figure>

<blockquote>
<p>下一节介绍其中的编译参数</p>
</blockquote>
<p>查看镜像, 生成的镜像只有 <code>1.21MB</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># docker images app</span></div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">app                 latest              b716e13758<span class="built_in">cd</span>        <span class="number">11</span> seconds ago      <span class="number">1.21</span>MB</div></pre></td></tr></table></figure>

<p>这命令将编译、打包、输入镜像集成到一条命令了。</p>
<p><strong>第二种</strong>方式是使用一个Dockerfile文件:</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> scratch</div><div class="line">ADD app /</div><div class="line">CMD [<span class="string">"/app"</span>]</div></pre></td></tr></table></figure>

<p>运行下面的命令创建一个镜像：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t app2 .</div></pre></td></tr></table></figure>

<p>查看生成的镜像， 也是 <code>1.21MB</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># docker images app2</span></div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">app2                latest              <span class="number">4</span>e2af2ffb695        <span class="number">4</span> seconds ago       <span class="number">1.21</span>MB</div></pre></td></tr></table></figure>

<p><strong>第三种</strong>方式是利用Docker的 multistage 功能，在镜像中编译，Dockerfile文件：</p>
<figure class="highlight docker"><figcaption><span>Dockerfile.multistage</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t app3 <span class="operator">-f</span> Dockerfile.multistage .</div></pre></td></tr></table></figure>

<p>查看生成的镜像， 也是``:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># docker images app3</span></div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">app3                latest              <span class="number">9177859</span>dad64        <span class="number">16</span> seconds ago      <span class="number">1.21</span>MB</div></pre></td></tr></table></figure>

<p>你可以结合你的情况选择一种生成镜像的方式。</p>
<h2 id="编译Go程序">编译Go程序</h2>
<p>上面的例子中我们使用下面的命令编译Go程序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GOOS=linux CGO_ENABLED=<span class="number">0</span> go build -ldflags=<span class="string">"-s -w"</span> -o app app.go</div></pre></td></tr></table></figure>

<p>你可能在其它一些文章中还看到<code>installsuffix</code>参数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">GOOS=</span>linux <span class="variable">CGO_ENABLED=</span><span class="number">0</span> go build <span class="variable">-ldflags=</span><span class="string">"-s -w"</span>  -installsuffix cgo -o app app.go</div></pre></td></tr></table></figure>

<p>自Go 1.10以后，你不必再使用<code>installsuffix</code>参数(或许更早的版本)，Go的核心开发人员Ian Lance Taylor已经<a href="https://plus.google.com/117192131596509381660/posts/eNnNePihYnK" target="_blank" rel="external">确认</a>了这一点。</p>
<p>你可能有人还使用<code>-a</code>参数，它强制重新编译相关的包,一般你不会使用它。</p>
<p><code>-s</code> 忽略符号表和调试信息，<code>-w</code>忽略DWARF符号表，通过这两个参数，可以进一步减少编译的程序的尺寸，更多的参数可以参考<a href="https://golang.org/cmd/link/" target="_blank" rel="external">go link</a>, 或者 <code>go tool link -help</code>(另一个有用的命令是<code>go tool compile -help</code>)。</p>
<p>你也可以使用<code>strip</code>工具对编译的Go程序进行裁剪。</p>
<p>本身Go是静态编译的， 对于CGO, 如果设置<code>CGO_ENABLED=0</code>,则完全静态编译，不会再依赖动态库。</p>
<p>如果设置<code>CGO_ENABLED=0</code>,并且你的代码中使用了标准库的<code>net</code>包的话，有可能编译好的镜像无法运行，报<code>sh: /app: not found</code>的错误，尽管<code>/app</code>这个文件实际存在，并且如果讲基础镜像换为<code>centos</code>或者<code>ubuntu</code>的话就能执行。这是一个奇怪的错误，原因在于：</p>
<p><strong> 默认情况下<code>net</code>包会使用静态链接库， 比如libc</strong></p>
<p>知道了原因，解决办法也很简单，就是完全静态链接或者在基础镜像中加入libc库。</p>
<p>下面是几种解决办法：</p>
<ul>
<li>设置 <code>CGO_ENABLED=0</code></li>
<li>编译是使用纯go的net: <code>go build -tags netgo -a -v</code></li>
<li>使用基础镜像加glibc(或等价库musl、uclibc)， 比如 <a href="https://hub.docker.com/_/busybox/" target="_blank" rel="external">busybox:glibc</a>、alpine + <code>RUN apk add --no-cache libc6-compat</code>、<a href="https://hub.docker.com/r/frolvlad/alpine-glibc/" target="_blank" rel="external">frolvlad/alpine-glibc</a></li>
</ul>
<p>有的同学说了，我代码中确实必须使用CGO,因为需要依赖一些C/C++的库。目前没有对应的Go库可替代， 那么可以使用<code>-extldflags &quot;-static&quot;</code>,<code>go tool link help</code>介绍了<code>extldflags</code>的功能：</p>
<blockquote>
<p>-extldflags flags<br>   Set space-separated flags to pass to the external linker.</p>
<p>   -static means do not link against shared libraries</p>
</blockquote>
<h2 id="基础镜像">基础镜像</h2>
<p>其实前面已经列出了一些常用的基础镜像：</p>
<ul>
<li>scratch: 空的基础镜像，最小的基础镜像</li>
<li>busybox: 带一些常用的工具，方便调试， 以及它的一些扩展busybox:glibc</li>
<li>alpine: 另一个常用的基础镜像，带包管理功能，方便下载其它依赖的包</li>
</ul>
<p>显然。 你应该只在编译阶段使用<a href="https://hub.docker.com/_/golang/" target="_blank" rel="external">Go的镜像</a>，这样才能将你的镜像减小到最小。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然曾有一些文章介绍了如何创建一个最小的Go Docker镜像，我也曾写过一篇<a href="http://colobu.com/2015/10/12/create-minimal-golang-docker-images/" target="_blank" rel="external">文章</a>，但是随着Go的新的版本的发布， 以及docker本身的进化，有些技巧已经发生了变化， 本文介绍了最新的创建超小的Go镜像的方法。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Go HttpServer 最佳实践]]></title>
    <link href="https://colobu.com/2018/07/25/exposing-go-on-the-internet/"/>
    <id>https://colobu.com/2018/07/25/exposing-go-on-the-internet/</id>
    <published>2018-07-25T11:09:15.000Z</published>
    <updated>2018-07-31T08:27:34.556Z</updated>
    <content type="html"><![CDATA[<p>这是 Cloudflare 的 Filippo Valsorda 2016年发表在Gopher Academy的一篇<a href="https://blog.gopheracademy.com/advent-2016/exposing-go-on-the-internet/" target="_blank" rel="external">文章</a>， 虽然过去两年了，但是依然很有意义。</p>
<p>先前 <code>crypto/tls</code> 太慢而<code>net/http</code>也很年轻， 所以对于Go web server来说， 通常我们明智的做法把它放在反向代理的后面， 如nginx等，现在不需要了。</p>
<p>在Cloudflare我们最近试验了直接暴漏纯Go的服务作为主机。 Go 1.8的<code>net/http</code> 和 <code>crypto/tls</code> 提供了稳定的、高性能并且灵活的功能。</p>
<p>然后，需要做一些调优的工作，本文我们将展示怎么去调优和使web服务器更稳定。</p>
<a id="more"></a>
<p><img src="banner.jpg" alt=""></p>
<h2 id="crypto/tls">crypto/tls</h2>
<p>2016年了，你不会再运行一个不加密的HTTP Server，所以你需要<code>crypto/tls</code>。好消息使这个库已经非常<a href="https://blog.cloudflare.com/go-crypto-bridging-the-performance-gap/" target="_blank" rel="external">快</a>了(我们的<a href="https://blog.gopheracademy.com/advent-2016/tls-termination-bench/" target="_blank" rel="external">测试</a>)，目前他的安全攻击追踪也很优秀。</p>
<p>缺省配置是使用Mozilla<a href="https://wiki.mozilla.org/Security/Server_Side_TLS" target="_blank" rel="external">参考</a>中的中级推荐配置,但是　你仍然应该设置<code>PreferServerCipherSuites</code>以确保采用更快更安全的密码库, <code>CurvePreferences</code>避免未优化的曲线。 客户端如果使用<code>CurveP384</code>算法回导致我们的机器多达1秒的cpu消耗。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&tls.Config{</div><div class="line">	<span class="comment">// Causes servers to use Go's default ciphersuite preferences,</span></div><div class="line">	<span class="comment">// which are tuned to avoid attacks. Does nothing on clients.</span></div><div class="line">	PreferServerCipherSuites: <span class="constant">true</span>,</div><div class="line">	<span class="comment">// Only use curves which have assembly implementations</span></div><div class="line">	CurvePreferences: []tls.CurveID{</div><div class="line">		tls.CurveP256,</div><div class="line">		tls.X25519, <span class="comment">// Go 1.8 only</span></div><div class="line">	},</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你想配置兼容性， 你可以设置<code>MinVersion</code>和<code>CipherSuites</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">MinVersion: tls.VersionTLS12,</div><div class="line">CipherSuites: []<span class="typename">uint16</span>{</div><div class="line">	tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,</div><div class="line">	tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,</div><div class="line">	tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305, <span class="comment">// Go 1.8 only</span></div><div class="line">	tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,   <span class="comment">// Go 1.8 only</span></div><div class="line">	tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,</div><div class="line">	tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,</div><div class="line"></div><div class="line">	<span class="comment">// Best disabled, as they don't provide Forward Secrecy,</span></div><div class="line">	<span class="comment">// but might be necessary for some clients</span></div><div class="line">	<span class="comment">// tls.TLS_RSA_WITH_AES_256_GCM_SHA384,</span></div><div class="line">	<span class="comment">// tls.TLS_RSA_WITH_AES_128_GCM_SHA256,</span></div><div class="line">   },</div></pre></td></tr></table></figure>

<p>注意Go的CBC加密套件的实现（上面我们禁用了）很容易收到 <a href="https://www.imperialviolet.org/2013/02/04/luckythirteen.html" target="_blank" rel="external">Lucky13攻击</a>， 即使Go 1.8实现了部分的<a href="https://github.com/golang/go/commit/f28cf8346c4ce7cb74bf97c7c69da21c43a78034" target="_blank" rel="external">处理</a>。</p>
<p>最后需要注意的是， 所有这些建议仅适用 amd64架构因为它可以实现快速的常数级的<a href="https://blog.cloudflare.com/go-crypto-bridging-the-performance-gap/" target="_blank" rel="external">加密原语</a>(AES-GCM, ChaCha20-Poly1305, P256), 其它架构可能不适合产品级应用。</p>
<p>既然是服务要暴漏带互联网上， 它需要一个公开的可信的证书。通过<code>Let’s Encrypt</code>很容易申请， 可以使用<code>golang.org/x/crypto/acme/autocert</code>的<code>GetCertificate</code>函数。</p>
<p>不要忘了将HTTP重定向到HTTPS, 如果你的客户端是浏览器的话，可以考虑 <a href="https://www.owasp.org/index.php/HTTP_Strict_Transport_Security_Cheat_Sheet" target="_blank" rel="external">HSTS</a>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">srv := &http.Server{</div><div class="line">	ReadTimeout: <span class="number"> 5</span> * time.Second,</div><div class="line">	WriteTimeout:<span class="number"> 5</span> * time.Second,</div><div class="line">	Handler: http.HandlerFunc(<span class="keyword">func</span>(w http.ResponseWriter, req *http.Request) {</div><div class="line">		w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</div><div class="line">		url := <span class="string">"https://"</span> + req.Host + req.URL.String()</div><div class="line">		http.Redirect(w, req, url, http.StatusMovedPermanently)</div><div class="line">	}),</div><div class="line">}</div><div class="line"><span class="keyword">go</span> <span class="keyword">func</span>() { log.Fatal(srv.ListenAndServe()) }()</div></pre></td></tr></table></figure>

<p>你可以使用<a href="https://www.ssllabs.com/ssltest/" target="_blank" rel="external">SSL Labs test</a>检查配置是否正确。</p>
<h2 id="net/http">net/http</h2>
<p><code>net/http</code> 包含 <code>HTTP/1.1</code> 和 <code>HTTP/2</code>。你一定已经熟悉了Handler的开发，所以本文不讨论它。我们讨论服务器端背后的一些场景。</p>
<h3 id="Timeout">Timeout</h3>
<p>超时可能是最容易忽略的危险的场景。你的服务可能在受控网络中幸免于难，但是在互联网上就不会那么幸运了， 特别是(不仅仅)受到恶意攻击。</p>
<p>有一系列的资源需要超时控制。尽管goroutine消耗很少，但文件描述符总是有限的。卡住的连接、不工作的连接甚至恶意断掉的连接不应该消耗它们。</p>
<p>一个超过最大文件符的服务器总是不能接受新的连接， 会报下面的失败:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">http</span>: Accept error: accept tcp [::]:<span class="number">80</span>: accept: too many <span class="built_in">open</span> <span class="built_in">files</span>; retrying <span class="operator">in</span> <span class="number">1</span>s</div></pre></td></tr></table></figure>

<p>一个缺省的 <code>http.Server</code>, 、就像包文档中的例子<code>http.ListenAndServe</code> 和 <code>http.ListenAndServeTLS</code>， 没有设置任何超时控制, 你肯定不是你想要的。</p>
<p><img src="timeouts.png" alt=""></p>
<p>在<code>http.Server</code>有三个参数控制timeout: <code>ReadTimeout</code>, <code>WriteTimeout</code> 和 <code>IdleTimeout</code>,你可以显示地设置它们:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">srv := &http.Server{</div><div class="line">    ReadTimeout: <span class="number"> 5</span> * time.Second,</div><div class="line">    WriteTimeout:<span class="number"> 10</span> * time.Second,</div><div class="line">    IdleTimeout: <span class="number"> 120</span> * time.Second,</div><div class="line">    TLSConfig:    tlsConfig,</div><div class="line">    Handler:      serveMux,</div><div class="line">}</div><div class="line">log.Println(srv.ListenAndServeTLS(<span class="string">""</span>, <span class="string">""</span>))</div></pre></td></tr></table></figure>

<p><code>ReadTimeout</code>的时间范围起自连接备接受，止于请求的body完全读出。在<code>net/http</code>的实现中它在连接<code>Accept</code>后通过<code>SetReadDeadline</code><a href="https://github.com/golang/go/blob/3ba31558d1bca8ae6d2f03209b4cae55381175b3/src/net/http/server.go#L750" target="_blank" rel="external">设置</a>。</p>
<p><code>ReadTimeout</code>最大的问题它不允许服务器给客户端更多的时间去请求的body stream。 go 1.8新引入了一个参数<code>ReadHeaderTimeout</code>，它止于读完请求头。然后一直有一些不清楚的方式去设置读超时，相关的设计讨论可以参考<a href="https://golang.org/issue/16100" target="_blank" rel="external">#16100</a>。</p>
<p><code>WriteTimeout</code>超时正常起自读完请求头， 止于response写完(也就是<code>ServeHTTP</code>的生命周期)， 通过<code>readRequest</code>的<a href="https://github.com/golang/go/blob/3ba31558d1bca8ae6d2f03209b4cae55381175b3/src/net/http/server.go#L753-L755" target="_blank" rel="external">结尾</a>处的<code>SetWriteDeadline</code>设置。</p>
<p>然后，当通过HTTPS连接时，<code>SetWriteDeadline</code>在<code>Accept</code>后立即设置， 所以它也包含TLS握手的packet的写。讨厌的是，这意味着<code>WriteTimeout</code>包含http头的读以及第一个字节的等待。</p>
<p><code>ReadTimeout</code>和<code>WriteTimeout</code>是绝对值，无法在Handler中更改它(<a href="https://golang.org/issue/16100" target="_blank" rel="external">#16100</a>)。</p>
<p>Go 1.8还新引入了<code>IdleTimeout</code>参数， 用来限制服务端<code>Keep-Alive</code>连接在重用前idle的数量。</p>
<p>Go 1.8之前的版本， <code>ReadTimeout</code>在请求完成后又立即开始滴答(tick)，这对<code>Keep-Alive</code>连接是不合适的: idle time会消耗客户端允许发送请求的时间，导致一些快的客户端会有不期望的超时。</p>
<p>对于不可信的客户端和网络，你应该设置<code>Read</code>, <code>Write</code> 和 <code>Idle</code>超时， 这样一个读或者写很慢的客户端不会长时间占用一个连接。</p>
<p>对于go 1.8之前的 HTTP/1.1超时的背景知识， 你可以参考Cloudflare的<a href="https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/" target="_blank" rel="external">博客</a>。</p>
<h3 id="HTTP/2">HTTP/2</h3>
<p>HTTP/2在 Go 1.6+中回自动启用， 只要它满足下面的条件：</p>
<ul>
<li>请求通过<code>TLS/HTTPS</code></li>
<li><code>Server.TLSNextProto</code>为nil (如果设置一个空的map，则禁止HTTP/2)</li>
<li><code>Server.TLSConfig</code>已被设置，<code>ListenAndServeTLS</code>被调用或者下一条</li>
<li><code>Serve</code>被调用，并且<code>tls.Config.NextProtos</code>包含<code>h2</code> (比如[]string{&quot;h2&quot;, &quot;http/1.1&quot;)</li>
</ul>
<p>HTTP/2 和 HTTP/1.1有些不同，因为同一个连接同时会服务多个请求，但是Go抽象了统一的超时控制接口。</p>
<p>遗憾的是, Go 1.7中的<code>ReadTimeout</code>会打断 HTTP/2 连接，它不会为每一个连接重置，而是在连接初次建立时就设置而不会重置，当超时后就会断掉 HTTP/2连接。 Go 1.8 修复了这个<a href="https://github.com/golang/go/issues/16450" target="_blank" rel="external">问题</a>。</p>
<p>基于此和<code>ReadTimeout</code>的idle time问题，我强烈建议你尽快升级到1.8。</p>
<h3 id="TCP_Keep-Alives">TCP Keep-Alives</h3>
<p>如果你使用<code>ListenAndServe</code>(与传入<code>net.Listener</code>给<code>Serve</code>不同，这个方法使用缺省值提供了零保护措施)， 3分钟的TCP Keep-Alive会<a href="https://github.com/golang/go/blob/61db2e4efa2a8f558fd3557958d1c86dbbe7d3cc/src/net/http/server.go#L3023-L3039" target="_blank" rel="external">自动设置</a>,它会让彻底消失的client有机会放弃连接， 我的经验是不要完全相信它， 无论如何也要设置超时。</p>
<p>首先， 3分钟太长了，你可以使用你自己的<code>tcpKeepAliveListener</code>调整它。、</p>
<p>更重要的是，<code>Keep-Alive</code>只是保证client还活着，但不会设置连接存活的上限。恶意攻击的客户端会打开非常多的连接，导致你的服务器打开很多文件描述符， 通过未完成的请求， 会导致你的服务拒绝服务。</p>
<p>最后，我的经验是连接往往会导致泄漏，知道<a href="https://github.com/FiloSottile/Heartbleed/commit/4a3332ca1dc07aedf24b8540857792f72624cdf7" target="_blank" rel="external">超时起作用</a>。</p>
<h3 id="ServeMux">ServeMux</h3>
<p>包级别的<code>http.Handle[Func]</code> (和你的web框架)注册handler到全局的<code>http.DefaultServeMux</code>， 如果<code>Server.Handler</code>是nil的话， 你应该避免这样做。</p>
<p>任何你输入的包，不管是直接的还是间接的，都可以访问<code>http.DefaultServeMux</code>，可能会注册你不期望的route。</p>
<p>例如，包依赖中有任何一个库导入了<code>net/http/pprof</code>,客户端都能得到你的应用的CPU的profile。 你可以使用<code>net/http/pprof</code>手工注册。</p>
<p>正确的是， 初始化你自己的<code>http.ServeMux</code>,把handler注册到它的上面， 设置它为<code>Server.Handler</code>, 或者设置你自己的web框架为<code>Server.Handler</code>。</p>
<h3 id="Logging">Logging</h3>
<p>net/http在调用你的handler之前做了大量的工作， 比如<a href="">接受连接</a><a href="https://github.com/golang/go/blob/1106512db54fc2736c7a9a67dd553fc9e1fca742/src/net/http/server.go#L2631-L2653，" target="_blank" rel="external">https://github.com/golang/go/blob/1106512db54fc2736c7a9a67dd553fc9e1fca742/src/net/http/server.go#L2631-L2653，</a> <a href="https://github.com/golang/go/blob/1106512db54fc2736c7a9a67dd553fc9e1fca742/src/net/http/server.go#L1718-L1728" target="_blank" rel="external">TLS握手</a>等等……</p>
<p>当任何一个步骤出错，它会写一行日志到<code>Server.ErrorLog</code>。其中一些错误， 比如超时和连接重置， 在互联网上是正常的。你可以连接大部分错误并把它们加入到metric中，这要归功于这个保证：</p>
<blockquote>
<p>Each logging operation makes a single call to the Writer’s Write method.</p>
</blockquote>
<p>如果在handler中你不想输出堆栈log, 你可以使用<code>panic(nil)</code>或者使用Go 1.8的<code>panic(http.ErrAbortHandler)</code>。</p>
<h3 id="Metrics">Metrics</h3>
<p>metric可以帮助你监控打开的文件描述符。<a href="https://github.com/prometheus/client_golang/blob/575f371f7862609249a1be4c9145f429fe065e32/prometheus/process_collector.go" target="_blank" rel="external">Prometheus使用<code>proc</code>文件系统来帮助你完成这些</a>。</p>
<p>如果你需要调研泄漏问题， 你可以使用<code>Server.ConnState</code>钩子来得到更多的连接的细节metric。注意，不保持state就没有方式能保持一个正确的<code>StateActive</code>数量，所以你需要维护一个<code>map[net.Conn]ConnState</code>。</p>
<h3 id="结论">结论</h3>
<p>使用Nginx做Go服务前端的日志一去不复返了， 但是面对互联网你仍然需要做一些额外的防护措施， 可能需要升级到新的Go 1.8版本。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是 Cloudflare 的 Filippo Valsorda 2016年发表在Gopher Academy的一篇<a href="https://blog.gopheracademy.com/advent-2016/exposing-go-on-the-internet/" target="_blank" rel="external">文章</a>， 虽然过去两年了，但是依然很有意义。</p>
<p>先前 <code>crypto/tls</code> 太慢而<code>net/http</code>也很年轻， 所以对于Go web server来说， 通常我们明智的做法把它放在反向代理的后面， 如nginx等，现在不需要了。</p>
<p>在Cloudflare我们最近试验了直接暴漏纯Go的服务作为主机。 Go 1.8的<code>net/http</code> 和 <code>crypto/tls</code> 提供了稳定的、高性能并且灵活的功能。</p>
<p>然后，需要做一些调优的工作，本文我们将展示怎么去调优和使web服务器更稳定。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[完全静态编译一个Go程序]]></title>
    <link href="https://colobu.com/2018/07/20/totally-static-Go-builds/"/>
    <id>https://colobu.com/2018/07/20/totally-static-Go-builds/</id>
    <published>2018-07-20T00:36:18.000Z</published>
    <updated>2018-07-25T03:37:37.736Z</updated>
    <content type="html"><![CDATA[<p>在Docker化的今天， 我们经常需要静态编译一个Go程序，以便方便放在Docker容器中。 即使你没有引用其它的第三方包，只是在程序中使用了标准库<code>net</code>,你也会发现你编译后的程序依赖glic,这时候你需要glibc-static库，并且静态连接。</p>
<p>不同的Go版本下静态编译方式还有点不同，在go 1.10下， 下面的方式会尽可能做到静态编译：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGO_ENABLED=<span class="number">0</span> go build <span class="operator">-a</span> -ldflags <span class="string">'-extldflags "-static"'</span> .</div></pre></td></tr></table></figure>

<p>有一个<a href="https://github.com/golang/go/issues/26492" target="_blank" rel="external">提案</a>请求给编译加一个<code>static</code>,如果接收了的话也许在将来的go中直接使用<code>static</code>。</p>
<h2 id="参考文档">参考文档</h2>
<ol>
<li><a href="http://blog.wrouesnel.com/articles/Totally%20static%20Go%20builds/" target="_blank" rel="external">http://blog.wrouesnel.com/articles/Totally%20static%20Go%20builds/</a></li>
<li><a href="https://github.com/golang/go/issues/9344" target="_blank" rel="external">https://github.com/golang/go/issues/9344</a></li>
<li><a href="https://github.com/golang/go/issues/26492" target="_blank" rel="external">https://github.com/golang/go/issues/26492</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Docker化的今天， 我们经常需要静态编译一个Go程序，以便方便放在Docker容器中。 即使你没有引用其它的第三方包，只是在程序中使用了标准库<code>net</code>,你也会发现你编译后的程序依赖glic,这时候你需要glibc-static库，并且静态连接。]]>
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ldd、objdump、nm、strings、strip等工具]]></title>
    <link href="https://colobu.com/2018/07/12/some-tools-in-GNU-Binutils/"/>
    <id>https://colobu.com/2018/07/12/some-tools-in-GNU-Binutils/</id>
    <published>2018-07-12T08:11:29.000Z</published>
    <updated>2018-07-12T08:49:03.594Z</updated>
    <content type="html"><![CDATA[<p>最近在做Docker镜像的时候发现镜像文件非常大，需要找出程序的依赖库，减少程序的大小，所以整理了一下相关的工具。基本上这些工具都在<a href="https://www.gnu.org/software/binutils/" target="_blank" rel="external">GNU Binutils</a>中。</p>
<p>GNU Binary Utilities或binutils是一整套的编程语言工具程序，用来处理许多格式的目标文件。当前的版本原本由在Cygnus Solutions的程序员以Binary File Descriptor library（libbfd）所撰写。这个工具程序通常搭配GCC、make、和GDB这些程序来使用。</p>
<p>它包含20个左右的工具，本文介绍了我在创建Docker镜像的时候的使用的几种工具。</p>
<h3 id="ldd">ldd</h3>
<p>ldd不是GNU Binutils工具集中的一个工具，但是却是一个非常有用的工具， 它可以显示程序或者共享库所需的共享库。</p>
<p>例如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   <span class="comment"># ldd main</span></div><div class="line">linux-vdso.so.<span class="number">1</span> =&gt;  (<span class="number">0</span>x00007ffc88fd4000)</div><div class="line">libpthread.so.<span class="number">0</span> =&gt; /lib64/libpthread.so.<span class="number">0</span> (<span class="number">0</span>x00007faee13b8000)</div><div class="line">libc.so.<span class="number">6</span> =&gt; /lib64/libc.so.<span class="number">6</span> (<span class="number">0</span>x00007faee0feb000)</div><div class="line">/lib64/ld-linux-x86-<span class="number">64</span>.so.<span class="number">2</span> (<span class="number">0</span>x00007faee15d4000)</div></pre></td></tr></table></figure>

<p>依照ldd得手册， 有时候ldd会通过执行程序来获取依赖信息，对于来源不明的程序，执行这些程序可能会带来风险，所以对于来源不明的程序，可以使用<code>objdump</code>来分析。</p>
<h3 id="objdump">objdump</h3>
<p>onjdump可以显示目标文件的信息,可以通过参数控制要显示的内容。</p>
<p>比如<code>-p</code>可以显示文件头内容， 通过<code>grep</code>可以查看依赖的库。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># objdump -p  main|grep GLIBC</span></div><div class="line"><span class="number">0</span>x09691a75 <span class="number">0</span>x00 <span class="number">02</span> GLIBC_2.<span class="number">2.5</span></div><div class="line"><span class="number">0</span>x09691972 <span class="number">0</span>x00 <span class="number">03</span> GLIBC_2.<span class="number">3.2</span></div><div class="line"><span class="number">0</span>x09691a75 <span class="number">0</span>x00 <span class="number">04</span> GLIBC_2.<span class="number">2.5</span></div></pre></td></tr></table></figure>

<p>甚至可以查看<code>-T</code>可以查看动态符号表的内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># objdump -T  main|grep GLIBC</span></div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> stderr</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> fwrite</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> vfprintf</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> fputc</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> abort</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> pthread_mutex_lock</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">3.2</span> pthread_cond_wait</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> pthread_mutex_unlock</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">3.2</span> pthread_cond_broadcast</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> pthread_create</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> nanosleep</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> pthread_detach</div><div class="line">......</div></pre></td></tr></table></figure>

<h3 id="nm">nm</h3>
<p>nm显示目标文件的符号。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># nm go/bin/glide |more</span></div><div class="line"><span class="number">0000000000908680</span> r andMask</div><div class="line"><span class="number">0000000000901</span>d00 r bswapMask</div><div class="line"><span class="number">00000000009036</span>c0 r BSWAP_SHUFB_CTL</div><div class="line"><span class="number">0000000000</span>b000e0 B bufio.ErrAdvanceTooFar</div><div class="line"><span class="number">0000000000</span>b000f0 B bufio.ErrBufferFull</div><div class="line"><span class="number">0000000000</span>b00100 B bufio.ErrFinalToken</div><div class="line"><span class="number">0000000000</span>b00110 B bufio.ErrInvalidUnreadByte</div><div class="line"><span class="number">0000000000</span>b00120 B bufio.ErrInvalidUnreadRune</div><div class="line"><span class="number">0000000000</span>b00130 B bufio.ErrNegativeAdvance</div><div class="line"><span class="number">0000000000</span>b00140 B bufio.ErrNegativeCount</div><div class="line"><span class="number">0000000000</span>b00160 B bufio.errNegativeRead</div><div class="line"><span class="number">0000000000</span>b00170 B bufio.errNegativeWrite</div><div class="line"><span class="number">0000000000</span>b00150 B bufio.ErrTooLong</div><div class="line"><span class="number">00000000004</span>d9140 T bufio.init</div><div class="line"><span class="number">0000000000</span>b21120 B bufio.initdone.</div><div class="line"><span class="number">00000000004</span>d6510 T bufio.(*Reader).Buffered</div><div class="line"><span class="number">00000000004</span>d59d0 T bufio.(*Reader).Discard</div><div class="line"><span class="number">00000000004</span>d5590 T bufio.(*Reader).fill</div><div class="line"><span class="number">00000000004</span>d57c0 T bufio.(*Reader).Peek</div><div class="line"><span class="number">00000000004</span>d5b70 T bufio.(*Reader).Read</div><div class="line">......</div></pre></td></tr></table></figure>

<h3 id="strings">strings</h3>
<p>strings显示文件中的可打印字符。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># strings main|grep GLIBC</span></div><div class="line">GLIBC_2.<span class="number">2.5</span></div><div class="line">GLIBC_2.<span class="number">3.2</span></div><div class="line">GLIBC_2.<span class="number">2.5</span></div></pre></td></tr></table></figure>

<h3 id="strip">strip</h3>
<p>通过上面的工具，可以分析出文件的依赖库，创建Docker镜像的时候只需把所需的依赖库加进去即可。</p>
<p>如果程序本身比较大，可以将程序压缩，去掉不需要的一些数据， 比如使用<code>strip</code>进行裁剪。</p>
<p>你可以通过参数控制要丢掉的哪些符号。<br>比如去除符号表和行号信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">strip</span> main</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>最近在做Docker镜像的时候发现镜像文件非常大，需要找出程序的依赖库，减少程序的大小，所以整理了一下相关的工具。基本上这些工具都在<a href="https://www.gnu.org/software/binutils/" target="_blank" rel="e]]>
    </summary>
    
      <category term="工具" scheme="https://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[解决 error creating overlay mount to /var/lib/docker/overlay2]]></title>
    <link href="https://colobu.com/2018/06/28/Error-response-from-daemon-error-creating-overlay-mount-to-var-lib-docker-overlay2/"/>
    <id>https://colobu.com/2018/06/28/Error-response-from-daemon-error-creating-overlay-mount-to-var-lib-docker-overlay2/</id>
    <published>2018-06-28T08:45:44.000Z</published>
    <updated>2018-06-28T08:59:50.657Z</updated>
    <content type="html"><![CDATA[<p>最近在<code>centos7.1</code>使用docker运行<code>redis</code>镜像，出现下面的错误：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/usr/bin/docker-current: <span class="keyword">Error</span> response <span class="keyword">from</span> daemon: <span class="keyword">error</span> creating overlay mount <span class="keyword">to</span> /var/<span class="keyword">lib</span>/docker/overlay2/<span class="number">65</span>f3c109fb903539820f84856d2725af784f2f03f95b1f0214e34184e4d61ff7-init/merged: invalid argument.</div><div class="line">See <span class="comment">'/usr/bin/docker-current run --help'.</span></div></pre></td></tr></table></figure>

<p>在网上搜索一番后，一个可行的方案如下(改变storage driver类型， 禁用selinux):</p>
<ol>
<li>停止docker服务</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl stop docker</div></pre></td></tr></table></figure>

<ol>
<li>清理镜像</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -rf /var/lib/docker</div></pre></td></tr></table></figure>

<ol>
<li>修改存储类型</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/sysconfig/docker-storage</div></pre></td></tr></table></figure>

<p>把空的DOCKER_STORAGE_OPTIONS参数改为overlay:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DOCKER_STORAGE_OPTIONS=<span class="string">"--storage-driver overlay"</span></div></pre></td></tr></table></figure>

<ol>
<li>禁用selinux</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/sysconfig/docker</div></pre></td></tr></table></figure>

<p>去掉option的<code>--selinux-enabled</code></p>
<ol>
<li>启动docker应该就可以了</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl start docker</div></pre></td></tr></table></figure>

<p>方案抄自 <a href="https://blog.csdn.net/Ysssssssssssssss/article/details/79596367" target="_blank" rel="external">Ysssssssssssssss的博客</a> 和 redis的讨论: <a href="https://github.com/coreos/bugs/issues/2340" target="_blank" rel="external">error creating overlay mount to .../merged: invalid argument.</a>, 基本可以确定是启用selinux导致的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在<code>centos7.1</code>使用docker运行<code>redis</code>镜像，出现下面的错误：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div cl]]>
    </summary>
    
      <category term="Docker" scheme="https://colobu.com/categories/Docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 Go 实现快速排序]]></title>
    <link href="https://colobu.com/2018/06/26/implement-quick-sort-in-golang/"/>
    <id>https://colobu.com/2018/06/26/implement-quick-sort-in-golang/</id>
    <published>2018-06-26T10:29:33.000Z</published>
    <updated>2018-06-26T11:22:30.657Z</updated>
    <content type="html"><![CDATA[<p>快速排序(quick sort)号称是二十世纪最伟大的十大算法之一(<a href="http://www.uta.edu/faculty/rcli/TopTen/topten.pdf" target="_blank" rel="external">The Best of the 20th Century: Editors Name Top 10 Algorithms</a>), 但是快速排序也是最不容易实现的排序算法之一 (<a href=""></a>)。虽然它的原理非常的简单，但实现起来很容易出错。 也曾因为快排导致腥风血雨甚至网站攻击事件。</p>
<p>快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<blockquote>
<p>分治法：将问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。</p>
</blockquote>
<p>利用分治法可将快速排序的分为三步：</p>
<ul>
<li>在数据集之中，选择一个元素作为”基准”（pivot）。</li>
<li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。</li>
<li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li>
</ul>
<p>快速排序平均时间复杂度为<code>O(n log n)</code>,最坏情况为<code>O(n2)</code>，不稳定排序。</p>
<a id="more"></a>
<p>快速排序一般实现为原地排序(in-place),因为非原地排序会设计到大量的容器创建和对象复制。</p>
<p>本文实现了两种快速排序，一种是单线程的快速排序,一种是一定数量的goroutine并行的快速排序。</p>
<p>同时也增加了标准库排序算法和timsort算法的比较。</p>
<p>下面是算法实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"math/rand"</span></div><div class="line">	<span class="string">"sort"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/psilva261/timsort"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> partition(a []<span class="typename">int</span>, lo, hi <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">	pivot := a[hi]</div><div class="line">	i := lo -<span class="number"> 1</span></div><div class="line">	<span class="keyword">for</span> j := lo; j &lt; hi; j++ {</div><div class="line">		<span class="keyword">if</span> a[j] &lt; pivot {</div><div class="line">			i++</div><div class="line">			a[j], a[i] = a[i], a[j]</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">	a[i<span class="number">+1</span>], a[hi] = a[hi], a[i<span class="number">+1</span>]</div><div class="line">	<span class="keyword">return</span> i +<span class="number"> 1</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> quickSort(a []<span class="typename">int</span>, lo, hi <span class="typename">int</span>) {</div><div class="line">	<span class="keyword">if</span> lo &gt;= hi {</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	p := partition(a, lo, hi)</div><div class="line">	quickSort(a, lo, p<span class="number">-1</span>)</div><div class="line">	quickSort(a, p<span class="number">+1</span>, hi)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> quickSort_go(a []<span class="typename">int</span>, lo, hi <span class="typename">int</span>, done <span class="keyword">chan</span> <span class="keyword">struct</span>{}, depth <span class="typename">int</span>) {</div><div class="line">	<span class="keyword">if</span> lo &gt;= hi {</div><div class="line">		done &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	depth--</div><div class="line">	p := partition(a, lo, hi)</div><div class="line">	<span class="keyword">if</span> depth &gt;<span class="number"> 0</span> {</div><div class="line">		childDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 2</span>)</div><div class="line">		<span class="keyword">go</span> quickSort_go(a, lo, p<span class="number">-1</span>, childDone, depth)</div><div class="line">		<span class="keyword">go</span> quickSort_go(a, p<span class="number">+1</span>, hi, childDone, depth)</div><div class="line"></div><div class="line">		&lt;-childDone</div><div class="line">		&lt;-childDone</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		quickSort(a, lo, p<span class="number">-1</span>)</div><div class="line">		quickSort(a, p<span class="number">+1</span>, hi)</div><div class="line">	}</div><div class="line"></div><div class="line">	done &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	rand.Seed(time.Now().UnixNano())</div><div class="line"></div><div class="line">	testData1, testData2, testData3, testData4 := <span class="built_in">make</span>([]<span class="typename">int</span>,<span class="number"> 0</span>,<span class="number"> 100000000</span>), <span class="built_in">make</span>([]<span class="typename">int</span>,<span class="number"> 0</span>,<span class="number"> 100000000</span>), <span class="built_in">make</span>([]<span class="typename">int</span>,<span class="number"> 0</span>,<span class="number"> 100000000</span>), <span class="built_in">make</span>([]<span class="typename">int</span>,<span class="number"> 0</span>,<span class="number"> 100000000</span>)</div><div class="line">	times :=<span class="number"> 100000000</span></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; times; i++ {</div><div class="line">		val := rand.Intn<span class="number">(20000000</span>)</div><div class="line">		testData1 = <span class="built_in">append</span>(testData1, val)</div><div class="line">		testData2 = <span class="built_in">append</span>(testData2, val)</div><div class="line">		testData3 = <span class="built_in">append</span>(testData3, val)</div><div class="line">		testData4 = <span class="built_in">append</span>(testData4, val)</div><div class="line">	}</div><div class="line"></div><div class="line">	start := time.Now()</div><div class="line">	quickSort(testData1,<span class="number"> 0</span>, <span class="built_in">len</span>(testData1<span class="number">)-1</span>)</div><div class="line">	fmt.Println(<span class="string">"single goroutine: "</span>, time.Now().Sub(start))</div><div class="line"></div><div class="line">	<span class="keyword">if</span> !sort.IntsAreSorted(testData1) {</div><div class="line">		fmt.Println(<span class="string">"wrong quick_sort implementation"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})</div><div class="line">	start = time.Now()</div><div class="line">	<span class="keyword">go</span> quickSort_go(testData2,<span class="number"> 0</span>, <span class="built_in">len</span>(testData2<span class="number">)-1</span>, done,<span class="number"> 5</span>)</div><div class="line">	&lt;-done</div><div class="line">	fmt.Println(<span class="string">"multiple goroutine: "</span>, time.Now().Sub(start))</div><div class="line"></div><div class="line">	<span class="keyword">if</span> !sort.IntsAreSorted(testData2) {</div><div class="line">		fmt.Println(<span class="string">"wrong quickSort_go implementation"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	start = time.Now()</div><div class="line">	sort.Ints(testData3)</div><div class="line">	fmt.Println(<span class="string">"std lib: "</span>, time.Now().Sub(start))</div><div class="line"></div><div class="line">	<span class="keyword">if</span> !sort.IntsAreSorted(testData3) {</div><div class="line">		fmt.Println(<span class="string">"wrong std lib implementation"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	start = time.Now()</div><div class="line">	timsort.Ints(testData4, <span class="keyword">func</span>(a, b <span class="typename">int</span>) <span class="typename">bool</span> { <span class="keyword">return</span> a &lt;= b })</div><div class="line">	fmt.Println(<span class="string">"timsort: "</span>, time.Now().Sub(start))</div><div class="line"></div><div class="line">	<span class="keyword">if</span> !sort.IntsAreSorted(testData4) {</div><div class="line">		fmt.Println(<span class="string">"wrong timsort implementation"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>快速排序(quick sort)号称是二十世纪最伟大的十大算法之一(<a href="http://www.uta.edu/faculty/rcli/TopTen/topten.pdf" target="_blank" rel="external">The Best of the 20th Century: Editors Name Top 10 Algorithms</a>), 但是快速排序也是最不容易实现的排序算法之一 (<a href=""></a>)。虽然它的原理非常的简单，但实现起来很容易出错。 也曾因为快排导致腥风血雨甚至网站攻击事件。</p>
<p>快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<blockquote>
<p>分治法：将问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。</p>
</blockquote>
<p>利用分治法可将快速排序的分为三步：</p>
<ul>
<li>在数据集之中，选择一个元素作为”基准”（pivot）。</li>
<li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。</li>
<li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li>
</ul>
<p>快速排序平均时间复杂度为<code>O(n log n)</code>,最坏情况为<code>O(n2)</code>，不稳定排序。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CGO 文章整理]]></title>
    <link href="https://colobu.com/2018/06/13/cgo-articles/"/>
    <id>https://colobu.com/2018/06/13/cgo-articles/</id>
    <published>2018-06-13T10:08:15.000Z</published>
    <updated>2018-08-28T10:56:52.554Z</updated>
    <content type="html"><![CDATA[<p>虽然<code>CGO</code>属于不太常用的技术，但是偶尔在一些场景中还是会用到的，本文搜集了一些<code>CGO</code>的文章, 方便大家学习和参考。</p>
<a id="more"></a>
<h3 id="官方文章">官方文章</h3>
<ul>
<li><a href="https://golang.org/cmd/cgo/" target="_blank" rel="external">cmd/cgo</a>: cgo命令行工具</li>
<li><a href="https://github.com/golang/go/wiki/cgo" target="_blank" rel="external">wiki/cgo</a>: 简介</li>
<li><a href="https://blog.golang.org/c-go-cgo" target="_blank" rel="external">C? Go? Cgo!</a>: 古老的文章</li>
<li><a href="https://github.com/golang/go/wiki/WindowsDLLs" target="_blank" rel="external">WindowsDLLs</a>: 不是CGO</li>
<li><a href="https://docs.hacknode.org/gopl-zh/ch13/ch13-04.html" target="_blank" rel="external">通过cgo调用C代码</a>: Go语言圣经中的介绍</li>
</ul>
<h3 id="相关文章">相关文章</h3>
<ul>
<li><a href="https://dave.cheney.net/2016/01/18/cgo-is-not-go" target="_blank" rel="external">cgo is not Go</a>: Dave Cheney的文章，CGO不好的地方，<a href="https://www.oschina.net/translate/cgo-is-not-go" target="_blank" rel="external">中文</a></li>
<li><a href="http://relistan.com/cgo-when-and-when-not-to-use-it/" target="_blank" rel="external">Cgo: When and (Usually) When Not to Use it</a>:决断</li>
<li><a href="https://www.cockroachlabs.com/blog/the-cost-and-complexity-of-cgo/" target="_blank" rel="external">The Cost and Complexity of Cgo</a>: 实践出真知</li>
<li><a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoCGoStringFunctions" target="_blank" rel="external">CGo&#39;s Go string functions explained</a>: CGO的字符串</li>
<li><a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoCGoCompatibleStructs" target="_blank" rel="external">Getting C-compatible structs in Go with and for cgo</a>: C兼容的 struct</li>
<li><a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoCgoExperienceNotes" target="_blank" rel="external">Some notes on my experience using Go&#39;s cgo system</a>: CGO使用经验</li>
<li><a href="https://medium.com/using-go-in-mobile-apps/using-go-in-mobile-apps-part-1-calling-go-functions-from-c-be1ecf7dfbc6" target="_blank" rel="external">Calling Go functions from C</a>: 在C语言中调用Go函数以及相反</li>
<li><a href="https://medium.com/learning-the-go-programming-language/calling-go-functions-from-other-languages-4c7d8bcc69bf" target="_blank" rel="external">Calling Go Functions from Other Languages</a>:从其它语言调用Go函数</li>
<li><a href="https://blog.filippo.io/rustgo/" target="_blank" rel="external">rustgo: calling Rust from Go with near-zero overhead</a>:使用的不是CGO,而是FFI</li>
<li><a href="https://blog.wallaroolabs.com/2018/04/adventures-with-cgo-part-1--the-pointering/" target="_blank" rel="external">Adventures with cgo: Part 1- The Pointering</a>: 探索</li>
<li><a href="http://akrennmair.github.io/golang-cgo-slides/#1" target="_blank" rel="external">Go &amp; cgo: integrating existing C code with Go</a>: 干货PPT</li>
<li><a href="https://www.jianshu.com/p/7d67068848a4" target="_blank" rel="external">如何在windows上使用cgo</a>: 中文，windows上使用CGO</li>
<li><a href="http://bastengao.com/blog/2017/12/go-cgo-c.html" target="_blank" rel="external">在 Go 语言中调用 C 代码</a>: 高辉的两篇介绍， 手把手教</li>
<li><a href="http://bastengao.com/blog/2017/12/go-cgo-cpp.html" target="_blank" rel="external">在 Go 语言中调用 C++ 代码</a>:</li>
<li><a href="http://blog.sina.com.cn/s/blog_48c95a190102w2ln.html" target="_blank" rel="external">Golang使用pkg-config自动获取头文件和链接库的方法</a>: 使用pkg-config简化CFLAGS和LDFLAGS设置</li>
<li><a href="http://gridengine.eu/index.php/other-stories/232-avoiding-the-ldlibrarypath-with-shared-libs-in-go-cgo-applications-2015-12-21" target="_blank" rel="external">Avoiding the LD_LIBRARY_PATH for Shared Libs in Go (cgo) Applications</a>: 设置CGO_LDFLAGS和CGO_CFLAGS环境变量</li>
<li><a href="https://artem.krylysov.com/blog/2017/04/13/handling-cpp-exceptions-in-go/" target="_blank" rel="external">Handling C++ exceptions in Go</a>: 处理C++的异常</li>
<li><a href="https://hackernoon.com/extending-python-3-in-go-78f3a69552ac" target="_blank" rel="external">Extending Python 3 in Go</a>:使用Go扩展Python</li>
<li><a href="https://dev.to/mattn/call-go-function-from-c-function-1n3" target="_blank" rel="external">Call Go function from C function</a>: c调用go</li>
<li><a href="http://technosophos.com/2013/06/20/go-calling-pointer-functions-c-cgo.html" target="_blank" rel="external">Go: Calling pointer functions in C with CGO</a>: 调用C函数指针</li>
<li><a href="https://www.cnblogs.com/cobbliu/p/5035358.html" target="_blank" rel="external">CGo中传递多维数组给C函数</a>: 多维数组处理</li>
<li><a href="https://github.com/giorgisio/cgo" target="_blank" rel="external">cgo by example</a>: cgo例子</li>
<li><a href="http://www.liuweihua.cn/2018/01/24/golang-cgo/" target="_blank" rel="external">golang cgo</a>: 总结</li>
<li><a href="http://www.swig.org/Doc3.0/Go.html" target="_blank" rel="external">SWIG and Go</a>: C++</li>
<li><a href="https://stackoverflow.com/questions/6125683/call-go-functions-from-c" target="_blank" rel="external">Call Go functions from C</a>: C中调用Go函数</li>
<li><a href="https://github.com/chai2010/advanced-go-programming-book/blob/master/ch2-cgo/readme.md" target="_blank" rel="external">CGO编程</a>:柴树杉 《Go语言高级编程》中的CGO一章</li>
</ul>
<h3 id="辅助工具">辅助工具</h3>
<ul>
<li><a href="https://github.com/xlab/c-for-go" target="_blank" rel="external">c-for-go</a>: cgo产生器</li>
<li><a href="https://github.com/gonuts/ffi" target="_blank" rel="external">ffi</a>: 不使用CGO的另一种方式，ffi</li>
<li><a href="https://github.com/michlabs/cgoutil" target="_blank" rel="external">cgoutil</a>: 字符串数组的便利方法</li>
<li><a href="https://github.com/vitaminwater/cgo.wchar" target="_blank" rel="external">cgo.wchar</a>: wchar_t的便利方法</li>
<li><a href="https://godoc.org/github.com/chai2010/cgo" target="_blank" rel="external">chai2010/cgo</a>: 柴树杉实现的辅助方法</li>
</ul>
<h3 id="CGO应用">CGO应用</h3>
<ul>
<li><a href="https://github.com/draffensperger/go-interlang" target="_blank" rel="external">go-interlang</a>: go与几种语言相互调用的例子</li>
<li><a href="https://github.com/kitech/qt.go" target="_blank" rel="external">qt.go</a>: QT binding</li>
<li><a href="https://github.com/gen2brain/raylib-go" target="_blank" rel="external">raylib-go</a>:光线追踪库</li>
<li><a href="https://github.com/go-opencv/go-opencv" target="_blank" rel="external">go-opencv</a>:</li>
<li><a href="https://github.com/hashicorp/raft-mdb" target="_blank" rel="external">hashicorp/raft-mdb</a>:</li>
<li><a href="https://github.com/mattn/go-sqlite3" target="_blank" rel="external">go-sqlite3</a>:</li>
<li><a href="https://github.com/tecbot/gorocksdb" target="_blank" rel="external">gorocksdb</a>:</li>
<li><a href="https://github.com/AllenDang/w32" target="_blank" rel="external">w32</a>: win32 API包装</li>
<li><a href="https://github.com/quirkey/magick/blob/master/magick.go" target="_blank" rel="external">magick</a>: 代码量少，易学习</li>
<li><a href="https://github.com/imroc/ontts" target="_blank" rel="external">ontts</a>:科大讯飞语音linux在线语音合成后台服务</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然<code>CGO</code>属于不太常用的技术，但是偶尔在一些场景中还是会用到的，本文搜集了一些<code>CGO</code>的文章, 方便大家学习和参考。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[搭建IPFS私有网络]]></title>
    <link href="https://colobu.com/2018/05/29/setup-ipfs-private-network/"/>
    <id>https://colobu.com/2018/05/29/setup-ipfs-private-network/</id>
    <published>2018-05-29T09:05:56.000Z</published>
    <updated>2018-05-29T09:35:26.386Z</updated>
    <content type="html"><![CDATA[<p>IPFS (InterPlanetary File System) 是一个面向全球的、点对点的分布式版本文件系统。它用基于内容的地址替代基于域名的地址，也就是用户寻找的不是某个地址而是储存在某个地方的内容，不需要验证发送者的身份，而只需要验证内容的哈希，通过这样可以让网页的速度更快、更安全、更健壮、更持久。IPFS表示，IPFS未来将替代HTTP（以及其他的许多东西）。</p>
<blockquote>
<p>IPFS 和 BitTorrent 的区别: <a href="https://github.com/ipfs/faq/issues/17" target="_blank" rel="external">How does it compare to BitTorrent&#39;s Project Maelstrom?</a></p>
</blockquote>
<p>IPFS从根本上改变了用户搜索的方式。通过IPFS，用户搜索的是内容。通过HTTP浏览器搜索文件的时候，首先找到服务器的位置（IP地址），然后使用路径名称在服务器上查找文件。按照这个设计，只有文件所有者可以判断这是否是用户要找的文件。此时，必须保证托管者不会通过移除文件或者关闭服务器而对文件做任何更改。</p>
<p>当文件被添加到IPFS节点上，它得到一个新的名字。这个名字实际上是一个加密哈希，它是从文件内容中被计算出来。通过加密保证该哈希始终只表示该文件的内容。哪怕只在文件中修改一个比特的数据，哈希都会完全不同。</p>
<p>当下一步向IPFS分布式网络询问哈希的时候，它通过使用一个分布式哈希表，可以快速（在一个拥有10,000,000个节点的网络中只需要20跳）地找到拥有数据的节点，从而检索该数据，并使用哈希验证这是否是正确的数据。</p>
<p>不幸的是， IPFS 被<strong>墙</strong>了。如果你有幸能翻墙，你可以通过通过下面的命令下载并安装预编译的ipfs工具。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tar xvfz go-ipfs.tar.gz</div><div class="line"><span class="built_in">cd</span> go-ipfs</div><div class="line">./install.sh</div></pre></td></tr></table></figure>

<p>然后初始化仓库:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; ipfs init</div><div class="line"></div><div class="line">initializing ipfs node <span class="keyword">at</span> /Users/jbenet/.go-ipfs</div><div class="line">generating <span class="number">2048</span>-bit RSA keypair...done</div><div class="line">peer identity: Qmcpo2iLBikrdf1d6QU6vXuNb6P7hwrbNPW9kLAH8eG67z</div><div class="line"><span class="built_in">to</span> <span class="built_in">get</span> started, enter:</div><div class="line"></div><div class="line">  ipfs cat /ipfs/QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG/readme</div></pre></td></tr></table></figure>

<p>它默认会在你的Home下创建一个<code>.ipfs</code>文件夹。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ipfs cat /ipfs/QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG/readme</div></pre></td></tr></table></figure>

<p>查看ipfs网络上的一个文件，正常你可以看到这个文件的内容。</p>
<p>你可以使用<code>ipfs add</code>上传文件，<code>ipfs cat</code>查看文件。当然<code>ipfs</code>包含很多的命令，你可以在 <a href="https://ipfs.io/docs/commands/" target="_blank" rel="external">commands</a> 页面查看每个命令。</p>
<p>默认IPFS会通过一些种子连接到IPFS全球网络， 如果你想搭建一个私有的IPFS网络，可以使用本文下面介绍的方法。</p>
<a id="more"></a>
<h2 id="初始化一个私有仓库">初始化一个私有仓库</h2>
<p>命令同上</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ipfs init</div></pre></td></tr></table></figure>

<p>默认<code>$IPFS_PATH</code>为<code>$Home\.ipfs</code>文件夹。</p>
<h2 id="创建共享的key">创建共享的key</h2>
<p>使用<a href="https://github.com/Kubuxu/go-ipfs-swarm-key-gen" target="_blank" rel="external">ipfs-swarm-key-gen</a>创建私有网络共享的key, 私有网络的所有的节点都使用这个key, 不使用这个key的节点无法加入这个私有网络。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">go get github.com/Kubuxu/go-ipfs-swarm-key-gen/ipfs-swarm-key-gen</div><div class="line">ipfs-swarm-key-gen &gt; ~/.ipfs/swarm.key</div></pre></td></tr></table></figure>

<h2 id="移除默认的bootstrap节点">移除默认的bootstrap节点</h2>
<p>为了不连接全球的IPFS网络，你需要将默认的bootstrap的节点信息删除。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ipfs bootstrap rm --all</div></pre></td></tr></table></figure>

<h2 id="加入私有网络">加入私有网络</h2>
<p>如果是第一个节点， 这一步可以省略。</p>
<p>如果你已经知道了私有网络的一些节点，你可以把它们作为bootstrap节点。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ipfs bootstrap add &lt;multiaddr&gt;</div></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ipfs bootstrap add <span class="regexp">/ip4/</span><span class="number">104.236</span>.<span class="number">76.40</span><span class="regexp">/tcp/</span><span class="number">4001</span><span class="regexp">/ipfs/</span>QmSoLV4Bbm51jM9C4gDYZQ9Cy3U6aXMJDAbzgu2fzaDs64</div></pre></td></tr></table></figure>

<h2 id="设置LIBP2P_FORCE_PNET">设置LIBP2P_FORCE_PNET</h2>
<p>设置环境变量<code>LIBP2P_FORCE_PNET</code>为<code>1</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> LIBP2P_FORCE_PNET=<span class="number">1</span></div></pre></td></tr></table></figure>

<h2 id="测试">测试</h2>
<p>在一个节点上增加一个文件，然后在另外一个节点cat这个文件，看看是否成功了。</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="http://www.infoq.com/cn/articles/ipfs" target="_blank" rel="external">http://www.infoq.com/cn/articles/ipfs</a></li>
<li><a href="https://github.com/ipfs/go-ipfs/blob/master/docs/experimental-features.md#private-networks" target="_blank" rel="external">https://github.com/ipfs/go-ipfs/blob/master/docs/experimental-features.md#private-networks</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>IPFS (InterPlanetary File System) 是一个面向全球的、点对点的分布式版本文件系统。它用基于内容的地址替代基于域名的地址，也就是用户寻找的不是某个地址而是储存在某个地方的内容，不需要验证发送者的身份，而只需要验证内容的哈希，通过这样可以让网页的速度更快、更安全、更健壮、更持久。IPFS表示，IPFS未来将替代HTTP（以及其他的许多东西）。</p>
<blockquote>
<p>IPFS 和 BitTorrent 的区别: <a href="https://github.com/ipfs/faq/issues/17" target="_blank" rel="external">How does it compare to BitTorrent&#39;s Project Maelstrom?</a></p>
</blockquote>
<p>IPFS从根本上改变了用户搜索的方式。通过IPFS，用户搜索的是内容。通过HTTP浏览器搜索文件的时候，首先找到服务器的位置（IP地址），然后使用路径名称在服务器上查找文件。按照这个设计，只有文件所有者可以判断这是否是用户要找的文件。此时，必须保证托管者不会通过移除文件或者关闭服务器而对文件做任何更改。</p>
<p>当文件被添加到IPFS节点上，它得到一个新的名字。这个名字实际上是一个加密哈希，它是从文件内容中被计算出来。通过加密保证该哈希始终只表示该文件的内容。哪怕只在文件中修改一个比特的数据，哈希都会完全不同。</p>
<p>当下一步向IPFS分布式网络询问哈希的时候，它通过使用一个分布式哈希表，可以快速（在一个拥有10,000,000个节点的网络中只需要20跳）地找到拥有数据的节点，从而检索该数据，并使用哈希验证这是否是正确的数据。</p>
<p>不幸的是， IPFS 被<strong>墙</strong>了。如果你有幸能翻墙，你可以通过通过下面的命令下载并安装预编译的ipfs工具。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tar xvfz go-ipfs.tar.gz</div><div class="line"><span class="built_in">cd</span> go-ipfs</div><div class="line">./install.sh</div></pre></td></tr></table></figure>

<p>然后初始化仓库:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; ipfs init</div><div class="line"></div><div class="line">initializing ipfs node <span class="keyword">at</span> /Users/jbenet/.go-ipfs</div><div class="line">generating <span class="number">2048</span>-bit RSA keypair...done</div><div class="line">peer identity: Qmcpo2iLBikrdf1d6QU6vXuNb6P7hwrbNPW9kLAH8eG67z</div><div class="line"><span class="built_in">to</span> <span class="built_in">get</span> started, enter:</div><div class="line"></div><div class="line">  ipfs cat /ipfs/QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG/readme</div></pre></td></tr></table></figure>

<p>它默认会在你的Home下创建一个<code>.ipfs</code>文件夹。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ipfs cat /ipfs/QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG/readme</div></pre></td></tr></table></figure>

<p>查看ipfs网络上的一个文件，正常你可以看到这个文件的内容。</p>
<p>你可以使用<code>ipfs add</code>上传文件，<code>ipfs cat</code>查看文件。当然<code>ipfs</code>包含很多的命令，你可以在 <a href="https://ipfs.io/docs/commands/" target="_blank" rel="external">commands</a> 页面查看每个命令。</p>
<p>默认IPFS会通过一些种子连接到IPFS全球网络， 如果你想搭建一个私有的IPFS网络，可以使用本文下面介绍的方法。</p>
]]>
    
    </summary>
    
      <category term="IPFS" scheme="https://colobu.com/tags/IPFS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[停止、删除所有的docker容器和镜像]]></title>
    <link href="https://colobu.com/2018/05/15/Stop-and-remove-all-docker-containers-and-images/"/>
    <id>https://colobu.com/2018/05/15/Stop-and-remove-all-docker-containers-and-images/</id>
    <published>2018-05-15T10:10:59.000Z</published>
    <updated>2018-05-31T12:25:32.094Z</updated>
    <content type="html"><![CDATA[<p>这些命令总是记不住，或者说不用心去记，所以记录在本文中，以便将来查询。</p>
<a id="more"></a>
<h2 id="列出所有的容器_ID">列出所有的容器 ID</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">ps</span> -aq</div></pre></td></tr></table></figure>

<h2 id="停止所有的容器">停止所有的容器</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">stop</span> $(docker <span class="keyword">ps</span> -aq)</div></pre></td></tr></table></figure>

<h2 id="删除所有的容器">删除所有的容器</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm $(docker <span class="keyword">ps</span> -aq)</div></pre></td></tr></table></figure>

<h2 id="删除所有的镜像">删除所有的镜像</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi <span class="variable">$(</span>docker images -q)</div></pre></td></tr></table></figure>

<h2 id="复制文件">复制文件</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker cp mycontainer:/opt/<span class="built_in">file</span>.txt /opt/<span class="built_in">local</span>/</div><div class="line">docker cp /opt/<span class="built_in">local</span>/<span class="built_in">file</span>.txt mycontainer:/opt/</div></pre></td></tr></table></figure>

<p><strong>更新</strong>: @snakeliwei 的提醒， 现在的docker有了专门清理资源(container、image、网络)的命令。 docker 1.13 中增加了 <code>docker system prune</code>的命令，针对container、image可以使用<code>docker container prune</code>、<code>docker image prune</code>命令。</p>
<ul>
<li><code>docker image prune --force --all</code>或者docker image prune -f -a` : 删除所有不使用的镜像</li>
<li><code>docker container prune -f</code>: 删除所有停止的容器</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这些命令总是记不住，或者说不用心去记，所以记录在本文中，以便将来查询。</p>
]]>
    
    </summary>
    
      <category term="Docker" scheme="https://colobu.com/categories/Docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2018微博内部技术分享春晚专场]]></title>
    <link href="https://colobu.com/2018/04/24/weibo-share-2018/"/>
    <id>https://colobu.com/2018/04/24/weibo-share-2018/</id>
    <published>2018-04-24T10:29:50.000Z</published>
    <updated>2018-04-24T10:32:10.251Z</updated>
    <content type="html"><![CDATA[<p>这是公司内部分享的各部门春晚保障的技术分享。我将其中的和公司隐私相关的数据删除了，只保留了技术的介绍，总结了一些知识点。</p>
<p>Tim开场白。</p>
<p>双十一、微信红包和微博的区别（无法预期）。</p>
<p>三条军规。</p>
<a id="more"></a>
<h2 id="孟兆飞_混合云架构下微博春晚保障">孟兆飞 混合云架构下微博春晚保障</h2>
<h3 id="流量">流量</h3>
<ul>
<li>突发流量： 日常、异常</li>
<li>春晚</li>
<li>央视合作</li>
</ul>
<h3 id="万台扩容挑战">万台扩容挑战</h3>
<ul>
<li>联路长</li>
<li>依赖多</li>
<li>高并发</li>
</ul>
<p>15分钟1000台全公司随时随地</p>
<h3 id="自动化">自动化</h3>
<ul>
<li>智能弹性</li>
<li>混合云平台</li>
<li>监控信息</li>
<li>容量评估</li>
</ul>
<p>双仓库(公司内网、阿里云)</p>
<h3 id="高可用">高可用</h3>
<p>传统扩容，由于资源限制会失败</p>
<p>优化扩容：基于多种策略</p>
<p>DCP高可用双机房</p>
<h3 id="春节保障">春节保障</h3>
<p>春节X台扩容、云上X台<br>流量监控</p>
<p>DNS问题、扩容 （16台支持万台client） UDP session?</p>
<p>全链路压测。演练。共享池。重点监控。</p>
<h2 id="熊超_让红包飞春晚55万qps解决方案">熊超 让红包飞春晚55万qps解决方案</h2>
<p>超预期</p>
<h3 id="战队红包">战队红包</h3>
<h4 id="业务">业务</h4>
<p>满N万开奖</p>
<ul>
<li>瞬间QPS高</li>
<li>参与人数越多，开奖越快</li>
<li>瞬间开奖</li>
<li>参与规则复杂，单次参与动作资源交互次数10+</li>
</ul>
<h4 id="实现">实现</h4>
<p>5台扫描， 扔队列， 30台队列机， 64组redis， 发奖发私信等</p>
<p>前端： 缓存、不可缓存</p>
<h3 id="红包雨">红包雨</h3>
<h4 id="业务-1">业务</h4>
<p>3次机会，10分钟任意点</p>
<ul>
<li>参与用户多</li>
<li>拼手速、qps 55万</li>
<li>每次点击都有请求</li>
<li>中出数量巨大， 5次红包雨1.6亿</li>
</ul>
<h4 id="实现-1">实现</h4>
<ul>
<li>传送门 检查用户等，加密防刷、垃圾用户过滤、入口处错峰</li>
<li>抽奖: 特别快的请求、根据用户区分奖项</li>
<li>中出</li>
<li>队列机</li>
</ul>
<h4 id="优化">优化</h4>
<ul>
<li>代码： 重复资源链接重用、耗时步骤优化、根据日志</li>
<li>DBA： 监控平台</li>
</ul>
<h4 id="压测评估">压测评估</h4>
<h2 id="温情_陈新伍_春节百万答题">温情 陈新伍 春节百万答题</h2>
<p>两三周紧急开发。</p>
<h3 id="背景">背景</h3>
<p>大家都在做，拉新拉活。</p>
<p>产品经理介绍这个产品。</p>
<h3 id="技术挑战">技术挑战</h3>
<ul>
<li>快速扩所容</li>
<li>快速下发push设计</li>
</ul>
<h3 id="简介">简介</h3>
<ul>
<li>视频流</li>
<li>消息互动</li>
<li>问答</li>
</ul>
<p>发题阶段 -&gt; 答题阶段 -&gt; 颁奖阶段</p>
<h3 id="技术挑战-1">技术挑战</h3>
<ul>
<li>消息实时性</li>
<li><p>同步答题、实时到达率</p>
</li>
<li><p>每秒千万推送</p>
</li>
<li>百万在线</li>
</ul>
<h3 id="长连推送">长连推送</h3>
<ul>
<li>百万长连接</li>
<li><p>水平弹性伸缩</p>
<ul>
<li>无状态服务</li>
<li>减少资源的依赖</li>
</ul>
</li>
<li><p>消息分发队列: Reids的PubSub (apiServer  -&gt; redis)</p>
</li>
</ul>
<h3 id="问答服务">问答服务</h3>
<ul>
<li>上行: 接口https</li>
<li>下行方案:<ul>
<li>互动消息下发</li>
<li>轮训 (西瓜视频)</li>
<li>加入房间时全量下发(容易漏题)</li>
<li>视频流(SEI)下发(丢包)</li>
</ul>
</li>
</ul>
<p>微博方案: 1为主，2为辅</p>
<p>发题方案：  </p>
<ul>
<li>Push+ACK： 有条件重传</li>
<li>Push + Push: 无条件重传</li>
</ul>
<p>轮训：长链接断后自动重连降级</p>
<p>发题设计：根据服务器NTP， 题目和视频校准同时弹出</p>
<p>答题阶段</p>
<ul>
<li>客户端答题服务器判题</li>
<li>复活</li>
<li>答题结果推送</li>
<li>答题汇总</li>
<li>汇总推送</li>
</ul>
<p>10万级别的qps</p>
<p>判题方案：</p>
<ul>
<li>异步判题</li>
<li>随机重试机制</li>
</ul>
<p>服务压测</p>
<ul>
<li>第一场就全量push,无灰度</li>
<li>峰值速度快，第一题为峰值</li>
<li>百万用户</li>
</ul>
<h2 id="关里_微博搜索架构">关里 微博搜索架构</h2>
<h3 id="架构">架构</h3>
<p>trigger -&gt; 数据转换 -&gt; 预处理 -&gt; 数据分发 --&gt; 索引库</p>
<p>各种检索模块</p>
<p>热点爆发白页</p>
<p>数据分层：优质、筛选、全量</p>
<p>自动扩容、自动降级</p>
<p>1000多亿次数据需要索引</p>
<p>单机7、8亿</p>
<h2 id="朱伟_支撑百亿级请求的微博广告运维技术实践">朱伟 支撑百亿级请求的微博广告运维技术实践</h2>
<p>运维在微博广告体系中的价值。</p>
<p>人工 -&gt; 工具 -&gt; DevOps -&gt; AiOps</p>
<ul>
<li>监控: 数据采集、清洗、存储。Filebeat -&gt; kafka -&gt; OLS -&gt; Druid, kafka -&gt; graphite, kafka -&gt; logstash -&gt; ES, 多存储graphite,druid,ES, clickhouse</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是公司内部分享的各部门春晚保障的技术分享。我将其中的和公司隐私相关的数据删除了，只保留了技术的介绍，总结了一些知识点。</p>
<p>Tim开场白。</p>
<p>双十一、微信红包和微博的区别（无法预期）。</p>
<p>三条军规。</p>
]]>
    
    </summary>
    
      <category term="分享" scheme="https://colobu.com/categories/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go Channel 应用模式]]></title>
    <link href="https://colobu.com/2018/03/26/channel-patterns/"/>
    <id>https://colobu.com/2018/03/26/channel-patterns/</id>
    <published>2018-03-26T14:00:35.000Z</published>
    <updated>2018-08-30T03:11:58.563Z</updated>
    <content type="html"><![CDATA[<p>Channel是Go中的一种类型，和goroutine一起为Go提供了并发技术， 它在开发中得到了广泛的应用。Go鼓励人们通过Channel在goroutine之间传递数据的引用(就像把数据的owner从一个goroutine传递给另外一个goroutine), <a href="http://golang.org/doc/effective_go.html" target="_blank" rel="external">Effective Go</a>总结了这么一句话：</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<p>在 <a href="https://golang.org/ref/mem" target="_blank" rel="external">Go内存模型</a>指出了channel作为并发控制的一个特性：</p>
<blockquote>
<p>A send on a channel happens before the corresponding receive from that channel completes. (Golang Spec)</p>
</blockquote>
<p>除了正常的在goroutine之间安全地传递共享数据， Channel还可以玩出很多的花样(模式)， 本文列举了一些channel的应用模式。</p>
<p>促成本文诞生的因素主要包括：</p>
<ol>
<li>eapache的channels库</li>
<li>concurrency in go 这本书</li>
<li>Francesc Campoy的 justforfun系列中关于merge channel的实现</li>
<li>我在出版Scala集合手册这本书中对Scala集合的启发</li>
</ol>
<p>下面就让我们以实例的方式看看这么模式吧。</p>
<a id="more"></a>
<h2 id="Lock/TryLock_模式">Lock/TryLock 模式</h2>
<p>我们知道， Go的标准库<code>sync</code>有<code>Mutex</code>,可以用来作为锁，但是<code>Mutex</code>却没有实现<code>TryLock</code>方法。</p>
<p>我们对于<code>TryLock</code>的定义是当前goroutine尝试获得锁， 如果成功，则获得了锁，返回true, 否则返回false。我们可以使用这个方法避免在获取锁的时候当前goroutine被阻塞住。</p>
<p>本来，这是一个常用的功能，在一些其它编程语言中都有实现，为什么Go中没有实现的？<a href="https://github.com/golang/go/issues/6123" target="_blank" rel="external">issue#6123</a>有详细的讨论，在我看来，Go核心组成员本身对这个特性没有积极性，并且认为通过channel可以实现相同的方式。</p>
<h3 id="Hacked_Lock/TryLock_模式">Hacked Lock/TryLock 模式</h3>
<p>其实，对于标准库的<code>sync.Mutex</code>要增加这个功能很简单，下面的方式就是通过<code>hack</code>的方式为<code>Mutex</code>实现了<code>TryLock</code>的功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mutexLocked =<span class="number"> 1</span> &lt;&lt; <span class="constant">iota</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> {</div><div class="line">	mu sync.Mutex</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) Lock() {</div><div class="line">	m.mu.Lock()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) Unlock() {</div><div class="line">	m.mu.Unlock()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> atomic.CompareAndSwapInt32((*<span class="typename">int32</span>)(unsafe.Pointer(&m.mu)),<span class="number"> 0</span>, mutexLocked)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) IsLocked() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> atomic.LoadInt32((*<span class="typename">int32</span>)(unsafe.Pointer(&m.mu))) == mutexLocked</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你看一下<code>Mutex</code>实现的源代码，就很容易理解上面的这段代码了，因为<code>mutex</code>实现锁主要利用<code>CAS</code>对它的一个int32字段做操作。</p>
<p>上面的代码还额外增加了一个<code>IsLocked</code>方法，不过这个方法一般不常用，因为查询和加锁这两个方法执行的时候不是一个原子的操作，素以这个方法一般在调试和打日志的时候可能有用。</p>
<h3 id="TryLock_By_Channel">TryLock By Channel</h3>
<p>既然标准库中不准备在<code>Mutex</code>上增加这个方法，而是推荐使用channel来实现，那么就让我们看看如何使用 channel来实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> {</div><div class="line">	ch <span class="keyword">chan</span> <span class="keyword">struct</span>{}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> NewMutex() *Mutex {</div><div class="line">	mu := &Mutex{<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 1</span>)}</div><div class="line">	mu.ch &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">	<span class="keyword">return</span> mu</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) Lock() {</div><div class="line">	&lt;-m.ch</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) Unlock() {</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> m.ch &lt;- <span class="keyword">struct</span>{}{}:</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"unlock of unlocked mutex"</span>)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> &lt;-m.ch:</div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) IsLocked() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(m.ch) ==<span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>主要是利用channel边界情况下的阻塞特性实现的。</p>
<p>你还可以将缓存的大小从1改为n,用来处理n个锁(资源)。</p>
<h3 id="TryLock_with_Timeout">TryLock with Timeout</h3>
<p>有时候，我们在获取一把锁的时候，由于有竞争的关系，在锁被别的goroutine拥有的时候，当前goroutine没有办法立即获得锁，只能阻塞等待。标准库并没有提供等待超时的功能，我们尝试实现它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> {</div><div class="line">	ch <span class="keyword">chan</span> <span class="keyword">struct</span>{}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> NewMutex() *Mutex {</div><div class="line">	mu := &Mutex{<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 1</span>)}</div><div class="line">	mu.ch &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">	<span class="keyword">return</span> mu</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) Lock() {</div><div class="line">	&lt;-m.ch</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) Unlock() {</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> m.ch &lt;- <span class="keyword">struct</span>{}{}:</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"unlock of unlocked mutex"</span>)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) TryLock(timeout time.Duration) <span class="typename">bool</span> {</div><div class="line">	timer := time.NewTimer(timeout)</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> &lt;-m.ch:</div><div class="line">		timer.Stop()</div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	<span class="keyword">case</span> &lt;-time.After(timeout):</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) IsLocked() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(m.ch) ==<span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>你也可以把它用<code>Context</code>来改造，不是利用超时，而是利用<code>Context</code>来取消/超时获得锁的操作，这个作业留给读者来实现。</p>
<h2 id="Or_Channel_模式">Or Channel 模式</h2>
<p>当你等待多个信号的时候，如果收到任意一个信号， 就执行业务逻辑，忽略其它的还未收到的信号。</p>
<p>举个例子， 我们往提供相同服务的n个节点发送请求，只要任意一个服务节点返回结果，我们就可以执行下面的业务逻辑，其它n-1的节点的请求可以被取消或者忽略。当n=2的时候，这就是<code>back request</code>模式。 这样可以用资源来换取latency的提升。</p>
<p>需要注意的是，当收到任意一个信号的时候，<strong>其它信号都被忽略</strong>。如果用channel来实现，只要从任意一个channel中接收到一个数据，那么所有的channel都可以被关闭了(依照你的实现，但是输出的channel肯定会被关闭)。</p>
<p>有三种实现的方式: goroutine、reflect和递归。</p>
<h3 id="Goroutine方式">Goroutine方式</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> or(chans ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">var</span> once sync.Once</div><div class="line">		<span class="keyword">for</span> _, c := <span class="keyword">range</span> chans {</div><div class="line">			<span class="keyword">go</span> <span class="keyword">func</span>(c &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) {</div><div class="line">				<span class="keyword">select</span> {</div><div class="line">				<span class="keyword">case</span> &lt;-c:</div><div class="line">					once.Do(<span class="keyword">func</span>() { <span class="built_in">close</span>(out) })</div><div class="line">				<span class="keyword">case</span> &lt;-out:</div><div class="line">				}</div><div class="line">			}(c)</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> out</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>or</code>函数可以处理n个channel,它为每个channel启动一个goroutine，只要任意一个goroutine从channel读取到数据，输出的channel就被关闭掉了。</p>
<p>为了避免并发关闭输出channel的问题，关闭操作只执行一次。</p>
<h3 id="Reflect方式">Reflect方式</h3>
<p>Go的反射库针对select语句有专门的数据(<code>reflect.SelectCase</code>)和函数(<code>reflect.Select</code>)处理。<br>所以我们可以利用反射“随机”地从一组可选的channel中接收数据，并关闭输出channel。</p>
<p>这种方式看起来更简洁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> or(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	<span class="keyword">switch</span> <span class="built_in">len</span>(channels) {</div><div class="line">	<span class="keyword">case</span><span class="number"> 0</span>:</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">	<span class="keyword">case</span><span class="number"> 1</span>:</div><div class="line">		<span class="keyword">return</span> channels<span class="number">[0</span>]</div><div class="line">	}</div><div class="line"></div><div class="line">	orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</div><div class="line">		<span class="keyword">var</span> cases []reflect.SelectCase</div><div class="line">		<span class="keyword">for</span> _, c := <span class="keyword">range</span> channels {</div><div class="line">			cases = <span class="built_in">append</span>(cases, reflect.SelectCase{</div><div class="line">				Dir:  reflect.SelectRecv,</div><div class="line">				Chan: reflect.ValueOf(c),</div><div class="line">			})</div><div class="line">		}</div><div class="line"></div><div class="line">		reflect.Select(cases)</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> orDone</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="递归方式">递归方式</h3>
<p>递归方式一向是比较开脑洞的实现，下面的方式就是分而治之的方式，逐步合并channel，最终返回一个channel。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> or(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	<span class="keyword">switch</span> <span class="built_in">len</span>(channels) {</div><div class="line">	<span class="keyword">case</span><span class="number"> 0</span>:</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">	<span class="keyword">case</span><span class="number"> 1</span>:</div><div class="line">		<span class="keyword">return</span> channels<span class="number">[0</span>]</div><div class="line">	}</div><div class="line"></div><div class="line">	orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</div><div class="line"></div><div class="line">		<span class="keyword">switch</span> <span class="built_in">len</span>(channels) {</div><div class="line">		<span class="keyword">case</span><span class="number"> 2</span>:</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-channels<span class="number">[0</span>]:</div><div class="line">			<span class="keyword">case</span> &lt;-channels<span class="number">[1</span>]:</div><div class="line">			}</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			m := <span class="built_in">len</span>(channels) /<span class="number"> 2</span></div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-or(channels[:m]...):</div><div class="line">			<span class="keyword">case</span> &lt;-or(channels[m:]...):</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> orDone</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在后面的扇入(合并)模式中，我们还是会使用相同样的递归模式来合并多个输入channel，根据 justforfun 的测试结果，这种递归的方式要比goroutine、Reflect更有效。</p>
<h2 id="Or-Done-Channel模式">Or-Done-Channel模式</h2>
<p>这种模式是我们经常使用的一种模式，通过一个信号channel(done)来控制(取消)输入channel的处理。</p>
<p>一旦从done channel中读取到一个信号，或者done channel被关闭， 输入channel的处理则被取消。</p>
<p>这个模式提供一个简便的方法，把done channel 和 输入 channel 融合成一个输出channel。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> orDone(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, c &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	valStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(valStream)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> v, ok := &lt;-c:</div><div class="line">				<span class="keyword">if</span> ok == <span class="constant">false</span> {</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				<span class="keyword">select</span> {</div><div class="line">				<span class="keyword">case</span> valStream &lt;- v:</div><div class="line">				<span class="keyword">case</span> &lt;-done:</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> valStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="扇入模式">扇入模式</h2>
<p>扇入模式(FanIn)是将多个同样类型的输入channel合并成一个同样类型的输出channel，也就是channel的合并。</p>
<h3 id="Goroutine方式-1">Goroutine方式</h3>
<p>每个channel起一个goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fanIn(chans ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">		wg.Add(<span class="built_in">len</span>(chans))</div><div class="line"></div><div class="line">		<span class="keyword">for</span> _, c := <span class="keyword">range</span> chans {</div><div class="line">			<span class="keyword">go</span> <span class="keyword">func</span>(c &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) {</div><div class="line">				<span class="keyword">for</span> v := <span class="keyword">range</span> c {</div><div class="line">					out &lt;- v</div><div class="line">				}</div><div class="line">				wg.Done()</div><div class="line">			}(c)</div><div class="line">		}</div><div class="line"></div><div class="line">		wg.Wait()</div><div class="line">		<span class="built_in">close</span>(out)</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> out</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Reflect">Reflect</h3>
<p>利用反射库针对select语句的处理合并输入channel。</p>
<p>下面这种实现方式其实还是有些问题的， 在输入channel读取比较均匀的时候比较有效，否则性能比较低下。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">func fanInReflect(chans <span class="keyword">...</span>&lt;-chan interface{}) &lt;-chan interface{} {</div><div class="line">	out := make(chan interface{})</div><div class="line">	go func() {</div><div class="line">		defer close(out)</div><div class="line">		var cases []reflect.SelectCase</div><div class="line">		<span class="keyword">for</span> _, c := range chans {</div><div class="line">			cases = append(cases, reflect.SelectCase{</div><div class="line">				Dir:  reflect.SelectRecv,</div><div class="line">				Chan: reflect.ValueOf(c),</div><div class="line">			})</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">for</span> len(cases) &gt; <span class="number">0</span> {</div><div class="line">			i, v, ok := reflect.Select(cases)</div><div class="line">			<span class="keyword">if</span> !ok { //remove this case</div><div class="line">				cases = append(cases[:i], cases[i+<span class="number">1</span>:]<span class="keyword">...</span>)</div><div class="line">				continue</div><div class="line">			}</div><div class="line">			out &lt;- v.Interface()</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> out</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="递归方式-1">递归方式</h3>
<p>这种方式虽然理解起来不直观，但是性能还是不错的(输入channel不是很多的情况下递归层级不会很高，不会成为瓶颈)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fanInRec(chans ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	<span class="keyword">switch</span> <span class="built_in">len</span>(chans) {</div><div class="line">	<span class="keyword">case</span><span class="number"> 0</span>:</div><div class="line">		c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">		<span class="built_in">close</span>(c)</div><div class="line">		<span class="keyword">return</span> c</div><div class="line">	<span class="keyword">case</span><span class="number"> 1</span>:</div><div class="line">		<span class="keyword">return</span> chans<span class="number">[0</span>]</div><div class="line">	<span class="keyword">case</span><span class="number"> 2</span>:</div><div class="line">		<span class="keyword">return</span> mergeTwo(chans<span class="number">[0</span>], chans<span class="number">[1</span>])</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		m := <span class="built_in">len</span>(chans) /<span class="number"> 2</span></div><div class="line">		<span class="keyword">return</span> mergeTwo(</div><div class="line">			fanInRec(chans[:m]...),</div><div class="line">			fanInRec(chans[m:]...))</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> mergeTwo(a, b &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(c)</div><div class="line">		<span class="keyword">for</span> a != <span class="constant">nil</span> || b != <span class="constant">nil</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> v, ok := &lt;-a:</div><div class="line">				<span class="keyword">if</span> !ok {</div><div class="line">					a = <span class="constant">nil</span></div><div class="line">					<span class="keyword">continue</span></div><div class="line">				}</div><div class="line">				c &lt;- v</div><div class="line">			<span class="keyword">case</span> v, ok := &lt;-b:</div><div class="line">				<span class="keyword">if</span> !ok {</div><div class="line">					b = <span class="constant">nil</span></div><div class="line">					<span class="keyword">continue</span></div><div class="line">				}</div><div class="line">				c &lt;- v</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> c</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tee模式">Tee模式</h2>
<p>扇出模式(FanOut)是将一个输入channel扇出为多个channel。</p>
<p>扇出行为至少可以分为两种：</p>
<ol>
<li>从输入channel中读取一个数据，发送给每个输入channel，这种模式称之为Tee模式</li>
<li>从输入channel中读取一个数据，在输出channel中选择一个channel发送</li>
</ol>
<p>本节只介绍第一种情况，下一节介绍第二种情况</p>
<h3 id="Goroutine方式-2">Goroutine方式</h3>
<p>将读取的值发送给每个输出channel， 异步模式可能会产生很多的goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fanOut(ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, out []<span class="keyword">chan</span> <span class="keyword">interface</span>{}, async <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(out); i++ {</div><div class="line">				<span class="built_in">close</span>(out[i])</div><div class="line">			}</div><div class="line">		}()</div><div class="line"></div><div class="line">		<span class="keyword">for</span> v := <span class="keyword">range</span> ch {</div><div class="line">			v := v</div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(out); i++ {</div><div class="line">				i := i</div><div class="line">				<span class="keyword">if</span> async {</div><div class="line">					<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">						out[i] &lt;- v</div><div class="line">					}()</div><div class="line">				} <span class="keyword">else</span> {</div><div class="line">					out[i] &lt;- v</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Reflect方式-1">Reflect方式</h3>
<p>这种模式一旦一个输出channel被阻塞，可能会导致后续的处理延迟。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fanOutReflect(ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, out []<span class="keyword">chan</span> <span class="keyword">interface</span>{}) {</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(out); i++ {</div><div class="line">				<span class="built_in">close</span>(out[i])</div><div class="line">			}</div><div class="line">		}()</div><div class="line"></div><div class="line">		cases := <span class="built_in">make</span>([]reflect.SelectCase, <span class="built_in">len</span>(out))</div><div class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> cases {</div><div class="line">			cases[i].Dir = reflect.SelectSend</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">for</span> v := <span class="keyword">range</span> ch {</div><div class="line">			v := v</div><div class="line">			<span class="keyword">for</span> i := <span class="keyword">range</span> cases {</div><div class="line">				cases[i].Chan = reflect.ValueOf(out[i])</div><div class="line">				cases[i].Send = reflect.ValueOf(v)</div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="keyword">for</span> _ = <span class="keyword">range</span> cases { <span class="comment">// for each channel</span></div><div class="line">				chosen, _, _ := reflect.Select(cases)</div><div class="line">				cases[chosen].Chan = reflect.ValueOf(<span class="constant">nil</span>)</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="分布模式">分布模式</h2>
<p>分布模式将从输入channel中读取的值往输出channel中的其中一个发送。</p>
<h3 id="Goroutine方式-3">Goroutine方式</h3>
<p>roundrobin的方式选择输出channel。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fanOut(ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, out []<span class="keyword">chan</span> <span class="keyword">interface</span>{}) {</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(out); i++ {</div><div class="line">				<span class="built_in">close</span>(out[i])</div><div class="line">			}</div><div class="line">		}()</div><div class="line"></div><div class="line">		<span class="comment">// roundrobin</span></div><div class="line">		<span class="keyword">var</span> i =<span class="number"> 0</span></div><div class="line">		<span class="keyword">var</span> n = <span class="built_in">len</span>(out)</div><div class="line">		<span class="keyword">for</span> v := <span class="keyword">range</span> ch {</div><div class="line">			v := v</div><div class="line">			out[i] &lt;- v</div><div class="line">			i = (i +<span class="number"> 1</span>) % n</div><div class="line">		}</div><div class="line">	}()</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Reflect方式-2">Reflect方式</h3>
<p>利用发射随机的选择。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fanOutReflect(ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, out []<span class="keyword">chan</span> <span class="keyword">interface</span>{}) {</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(out); i++ {</div><div class="line">				<span class="built_in">close</span>(out[i])</div><div class="line">			}</div><div class="line">		}()</div><div class="line"></div><div class="line">		cases := <span class="built_in">make</span>([]reflect.SelectCase, <span class="built_in">len</span>(out))</div><div class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> cases {</div><div class="line">			cases[i].Dir = reflect.SelectSend</div><div class="line">			cases[i].Chan = reflect.ValueOf(out[i])</div><div class="line"></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">for</span> v := <span class="keyword">range</span> ch {</div><div class="line">			v := v</div><div class="line">			<span class="keyword">for</span> i := <span class="keyword">range</span> cases {</div><div class="line">				cases[i].Send = reflect.ValueOf(v)</div><div class="line">			}</div><div class="line">			_, _, _ = reflect.Select(cases)</div><div class="line">		}</div><div class="line">	}()</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="eapache">eapache</h2>
<p><a href="https://github.com/eapache/channels" target="_blank" rel="external">eapache/channels</a>提供了一些channel应用模式的方法，比如上面的扇入扇出模式等。</p>
<p>因为go本身的channel无法再进行扩展， <code>eapache/channels</code>库定义了自己的channel接口，并提供了与channel方便的转换。</p>
<p><code>eapache/channels</code> 提供了四个方法:</p>
<ul>
<li>Distribute： 从输入channel读取值，发送到其中一个输出channel中。当输入channel关闭后，输出channel都被关闭</li>
<li>Tee: 从输入channel读取值，发送到所有的输出channel中。当输入channel关闭后，输出channel都被关闭</li>
<li>Multiplex: 合并输入channel为一个输出channel， 当所有的输入都关闭后，输出才关闭</li>
<li>Pipe: 将两个channel串起来</li>
</ul>
<p>同时对上面的四个函数还提供了<code>WeakXXX</code>的函数，输入关闭后不会关闭输出。</p>
<p>下面看看对应的函数的例子。</p>
<h3 id="Distribute">Distribute</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> testDist() {</div><div class="line">	fmt.Println(<span class="string">"dist:"</span>)</div><div class="line">	a := channels.NewNativeChannel(channels.None)</div><div class="line">	outputs := []channels.Channel{</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">	}</div><div class="line"></div><div class="line">	channels.Distribute(a, outputs<span class="number">[0</span>], outputs<span class="number">[1</span>], outputs<span class="number">[2</span>], outputs<span class="number">[3</span>])</div><div class="line">	<span class="comment">//channels.WeakDistribute(a, outputs[0], outputs[1], outputs[2], outputs[3])</span></div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 5</span>; i++ {</div><div class="line">			a.In() &lt;- i</div><div class="line">		}</div><div class="line">		a.Close()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 6</span>; i++ {</div><div class="line">		<span class="keyword">var</span> v <span class="keyword">interface</span>{}</div><div class="line">		<span class="keyword">var</span> j <span class="typename">int</span></div><div class="line">		<span class="keyword">select</span> {</div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[0</span>].Out():</div><div class="line">			j =<span class="number"> 0</span></div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[1</span>].Out():</div><div class="line">			j =<span class="number"> 1</span></div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[2</span>].Out():</div><div class="line">			j =<span class="number"> 2</span></div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[3</span>].Out():</div><div class="line">			j =<span class="number"> 3</span></div><div class="line">		}</div><div class="line">		fmt.Printf(<span class="string">"channel#%d: %d\n"</span>, j, v)</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Tee">Tee</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> testTee() {</div><div class="line">	fmt.Println(<span class="string">"tee:"</span>)</div><div class="line">	a := channels.NewNativeChannel(channels.None)</div><div class="line">	outputs := []channels.Channel{</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">	}</div><div class="line"></div><div class="line">	channels.Tee(a, outputs<span class="number">[0</span>], outputs<span class="number">[1</span>], outputs<span class="number">[2</span>], outputs<span class="number">[3</span>])</div><div class="line">	<span class="comment">//channels.WeakTee(a, outputs[0], outputs[1], outputs[2], outputs[3])</span></div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 5</span>; i++ {</div><div class="line">			a.In() &lt;- i</div><div class="line">		}</div><div class="line">		a.Close()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 20</span>; i++ {</div><div class="line">		<span class="keyword">var</span> v <span class="keyword">interface</span>{}</div><div class="line">		<span class="keyword">var</span> j <span class="typename">int</span></div><div class="line">		<span class="keyword">select</span> {</div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[0</span>].Out():</div><div class="line">			j =<span class="number"> 0</span></div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[1</span>].Out():</div><div class="line">			j =<span class="number"> 1</span></div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[2</span>].Out():</div><div class="line">			j =<span class="number"> 2</span></div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[3</span>].Out():</div><div class="line">			j =<span class="number"> 3</span></div><div class="line">		}</div><div class="line">		fmt.Printf(<span class="string">"channel#%d: %d\n"</span>, j, v)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Multiplex">Multiplex</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> testMulti() {</div><div class="line">	fmt.Println(<span class="string">"multi:"</span>)</div><div class="line">	a := channels.NewNativeChannel(channels.None)</div><div class="line">	inputs := []channels.Channel{</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">	}</div><div class="line"></div><div class="line">	channels.Multiplex(a, inputs<span class="number">[0</span>], inputs<span class="number">[1</span>], inputs<span class="number">[2</span>], inputs<span class="number">[3</span>])</div><div class="line">	<span class="comment">//channels.WeakMultiplex(a, inputs[0], inputs[1], inputs[2], inputs[3])</span></div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 5</span>; i++ {</div><div class="line">			<span class="keyword">for</span> j := <span class="keyword">range</span> inputs {</div><div class="line">				inputs[j].In() &lt;- i</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> inputs {</div><div class="line">			inputs[i].Close()</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> a.Out() {</div><div class="line">		fmt.Printf(<span class="string">"%d "</span>, v)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Pipe">Pipe</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> testPipe() {</div><div class="line">	fmt.Println(<span class="string">"pipe:"</span>)</div><div class="line">	a := channels.NewNativeChannel(channels.None)</div><div class="line">	b := channels.NewNativeChannel(channels.None)</div><div class="line"></div><div class="line">	channels.Pipe(a, b)</div><div class="line">	<span class="comment">// channels.WeakPipe(a, b)</span></div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 5</span>; i++ {</div><div class="line">			a.In() &lt;- i</div><div class="line">		}</div><div class="line">		a.Close()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> b.Out() {</div><div class="line">		fmt.Printf(<span class="string">"%d "</span>, v)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="集合操作">集合操作</h2>
<p>从channel的行为来看，它看起来很像一个数据流，所以我们可以实现一些类似Scala 集合的操作。</p>
<p>Scala的集合类提供了丰富的操作(方法)， 当然其它的一些编程语言或者框架也提供了类似的方法， 比如Apache Spark、Java Stream、ReactiveX等。</p>
<p>下面列出了一些方法的实现，我相信经过一些人的挖掘，相关的方法可以变成一个很好的类库，但是目前我们先看一些例子。</p>
<h3 id="skip">skip</h3>
<p>skip函数是从一个channel中跳过开一些数据，然后才开始读取。</p>
<h4 id="skipN">skipN</h4>
<p>skipN跳过开始的N个数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> skipN(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, num <span class="typename">int</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; num; i++ {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> &lt;-valueStream:</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> takeStream &lt;- &lt;-valueStream:</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> takeStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="skipFn">skipFn</h4>
<p>skipFn 提供Fn函数为true的数据，比如跳过偶数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> skipFn(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, fn <span class="keyword">func</span>(<span class="keyword">interface</span>{}) <span class="typename">bool</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> v := &lt;-valueStream:</div><div class="line">				<span class="keyword">if</span> !fn(v) {</div><div class="line">					takeStream &lt;- v</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> takeStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="skipWhile">skipWhile</h4>
<p>跳过开头函数fn为true的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> skipWhile(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, fn <span class="keyword">func</span>(<span class="keyword">interface</span>{}) <span class="typename">bool</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</div><div class="line">		take := <span class="constant">false</span></div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> v := &lt;-valueStream:</div><div class="line">				<span class="keyword">if</span> !take {</div><div class="line">					take = !fn(v)</div><div class="line">					<span class="keyword">if</span> !take {</div><div class="line">						<span class="keyword">continue</span></div><div class="line">					}</div><div class="line">				}</div><div class="line">				takeStream &lt;- v</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> takeStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="take">take</h3>
<p>skip的反向操作，读取一部分数据。</p>
<h4 id="takeN">takeN</h4>
<p>takeN 读取开头N个数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> takeN(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, num <span class="typename">int</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; num; i++ {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> takeStream &lt;- &lt;-valueStream:</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> takeStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="takeFn">takeFn</h4>
<p>takeFn 只筛选满足fn的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> takeFn(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, fn <span class="keyword">func</span>(<span class="keyword">interface</span>{}) <span class="typename">bool</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> v := &lt;-valueStream:</div><div class="line">				<span class="keyword">if</span> fn(v) {</div><div class="line">					takeStream &lt;- v</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> takeStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="takeWhile">takeWhile</h4>
<p>takeWhile只挑选开头满足fn的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> takeWhile(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, fn <span class="keyword">func</span>(<span class="keyword">interface</span>{}) <span class="typename">bool</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> v := &lt;-valueStream:</div><div class="line">				<span class="keyword">if</span> !fn(v) {</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				takeStream &lt;- v</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> takeStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="flat">flat</h3>
<p>平展(flat)操作是一个有趣的操作。</p>
<p>如果输入是一个channel,channel中的数据还是相同类型的channel， 那么flat将返回一个输出channel,输出channel中的数据是输入的各个channel中的数据。</p>
<p>它与扇入不同，扇入的输入channel在调用的时候就是固定的，并且以数组的方式提供，而flat的输入是一个channel，可以运行时随时的加入channel。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> orDone(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, c &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	valStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(valStream)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> v, ok := &lt;-c:</div><div class="line">				<span class="keyword">if</span> ok == <span class="constant">false</span> {</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				<span class="keyword">select</span> {</div><div class="line">				<span class="keyword">case</span> valStream &lt;- v:</div><div class="line">				<span class="keyword">case</span> &lt;-done:</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> valStream</div><div class="line">}</div><div class="line"><span class="keyword">func</span> flat(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, chanStream &lt;-<span class="keyword">chan</span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	valStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(valStream)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">var</span> stream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> maybeStream, ok := &lt;-chanStream:</div><div class="line">				<span class="keyword">if</span> ok == <span class="constant">false</span> {</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				stream = maybeStream</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			}</div><div class="line">			<span class="keyword">for</span> val := <span class="keyword">range</span> orDone(done, stream) {</div><div class="line">				<span class="keyword">select</span> {</div><div class="line">				<span class="keyword">case</span> valStream &lt;- val:</div><div class="line">				<span class="keyword">case</span> &lt;-done:</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> valStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="map">map</h3>
<p>map和reduce是一组常用的操作。</p>
<p>map将一个channel映射成另外一个channel， channel的类型可以不同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> mapChan(in &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, fn <span class="keyword">func</span>(<span class="keyword">interface</span>{}) <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">if</span> in == <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">close</span>(out)</div><div class="line">		<span class="keyword">return</span> out</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(out)</div><div class="line"></div><div class="line">		<span class="keyword">for</span> v := <span class="keyword">range</span> in {</div><div class="line">			out &lt;- fn(v)</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> out</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为<code>map</code>是go的关键字，所以我们不能命名函数类型为<code>map</code>,这里用<code>mapChan</code>代替。</p>
<p>比如你可以处理一个公司员工工资的channel， 输出一个扣税之后的员工工资的channel。</p>
<h3 id="reduce">reduce</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> reduce(in &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, fn <span class="keyword">func</span>(r, v <span class="keyword">interface</span>{}) <span class="keyword">interface</span>{}) <span class="keyword">interface</span>{} {</div><div class="line">	<span class="keyword">if</span> in == <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">	}</div><div class="line"></div><div class="line">	out := &lt;-in</div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> in {</div><div class="line">		out = fn(out, v)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> out</div><div class="line">}</div><div class="line"></div><div class="line">你可以用<span class="string">`reduce`</span>实现<span class="string">`sum`</span>、<span class="string">`max`</span>、<span class="string">`min`</span>等聚合操作。</div></pre></td></tr></table></figure>

<h2 id="总结">总结</h2>
<p>本文列出了channel的一些深入应用的模式，相信通过阅读本文，你可以更加深入的了解Go的channel类型，并在开发中灵活的应用channel。也欢迎你在评论中提出更多的 channel的应用模式。</p>
<p>所有的代码可以在github上找到: <a href="https://github.com/smallnest/channels" target="_blank" rel="external">smallnest/channels</a>。</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://github.com/kat-co/concurrency-in-go-src" target="_blank" rel="external">https://github.com/kat-co/concurrency-in-go-src</a></li>
<li><a href="https://github.com/campoy/justforfunc/tree/master/27-merging-chans" target="_blank" rel="external">https://github.com/campoy/justforfunc/tree/master/27-merging-chans</a></li>
<li><a href="https://github.com/eapache/channels" target="_blank" rel="external">https://github.com/eapache/channels</a></li>
<li><a href="https://github.com/LK4D4/trylock" target="_blank" rel="external">https://github.com/LK4D4/trylock</a></li>
<li><a href="https://stackoverflow.com/questions/36391421/explain-dont-communicate-by-sharing-memory-share-memory-by-communicating" target="_blank" rel="external">https://stackoverflow.com/questions/36391421/explain-dont-communicate-by-sharing-memory-share-memory-by-communicating</a></li>
<li><a href="https://github.com/lrita/gosync" target="_blank" rel="external">https://github.com/lrita/gosync</a></li>
<li><a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html" target="_blank" rel="external">https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html</a> </li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Channel是Go中的一种类型，和goroutine一起为Go提供了并发技术， 它在开发中得到了广泛的应用。Go鼓励人们通过Channel在goroutine之间传递数据的引用(就像把数据的owner从一个goroutine传递给另外一个goroutine), <a href="http://golang.org/doc/effective_go.html" target="_blank" rel="external">Effective Go</a>总结了这么一句话：</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<p>在 <a href="https://golang.org/ref/mem" target="_blank" rel="external">Go内存模型</a>指出了channel作为并发控制的一个特性：</p>
<blockquote>
<p>A send on a channel happens before the corresponding receive from that channel completes. (Golang Spec)</p>
</blockquote>
<p>除了正常的在goroutine之间安全地传递共享数据， Channel还可以玩出很多的花样(模式)， 本文列举了一些channel的应用模式。</p>
<p>促成本文诞生的因素主要包括：</p>
<ol>
<li>eapache的channels库</li>
<li>concurrency in go 这本书</li>
<li>Francesc Campoy的 justforfun系列中关于merge channel的实现</li>
<li>我在出版Scala集合手册这本书中对Scala集合的启发</li>
</ol>
<p>下面就让我们以实例的方式看看这么模式吧。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
</feed>
