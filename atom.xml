<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://colobu.com/"/>
  <updated>2018-08-31T09:46:53.201Z</updated>
  <id>https://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[C和Go相互调用]]></title>
    <link href="https://colobu.com/2018/08/28/c-and-go-calling-interaction/"/>
    <id>https://colobu.com/2018/08/28/c-and-go-calling-interaction/</id>
    <published>2018-08-28T11:45:46.000Z</published>
    <updated>2018-08-30T03:37:31.115Z</updated>
    <content type="html"><![CDATA[<p>C可以调用Go，并且Go可以调用C， 如果更进一步呢， <code>C--&gt;Go--&gt;C</code> 或者 <code>Go--&gt;C--&gt;Go</code>的调用如何实现？</p>
<p>本文通过两个简单的例子帮助你了解这两种复杂的调用关系。本文不涉及两者之间的复杂的数据转换，官方文章<a href="https://blog.golang.org/c-go-cgo" target="_blank" rel="external">C? Go? Cgo!</a>、<a href="https://github.com/golang/go/wiki/cgo" target="_blank" rel="external">wiki/cgo</a>和<a href="http://golang.org/cmd/cgo" target="_blank" rel="external">cmd/cgo</a>有一些介绍。</p>
<a id="more"></a>
<h2 id="Go-&gt;C-&gt;Go">Go--&gt;C--&gt;Go</h2>
<p>Go程序调用C实现的函数，然后C实现的函数又调用Go实现的函数。</p>
<p>1、首先，我们新建一个<code>hello.go</code>的文件：</p>
<figure class="highlight go"><figcaption><span>hello.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="comment">//export HelloFromGo</span></div><div class="line"><span class="keyword">func</span> HelloFromGo() {</div><div class="line">	fmt.Printf(<span class="string">"Hello from Go!\n"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>它定义了一个<code>HelloFromGo</code>函数，注意这个函数是一个纯的Go函数，我们定义它的输出符号为<code>HelloFromGo</code>。</p>
<p>2、接着我们新建一个<code>hello.c</code>的文件：</p>
<figure class="highlight c"><figcaption><span>hello.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "_cgo_export.h"</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> helloFromC() {</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hi from C\n"</span>);</div><div class="line">    <span class="comment">//call Go function</span></div><div class="line">    HelloFromGo();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个c文件定义了一个C函数<code>helloFromC</code>,内部它会调用我们刚才定义的<code>HelloFromGo</code>函数。</p>
<p>这样，我们实现了<code>C</code>调用<code>Go</code>: <code>C--&gt;Go</code>,下面我们再实现Go调用C。</p>
<p>3、最后新建一个<code>main.go</code>文件：</p>
<figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">extern int helloFromC();</div><div class="line">*/</div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">//call c function</span></div><div class="line">	C.helloFromC()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>它调用第二步实现的C函数<code>helloFromC</code>。</p>
<p>运行测试一下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ go run .</div><div class="line">Hi from C</div><div class="line">Hello from Go!</div></pre></td></tr></table></figure>

<p>可以看到，期望的函数调用正常的运行。第一行是C函数的输出，第二行是Go函数的输出。</p>
<h2 id="C-&gt;Go-&gt;C">C--&gt;Go--&gt;C</h2>
<p>第二个例子演示了C程序调用Go实现的函数，然后Go实现的函数又调用C实现的函数。</p>
<p>1、首先新建一个<code>hello.c</code>文件：</p>
<figure class="highlight c"><figcaption><span>hello.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> helloFromC() {</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hi from C\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>它定义了一个纯C实现的函数。</p>
<p>2、接着新建一个<code>hello.go</code>文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// go build -o hello.so -buildmode=c-shared .</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">extern int helloFromC();</div><div class="line">*/</div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="comment">//export HelloFromGo</span></div><div class="line"><span class="keyword">func</span> HelloFromGo() {</div><div class="line">	fmt.Printf(<span class="string">"Hello from Go!\n"</span>)</div><div class="line">	C.helloFromC()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>它实现了一个Go函数<code>HelloFromGo</code>,内部实现调用了C实现的函数<code>helloFromC</code>,这样我们就实现了<code>Go--&gt;C</code>。</p>
<p>注意包名设置为<code>package main</code>，并且增加一个空的<code>main</code>函数。</p>
<p>运行<code>go build -o hello.so -buildmode=c-shared .</code>生成一个C可以调用的库，这调命令执行完后会生成<code>hello.so</code>文件和<code>hello.h</code>文件。</p>
<p>3、最后新建一个文件夹，随便起个名字，比如<code>main</code></p>
<p>将刚才生成的<code>hello.so</code>文件和<code>hello.h</code>文件复制到<code>main</code>文件夹，并在<code>main</code>文件夹中新建一个文件<code>main.c</code>:</p>
<figure class="highlight c"><figcaption><span>main.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "hello.h"</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"use hello lib from C:\n"</span>);</div><div class="line">   </div><div class="line">    HelloFromGo();</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行<code>gcc -o main main.c hello.so</code>生成可执行文件<code>main</code>, 运行<code>main</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ./main</div><div class="line">use hello lib from C:</div><div class="line">Hello from Go!</div><div class="line">Hi from C</div></pre></td></tr></table></figure>

<p>第一行输出来自<code>main.c</code>,第二行来自Go函数，第三行来自<code>hello.c</code>中的C函数，这样我们就实现了<code>C--&gt;Go--C</code>的复杂调用。</p>
<h3 id="C-&gt;Go-&gt;C的状态变量"><code>C--&gt;Go--&gt;C</code>的状态变量</h3>
<p>我们来分析第二步中的一个特殊的场景， 为了下面我们好区分，我们给程序标记一下， 记为<code>C1--&gt;Go--&gt;C2</code>, C2的程序修改一下，加入一个状态变量<code>a</code>,并且函数<code>helloFromC</code>中会打印<code>a</code>的地址和值，也会将<code>a</code>加一。</p>
<figure class="highlight c"><figcaption><span>hello.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span>  a = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> helloFromC() {</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hi from C: %p, %d\n"</span>, &a, a++);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后修改<code>main.c</code>程序,让它既通过Go嗲用<code>C1.helloFromC</code>,又直接调用<code>C1.helloFromC</code>,看看多次调用的时候<code>a</code>的指针是否一致，并且<code>a</code>的值是否有变化。</p>
<figure class="highlight c"><figcaption><span>main.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "hello.h"</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"use hello lib from C:\n"</span>);</div><div class="line">   </div><div class="line">    <span class="comment">// 1. 直接调用C函数</span></div><div class="line">    helloFromC();</div><div class="line"></div><div class="line">    <span class="comment">// 2. 调用Go函数</span></div><div class="line">    HelloFromGo();</div><div class="line">    </div><div class="line">    <span class="comment">// 3. 直接调用C函数</span></div><div class="line">    helloFromC();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>激动人心的时候到了。我们不同的编译方式会产生不同的结果。</p>
<p>1、<code>gcc -o main main.c hello.so</code></p>
<p>和第二步相同的编译方式，编译出<code>main</code>并执行， 因为<code>hello.so</code>中包含<code>C1.helloFromC</code>实现，所以可以正常执行。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">./main</div><div class="line">use hello lib from C:</div><div class="line">Hi from C: <span class="number">0</span>x10092a370, <span class="number">1</span></div><div class="line">Hello from Go!</div><div class="line">Hi from C: <span class="number">0</span>x10092a370, <span class="number">2</span></div><div class="line">Hi from C: <span class="number">0</span>x10092a370, <span class="number">3</span></div></pre></td></tr></table></figure>

<p>可以看到<code>a</code>的指针是同一个值，无论通过Go函数改变还是通过C函数改变都是更改的同一个变量。</p>
<p>nm可以查看生成的<code>main</code>的符号：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">nm main</div><div class="line">                 U _HelloFromGo</div><div class="line"><span class="number">0000000100000000</span> T __mh_execute_header</div><div class="line">                 U _helloFromC</div><div class="line"><span class="number">0000000100000</span>f10 T _main</div><div class="line">                 U _<span class="built_in">printf</span></div><div class="line">                 U dyld_stub_binder</div></pre></td></tr></table></figure>

<p><code>U</code>代表这个符号是未定义的符号，通过动态库链接进来。</p>
<p>2、 <code>gcc -o main main.c hello.so ../hello.c</code></p>
<p>我们编译的时候直接链接<code>hello.c</code>的实现，然后运行<code>main</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">./main</div><div class="line">use hello lib from C:</div><div class="line">Hi from C: <span class="number">0</span>x104888020, <span class="number">1</span></div><div class="line">Hello from Go!</div><div class="line">Hi from C: <span class="number">0</span>x1049f7370, <span class="number">1</span></div><div class="line">Hi from C: <span class="number">0</span>x104888020, <span class="number">2</span></div></pre></td></tr></table></figure>

<p>可以看到<code>a</code>是不同的两个变量。</p>
<p>nm可以查看生成的<code>main</code>的符号：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">nm main</div><div class="line">                 U _HelloFromGo</div><div class="line"><span class="number">0000000100000000</span> T __mh_execute_header</div><div class="line"><span class="number">0000000100001020</span> D _a</div><div class="line"><span class="number">0000000100000</span>f10 T _helloFromC</div><div class="line"><span class="number">0000000100000</span>ec0 T _main</div><div class="line">                 U _<span class="built_in">printf</span></div><div class="line">                 U dyld_stub_binder</div></pre></td></tr></table></figure>

<p>可以看到<code>_a</code>是初始化的环境变量，<code>_helloFromC</code>的类型是<code>T</code>而不是<code>U</code>,代表它是一个全局的Text符号,这和上一步是不一样的。</p>
<h3 id="参考文档">参考文档</h3>
<ol>
<li><a href="https://medium.com/using-go-in-mobile-apps/using-go-in-mobile-apps-part-1-calling-go-functions-from-c-be1ecf7dfbc6" target="_blank" rel="external">https://medium.com/using-go-in-mobile-apps/using-go-in-mobile-apps-part-1-calling-go-functions-from-c-be1ecf7dfbc6</a></li>
<li><a href="https://github.com/vladimirvivien/go-cshared-examples" target="_blank" rel="external">https://github.com/vladimirvivien/go-cshared-examples</a></li>
<li><a href="http://golang.org/cmd/cgo" target="_blank" rel="external">http://golang.org/cmd/cgo</a></li>
<li><a href="https://gist.github.com/zchee/b9c99695463d8902cd33" target="_blank" rel="external">https://gist.github.com/zchee/b9c99695463d8902cd33</a></li>
<li><a href="https://medium.com/@liamkelly17/working-with-packed-c-structs-in-cgo-224a0a3b708b" target="_blank" rel="external">https://medium.com/@liamkelly17/working-with-packed-c-structs-in-cgo-224a0a3b708b</a></li>
<li><a href="https://groups.google.com/forum/#!topic/golang-nuts/EhndTzcPJxQ" target="_blank" rel="external">https://groups.google.com/forum/#!topic/golang-nuts/EhndTzcPJxQ</a></li>
<li><a href="https://docs.google.com/document/d/1nr-TQHw_er6GOQRsF6T43GGhFDelrAP0NqSS_00RgZQ/edit#" target="_blank" rel="external">https://docs.google.com/document/d/1nr-TQHw_er6GOQRsF6T43GGhFDelrAP0NqSS_00RgZQ/edit#</a></li>
<li><a href="https://www.mkssoftware.com/docs/man1/nm.1.asp" target="_blank" rel="external">https://www.mkssoftware.com/docs/man1/nm.1.asp</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>C可以调用Go，并且Go可以调用C， 如果更进一步呢， <code>C--&gt;Go--&gt;C</code> 或者 <code>Go--&gt;C--&gt;Go</code>的调用如何实现？</p>
<p>本文通过两个简单的例子帮助你了解这两种复杂的调用关系。本文不涉及两者之间的复杂的数据转换，官方文章<a href="https://blog.golang.org/c-go-cgo" target="_blank" rel="external">C? Go? Cgo!</a>、<a href="https://github.com/golang/go/wiki/cgo" target="_blank" rel="external">wiki/cgo</a>和<a href="http://golang.org/cmd/cgo" target="_blank" rel="external">cmd/cgo</a>有一些介绍。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[翻译]15个最常用的GCC编译器参数]]></title>
    <link href="https://colobu.com/2018/08/28/15-Most-Frequently-Used-GCC-Compiler-Command-Line-Options/"/>
    <id>https://colobu.com/2018/08/28/15-Most-Frequently-Used-GCC-Compiler-Command-Line-Options/</id>
    <published>2018-08-28T08:50:24.000Z</published>
    <updated>2018-08-28T10:35:39.734Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://www.thegeekstuff.com/2012/10/gcc-compiler-options/" target="_blank" rel="external">15 Most Frequently Used GCC Compiler Command Line Options</a> 以及评论中大家提供的一些参数。</p>
<p>GCC编译器是一个日常流行的 C 编译器， 很多Linux的发布版本中都带有这个编译器。这篇文章列举了一些最常用的编译参数。</p>
<p>本文中使用下面的C语言实现的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">   <span class="built_in">printf</span>(<span class="string">"\n The Geek Stuff\n"</span>);</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="指定编译输出的名字">指定编译输出的名字</h3>
<p>gcc编译器最常用的使用格式是:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc main.c</div></pre></td></tr></table></figure>

<p>上面的命令执行完整的编译过程，并且生成一个<code>a.out</code>文件。</p>
<p>使用参数<code>-o</code>, 可以指定输出的文件名。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc main.c -o main</div></pre></td></tr></table></figure>

<p>上面的命令会产生输出文件<code>main</code>。</p>
<p>为了理解GCC编译器的完整的编译过程，可以阅读 <a href="https://www.thegeekstuff.com/2011/10/c-program-to-an-executable/" target="_blank" rel="external">Journey of a C Program to Linux Executable in 4 Stages</a>。</p>
<h3 id="通过-Wall参数启用所有警告">通过<code>-Wall</code>参数启用所有警告</h3>
<p>这个参数可以启用所有警告。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">   <span class="keyword">int</span> i;</div><div class="line">   <span class="built_in">printf</span>(<span class="string">"\n The Geek Stuff [%d]\n"</span>, i);</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码编译时，会出现<code>未初始化的i</code>类似的警告。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ gcc -Wall main.c -o main</div><div class="line">main.c: <span class="keyword">In</span> <span class="function"><span class="keyword">function</span> ‘<span class="title">main</span>’:</span></div><div class="line">main.c:<span class="number">6</span>:<span class="number">10</span>: warning: ‘i’ <span class="keyword">is</span> used uninitialized <span class="keyword">in</span> this <span class="function"><span class="keyword">function</span> [-<span class="title">Wuninitialized</span>]</span></div></pre></td></tr></table></figure>

<h3 id="使用-E参数只产生预处理输出">使用<code>-E</code>参数只产生预处理输出</h3>
<p><code>-E</code>参数是产生预处理阶段的输出。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gcc -E main.c &gt; main.i</div></pre></td></tr></table></figure>

<p>gcc命令将结果输出在<code>stdout</code>中，所以你可以把它重定向到任意的文件中，在上面的例子中，重定向到<code>main.i</code>文件中。</p>
<h3 id="使用-S参数只产生汇编代码">使用<code>-S</code>参数只产生汇编代码</h3>
<p><code>-S</code> 参数产生汇编级别的代码。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -S main.c &gt; main.s</div></pre></td></tr></table></figure>

<p>文件<code>main.s</code>包含汇编代码。</p>
<h3 id="使用-C参数只产生编译的代码">使用<code>-C</code>参数只产生编译的代码</h3>
<p><code>-C</code>参数只产生编译的代码(没有链接link)。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -C main.c</div></pre></td></tr></table></figure>

<p>上面的代码产生<code>main.o</code>, 包含机器级别的代码或者编译的代码。</p>
<h3 id="使用-save-temps参数产生所有的中间步骤的文件">使用<code>-save-temps</code>参数产生所有的中间步骤的文件</h3>
<p><code>-save-temps</code>可以做4,5,6步骤的工作。通过这个参数，所有中间阶段的文件都会存储在当前文件夹中，注意它也会产生可执行文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ gcc -save-temps main.c</div><div class="line"></div><div class="line">$ ls</div><div class="line">a.out  main.c  main.i  main.o  main.s</div></pre></td></tr></table></figure>

<p>从例子中我们可以看到各个中间文件以及可执行文件。</p>
<h3 id="使用-l参数链接共享库">使用<code>-l</code>参数链接共享库</h3>
<p><code>-l</code>可以用作链接共享库，例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc  -Wall main.c -o main <span class="operator">-l</span>CPPfile</div></pre></td></tr></table></figure>

<p>上面的代码会链接<code>libCPPfile.so</code>，产生可执行文件<code>main</code>。</p>
<h3 id="使用-fPIC产生位置无关的代码">使用<code>-fPIC</code>产生位置无关的代码</h3>
<p>当产生共享库的时候，应该创建位置无关的代码，这会让共享库使用任意的地址而不是固定的地址，要实现这个功能，需要使用<code>-fPIC</code>参数。</p>
<p>下面的例子产生<code>libCfile.so</code>动态库。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>gcc -c -<span class="constant">Wall</span> -<span class="constant">Werror</span> -fPIC <span class="constant">Cfile</span>.c</div><div class="line"><span class="variable">$ </span>gcc -shared -o libCfile.so <span class="constant">Cfile</span>.o</div></pre></td></tr></table></figure>

<p>产生共享库的时候使用了<code>-fPIC</code>参数。</p>
<p>注意<code>-shared</code>产生共享库。</p>
<h3 id="使用-V打印所有的执行命令">使用<code>-V</code>打印所有的执行命令</h3>
<p>参数<code>-V</code>提供详细的信息，打印出gcc编译一个文件的时候所有的步骤。</p>
<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ gcc -Wall -v main.c -o main</div><div class="line">Using built-in specs.</div><div class="line">COLLECT_GCC=gcc</div><div class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/i686-linux-gnu/<span class="number">4.6</span>/lto-wrapper</div><div class="line">Target: i686-linux-gnu</div><div class="line">Configured with: ../src/configure -v --with-pkgversion=<span class="string">'Ubuntu/Linaro 4.6.3-1ubuntu5'</span> --with-bugurl=file:///usr/share/doc/gcc-<span class="number">4.6</span>/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-<span class="number">4.6</span> --enable-shared --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/<span class="number">4.6</span> --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --enable-plugin --enable-objc-gc --enable-targets=all --disable-werror --with-arch-<span class="number">32</span>=i686 --with-tune=generic --enable-checking=release --build=i686-linux-gnu --host=i686-linux-gnu --target=i686-linux-gnu</div><div class="line">Thread model: posix</div><div class="line">gcc version <span class="number">4.6</span>.<span class="number">3</span> (Ubuntu/Linaro <span class="number">4.6</span>.<span class="number">3</span>-<span class="number">1</span>ubuntu5)</div><div class="line">...</div><div class="line">...</div><div class="line">...</div></pre></td></tr></table></figure>

<p>这样我们可以看到所有的细节。</p>
<h3 id="使用-ansi参数支持_ISO_C89程序">使用<code>-ansi</code>参数支持 ISO C89程序</h3>
<p>使用<code>-ansi</code>参数可以支持 ISO C89风格。</p>
<p>比如下面的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">  <span class="comment">// Print the string</span></div><div class="line">   <span class="built_in">printf</span>(<span class="string">"\n The Geek Stuff\n"</span>);</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用<code>-ansi</code>参数编译上面的代码会出错，因为ISO C89不支持C++风格的注释。</p>
<p>下面是输出结果:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">main.c</span>: <span class="string">In function ‘main’:</span></div><div class="line"><span class="attribute">main.c:5:3</span>: <span class="string">error: expected expression before ‘/’ token</span></div></pre></td></tr></table></figure>

<p>我们可以看待上面编译的时候抛出一个注释错误。</p>
<h3 id="使用-funsigned-char将char解释为符号的char">使用<code>-funsigned-char</code>将char解释为符号的char</h3>
<p>通过这个参数， char类型被看作为 unsigned char类型。</p>
<p>例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">  <span class="keyword">char</span> c = -<span class="number">10</span>;</div><div class="line">  <span class="comment">// Print the string</span></div><div class="line">   <span class="built_in">printf</span>(<span class="string">"\n The Geek Stuff [%d]\n"</span>, c);</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码通过这个参数编译后，输出结果为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ gcc -Wall -funsigned-char main.c -o main</div><div class="line">$ ./main</div><div class="line"></div><div class="line"> The Geek Stuff [<span class="number">246</span>]</div></pre></td></tr></table></figure>

<p>可以看到char是无符号的字节。</p>
<h3 id="使用-fsigned-char将char解释为有符号的char">使用<code>-fsigned-char</code>将char解释为有符号的char</h3>
<p>和上面的功能相反， 使用这个参数， char类型被看作是有符号的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>gcc -<span class="constant">Wall</span> -fsigned-char main.c -o main</div><div class="line"><span class="variable">$ </span>./main</div><div class="line"></div><div class="line"> <span class="constant">The</span> <span class="constant">Geek</span> <span class="constant">Stuff</span> [-<span class="number">10</span>]</div></pre></td></tr></table></figure>

<p>结果输出为负数。</p>
<h3 id="使用-D参数可以使用编译时的宏">使用<code>-D</code>参数可以使用编译时的宏</h3>
<p>参数<code>D</code>可以用作定义编译时的宏。</p>
<p>例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line"><span class="preprocessor">#ifdef MY_MACRO</span></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\n Macro defined \n"</span>);</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">  <span class="keyword">char</span> c = -<span class="number">10</span>;</div><div class="line">  <span class="comment">// Print the string</span></div><div class="line">   <span class="built_in">printf</span>(<span class="string">"\n The Geek Stuff [%d]\n"</span>, c);</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>-D</code>可以用作从命令行定义宏<code>MY_MACRO</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ gcc -Wall -DMY_MACRO main.c -o main</div><div class="line">$ ./main</div><div class="line"></div><div class="line"> Macro defined </div><div class="line"></div><div class="line"> The Geek Stuff [-<span class="number">10</span>]</div></pre></td></tr></table></figure>

<p>可以看到宏被定义了，并打印出了结果。<br>tput confirms that the macro was defined.</p>
<h3 id="使用-Werror将警告升级为错误">使用<code>-Werror</code>将警告升级为错误</h3>
<p>通过这个参数，gcc会将所有的警告转换成错误信息。<br>例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">  <span class="keyword">char</span> c;</div><div class="line">  <span class="comment">// Print the string</span></div><div class="line">   <span class="built_in">printf</span>(<span class="string">"\n The Geek Stuff [%d]\n"</span>, c);</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码编译的时候会有一个<code>undefined variable c</code>警告， <code>-Werror</code>会把这个警告升级成错误。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ gcc -Wall -Werror main.c -o main</div><div class="line">main.c: <span class="keyword">In</span> <span class="function"><span class="keyword">function</span> ‘<span class="title">main</span>’:</span></div><div class="line">main.c:<span class="number">7</span>:<span class="number">10</span>: error: ‘c’ <span class="keyword">is</span> used uninitialized <span class="keyword">in</span> this <span class="function"><span class="keyword">function</span> [-<span class="title">Werror</span>=<span class="title">uninitialized</span>]</span></div><div class="line"><span class="title">cc1</span>: all warnings being treated <span class="keyword">as</span> errors</div></pre></td></tr></table></figure>

<h3 id="使用@参数从文件中读取参数">使用<code>@</code>参数从文件中读取参数</h3>
<p>gcc参数可以从文件中读取，通过<code>@</code>后跟文件名的方式提供， 多个参数可以使用空格区隔。</p>
<p>例子:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cat opt_file </div><div class="line">-Wall -omain</div></pre></td></tr></table></figure>

<p><code>opt_file</code>包含编译参数。</p>
<p>使用<code>@</code>参数：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ gcc main.c @opt_file</div><div class="line">main.c: In function ‘main’:</div><div class="line">main.c:<span class="number">6</span>:<span class="number">11</span>: warning: ‘i’ is used uninitialized <span class="keyword">in</span> this function [-Wuninitialized]</div><div class="line"></div><div class="line">$ ls main</div><div class="line">main</div></pre></td></tr></table></figure>

<p>输出结果表明参数的确从文件中读取了，并且正确的应用到编译过程中。</p>
<blockquote>
<p>以下是附加的一些编译参数</p>
</blockquote>
<h3 id="使用参数-I指定头文件的文件夹">使用参数<code>-I</code>指定头文件的文件夹</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -I/home/codeman/include input-file.c</div></pre></td></tr></table></figure>

<p><code>-I-</code>取消前一个参数功能，一般用在<code>-Idir</code>之后。</p>
<h3 id="使用参数-std指定支持的c++/c的标准">使用参数<code>-std</code>指定支持的c++/c的标准</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -std=c++<span class="number">11</span> hello-world.cpp</div></pre></td></tr></table></figure>

<p>标准如 <code>c++11, c++14, c90, c89</code>等。</p>
<h3 id="使用-static生成静态链接的文件">使用<code>-static</code>生成静态链接的文件</h3>
<p>静态编译文件(把动态库的函数和其它依赖都编译进最终文件)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc main.c -static -o main -lpthread</div></pre></td></tr></table></figure>

<p>相反的使用<code>-shared</code>使用动态库链接。</p>
<h3 id="使用-static-libstdc++静态链接libstdc++">使用<code>-static-libstdc++</code>静态链接libstdc++</h3>
<p>如果没有使用<code>-static</code>,默认使用libstdc++共享库，而<code>-static-libstdc++</code>可以指定使用libstdc++静态库。</p>
<h3 id="使用-M生成文件关联的信息">使用<code>-M</code>生成文件关联的信息</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">gcc -M main.c</div><div class="line">main.o: main.c /usr/include/stdc-predef.h /usr/include/stdio.h \</div><div class="line"> /usr/include/features.h /usr/include/sys/cdefs.h \</div><div class="line"> /usr/include/bits/wordsize.h /usr/include/gnu/stubs.h \</div><div class="line"> /usr/include/gnu/stubs-<span class="number">64</span>.h \</div><div class="line"> /usr/lib/gcc/x86_64-redhat-linux/<span class="number">4.8</span>.<span class="number">5</span>/include/stddef.h \</div><div class="line"> /usr/include/bits/types.h /usr/include/bits/typesizes.h \</div><div class="line"> /usr/include/libio.h /usr/include/_G_config.h /usr/include/wchar.h \</div><div class="line"> /usr/lib/gcc/x86_64-redhat-linux/<span class="number">4.8</span>.<span class="number">5</span>/include/stdarg.h \</div><div class="line"> /usr/include/bits/stdio_lim.h /usr/include/bits/sys_errlist.h</div></pre></td></tr></table></figure>

<h3 id="全部参数介绍">全部参数介绍</h3>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html" target="_blank" rel="external">https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://www.thegeekstuff.com/2012/10/gcc-compiler-options/" target="_blank" rel="external">15 Most Frequently Used GCC Compiler Command Line Options</a> 以及评论中大家提供的一些参数。</p>
<p>GCC编译器是一个日常流行的 C 编译器， 很多Linux的发布版本中都带有这个编译器。这篇文章列举了一些最常用的编译参数。</p>
<p>本文中使用下面的C语言实现的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">   <span class="built_in">printf</span>(<span class="string">"\n The Geek Stuff\n"</span>);</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="C++" scheme="https://colobu.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[跳出Go module的泥潭]]></title>
    <link href="https://colobu.com/2018/08/27/learn-go-module/"/>
    <id>https://colobu.com/2018/08/27/learn-go-module/</id>
    <published>2018-08-27T11:11:34.000Z</published>
    <updated>2018-08-31T09:46:06.896Z</updated>
    <content type="html"><![CDATA[<p>Go 1.11 前天已经正式发布了，这个版本包含了两个最重要的feature就是 <code>module</code>和<code>web assembly</code>。虽然也有一些简单的教程介绍了<code>go module</code>的特性，但是基本上都是<code>hello world</code>的例子，在实践的过程中， 很多人都在“拼命的挣扎”，包括我自己， 从一些qq群、github的issue, twitter上都可以看到大家茫然或者抱怨的语句。</p>
<p>虽然有三个帮助文件<code>go help mod</code>、<code>go help modules</code>、<code>go help module-get</code>可以了解一些go module的用法，但是感觉Go开发组对<code>module</code>这一特性还是没有很好的做一个全面的介绍，很多情况还得靠大家看源代码或者去猜，比如module下载的文件夹、版本格式的完整声明，<code>module</code>的最佳实践等，并且当前Go 1.11的实现中还有一些bug,给大家在使用的过程中带来了很大的困难。</p>
<p>我也在摸索中前行， 记录了摸索过程中的一些总结，希望能给还在挣扎中的Gopher一些帮助。</p>
<p><a href="https://roberto.selbach.ca/intro-to-go-modules/" target="_blank" rel="external">Introduction to Go Modules</a> 是一篇很好的go module 入门介绍， 如果你仔细阅读了它，应该就不需要看本文了。</p>
<a id="more"></a>
<h3 id="GO111MODULE">GO111MODULE</h3>
<p>要使用<code>go module</code>,首先要设置<code>GO111MODULE=on</code>,这没什么可说的，如果没设置，执行命令的时候会有提示，这个大家应该都了解了。</p>
<h3 id="既有项目">既有项目</h3>
<p>假设你已经有了一个go 项目， 比如在<code>$GOPATH/github.com/smallnest/rpcx</code>下， 你可以使用<code>go mod init github.com/smallnest/rpcx</code>在这个文件夹下创建一个空的<code>go.mod</code> (只有第一行 <code>module github.com/smallnest/rpcx</code>)。</p>
<p>然后你可以通过 <code>go get -m ./...</code>让它查找依赖，并记录在<code>go.mod</code>文件中(你还可以指定 <code>-tags</code>,这样可以把tags的依赖都查找到)。</p>
<p>通过<code>go mod tidy</code>也可以用来为<code>go.mod</code>增加丢失的依赖，删除不需要的依赖，但是我不确定它怎么处理<code>tags</code>。</p>
<p>执行上面的命令会把<code>go.mod</code>的<code>latest</code>版本换成实际的最新的版本，并且会生成一个<code>go.sum</code>记录每个依赖库的版本和哈希值。</p>
<h3 id="新的项目">新的项目</h3>
<p>你可以在<code>GOPATH</code>之外创建新的项目。</p>
<p><code>go mod init packagename</code>可以创建一个空的<code>go.mod</code>,然后你可以在其中增加<code>require github.com/smallnest/rpcx latest</code>依赖，或者像上面一样让go自动发现和维护。</p>
<p><code>go mod download</code>可以下载所需要的依赖，但是依赖并不是下载到<code>$GOPATH</code>中，而是<code>$GOPATH/pkg/mod</code>中，多个项目可以共享缓存的module。</p>
<h3 id="go_mod命令">go mod命令</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">download    download modules to local cache (下载依赖的module到本地cache))</div><div class="line">edit        edit go.mod from tools or scripts (编辑go.mod文件)</div><div class="line">graph       print module requirement graph (打印模块依赖图))</div><div class="line">init        initialize new module <span class="keyword">in</span> current directory (再当前文件夹下初始化一个新的module, 创建go.mod文件))</div><div class="line">tidy        add missing and remove unused modules (增加丢失的module，去掉未用的module)</div><div class="line">vendor      make vendored copy of dependencies (将依赖复制到vendor下)</div><div class="line">verify      verify dependencies have expected content (校验依赖)</div><div class="line">why         explain why packages or modules are needed (解释为什么需要依赖)</div></pre></td></tr></table></figure>

<p>有些命令还有bug, 比如<code>go mod download -dir</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">go mod download -dir /tmp</div><div class="line">flag provided but not defined: -dir</div><div class="line">usage: go mod download [-dir] [-json] [modules]</div><div class="line">Run <span class="string">'go help mod download'</span> <span class="keyword">for</span> details.</div></pre></td></tr></table></figure>

<p>帮助里明明说可以设置<code>dir</code>,但是实际却不支持<code>dir</code>参数。</p>
<p>看这些命令的帮助已经比较容易了解命令的功能。</p>
<h3 id="翻墙">翻墙</h3>
<p>在国内访问<code>golang.org/x</code>的各个包都需要翻墙，你可以在<code>go.mod</code>中使用<code>replace</code>替换成github上对应的库。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">replace (</div><div class="line">	golang.org<span class="regexp">/x/</span>crypto v0.<span class="number">0.0</span>-<span class="number">20180820150726</span>-<span class="number">614</span>d502a4dac =&gt; github.com<span class="regexp">/golang/</span>crypto v0.<span class="number">0.0</span>-<span class="number">20180820150726</span>-<span class="number">614</span>d502a4dac</div><div class="line">	golang.org<span class="regexp">/x/</span>net v0.<span class="number">0.0</span>-<span class="number">20180821023952</span>-<span class="number">922</span>f4815f713 =&gt; github.com<span class="regexp">/golang/</span>net v0.<span class="number">0.0</span>-<span class="number">20180826012351</span>-<span class="number">8</span>a410e7b638d</div><div class="line">	golang.org<span class="regexp">/x/</span>text v0.<span class="number">3.0</span> =&gt; github.com<span class="regexp">/golang/</span>text v0.<span class="number">3.0</span></div><div class="line">)</div></pre></td></tr></table></figure>

<p>依赖库中的<code>replace</code>对你的主<code>go.mod</code>不起作用，比如<code>github.com/smallnest/rpcx</code>的<code>go.mod</code>已经增加了<code>replace</code>,但是你的<code>go.mod</code>虽然<code>require</code>了<code>rpcx</code>的库，但是没有设置<code>replace</code>的话， <code>go get</code>还是会访问<code>golang.org/x</code>。</p>
<p>所以如果想编译那个项目，就在哪个项目中增加<code>replace</code>。</p>
<h3 id="版本格式">版本格式</h3>
<p>下面的版本都是合法的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gopkg.<span class="keyword">in</span>/tomb.v1 v1<span class="number">.0</span><span class="number">.0</span>-<span class="number">20141024135613</span>-dd632973f1e7</div><div class="line">gopkg.<span class="keyword">in</span>/vmihailenco/msgpack.v2 v2<span class="number">.9</span><span class="number">.1</span></div><div class="line">gopkg.<span class="keyword">in</span>/yaml.v2 &lt;=v2<span class="number">.2</span><span class="number">.1</span></div><div class="line">github.com/tatsushid/go-fastping v0<span class="number">.0</span><span class="number">.0</span>-<span class="number">20160109021039</span>-d7bb493dee3e</div><div class="line">latest</div></pre></td></tr></table></figure>

<h3 id="go_get_升级">go get 升级</h3>
<ul>
<li>运行 <code>go get -u</code> 将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)</li>
<li>运行 <code>go get -u=patch</code> 将会升级到最新的修订版本</li>
<li>运行 <code>go get package@version</code> 将会升级到指定的版本号<code>version</code></li>
</ul>
<h3 id="go_mod_vendor">go mod vendor</h3>
<p><code>go mod vendor</code> 会将modules下载到vendor中</p>
<h3 id="go_module,_vendor_和_Travis_CI">go module, vendor 和 Travis CI</h3>
<p><a href="https://arslan.io/2018/08/26/using-go-modules-with-vendor-support-on-travis-ci/" target="_blank" rel="external">https://arslan.io/2018/08/26/using-go-modules-with-vendor-support-on-travis-ci/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go 1.11 前天已经正式发布了，这个版本包含了两个最重要的feature就是 <code>module</code>和<code>web assembly</code>。虽然也有一些简单的教程介绍了<code>go module</code>的特性，但是基本上都是<code>hello world</code>的例子，在实践的过程中， 很多人都在“拼命的挣扎”，包括我自己， 从一些qq群、github的issue, twitter上都可以看到大家茫然或者抱怨的语句。</p>
<p>虽然有三个帮助文件<code>go help mod</code>、<code>go help modules</code>、<code>go help module-get</code>可以了解一些go module的用法，但是感觉Go开发组对<code>module</code>这一特性还是没有很好的做一个全面的介绍，很多情况还得靠大家看源代码或者去猜，比如module下载的文件夹、版本格式的完整声明，<code>module</code>的最佳实践等，并且当前Go 1.11的实现中还有一些bug,给大家在使用的过程中带来了很大的困难。</p>
<p>我也在摸索中前行， 记录了摸索过程中的一些总结，希望能给还在挣扎中的Gopher一些帮助。</p>
<p><a href="https://roberto.selbach.ca/intro-to-go-modules/" target="_blank" rel="external">Introduction to Go Modules</a> 是一篇很好的go module 入门介绍， 如果你仔细阅读了它，应该就不需要看本文了。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[局部敏感哈希介绍]]></title>
    <link href="https://colobu.com/2018/08/16/locality-sensitive-hashing/"/>
    <id>https://colobu.com/2018/08/16/locality-sensitive-hashing/</id>
    <published>2018-08-16T09:19:25.000Z</published>
    <updated>2018-08-16T11:56:14.950Z</updated>
    <content type="html"><![CDATA[<p>传统的Hash当源数据有些许的变化的时候生成的哈希值差异也非常的大， 比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	s1 := []<span class="typename">byte</span>(<span class="string">"你好世界"</span>)</div><div class="line">	s2 := []<span class="typename">byte</span>(<span class="string">"你好,世界"</span>)</div><div class="line"></div><div class="line">	hash1 := md5.Sum(s1)</div><div class="line">	hash2 := md5.Sum(s2)</div><div class="line"></div><div class="line">	fmt.Println(hex.EncodeToString(hash1[:]))</div><div class="line">	fmt.Println(hex.EncodeToString(hash2[:]))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>s1的哈希值是<code>65396ee4aad0b4f17aacd1c6112ee364</code>、s2的哈希值是<code>27444ee2d245c3e8e11ed8b9b035c43b</code>,源数据仅仅是一个逗号的区别，但是哈希值完全不一样。这是我们使用Hash的常见的场景，输出的哈希值经常被称为消息摘要（message digest）或摘要（digest）。</p>
<p>局部敏感哈希(Locality-sensitive hashing， 简称LSH)则不同， LSH则希望相似的源数据计算出来的哈希值越相近越好。<br>LSH经常用在判重、文章摘要、聚类、相似搜索、近邻查找等场景， 用来减少高维度的数据的维度，相近的数据放在同一个桶中。 比如<a href="https://cloud.tencent.com/developer/article/1035600" target="_blank" rel="external">大规模异常滥用检测：基于局部敏感哈希算法——来自Uber Engineering的实践</a></p>
<a id="more"></a>
<p>学术定义<a href="https://en.wikipedia.org/wiki/Locality-sensitive_hashing" target="_blank" rel="external">Locality sensitive hashing</a>总是不那么容易让人理解，本文也不试图从学术的角度去介绍LSH, 而是介绍一个特定的LSH算法：simhash。</p>
<p>通用的LSH会基于某个点与点之间的某种<code>距离</code>判定相似性，相近的点距离接近，也就是说，我们可以通过计算距离来比较对象的相似性。距离之间的测量可以分为两大类：</p>
<ul>
<li>欧几里得距离(Euclidean): 基于空间中的点计算距离<ul>
<li>普通的欧几里得距离</li>
<li>曼哈顿距离(Manhattan distance)</li>
<li>闵可夫斯基距离(Minkowski Distance)</li>
</ul>
</li>
<li>非欧几里得距离: 不是根据空间中的位置，而是根据点的属性计算距离<ul>
<li>杰卡德距离(Jaccard distance): 1-杰卡德相似系数</li>
<li>余弦距离(Cosine distance)</li>
<li>编辑距离(Edit distance)</li>
<li>汉明距离(Hamming Distance)</li>
</ul>
</li>
</ul>
<p>当然还有一些距离的计算公式， 比如切比雪夫距离(Chebyshev Distance)、马氏距离(Mahalanobis distance)、Pearson距离等。<br>这些计算距离的方法会应用在不同的场景中，有时候也会使用不同的距离计算方法进行比较。</p>
<p>不同的LSH会使用不同距离计算方法：</p>
<ul>
<li><a href="http://www.cs.princeton.edu/courses/archive/spring04/cos598B/bib/CharikarEstim.pdf" target="_blank" rel="external">HyperplaneLSH</a> 使用余弦距离</li>
<li><a href="https://papers.nips.cc/paper/4847-super-bit-locality-sensitive-hashing.pdf" target="_blank" rel="external">Super-Bit Locality-Sensitive Hashing</a> 使用汉明距离</li>
<li><a href="https://en.wikipedia.org/wiki/MinHash" target="_blank" rel="external">Min Hash</a> 使用杰卡德相似系数</li>
<li><a href="http://www.cs.princeton.edu/courses/archive/spr04/cos598B/bib/BroderCFM-minwise.pdf" target="_blank" rel="external">Min-wise independent permutations</a></li>
<li><a href="https://pdfs.semanticscholar.org/7a5f/dc6e9250428a636be20643191eaf9faa1434.pdf" target="_blank" rel="external">Nilsimsa Hash</a></li>
<li><a href="http://www.ime.unicamp.br/~wanderson/Artigos/randon_projection_kdd.pdf" target="_blank" rel="external">Random projection</a></li>
</ul>
<p>simhash是Google的爬虫用来文档去重。 simhash最牛逼的一点就是将一个文档，最后转换成一个64位的字节，然后判断重复只需要判断他们的特征字的距离是不是小于n（根据经验这个n一般取值为3），就可以判断两个文档是否相似。这大大简化了文档相似性的比较。</p>
<p>Simhash由<a href="https://en.wikipedia.org/wiki/Moses_Charikar" target="_blank" rel="external">Moses Charikar</a>, google 2006年做了minhash和simhash的大规模数据的比较，2007年Google说使用simhash用作<a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/33026.pdf" target="_blank" rel="external">爬虫去重</a>，使用minhash做<a href="https://doi.org/10.1145/1242572.1242610" target="_blank" rel="external">新闻个性化</a>。</p>
<p><img src="simhash.jpg" alt=""></p>
<p>simhash的计算也很简单，</p>
<ol>
<li>首先抽取文档的关键字， 比如前10个关键字，以及它们的权重(feature, weight), 记录为[(feature1, weight1), (feature1,weight2), ..., (featuren,weightn)]</li>
<li>计算feature的hash值，记为[(hash(feature1), weight1), (hash(feature1),weight2), ..., (hash(featuren),weightn)], 如图，假设hash值的bit数为6位，图中第一个feature1的hash值为100110, 权重位weight1。</li>
<li>然后对这些值按位进行累加，如果这个位是1,则该位上加上他的权重weight,如果是0，则减去weight，最后生成一个6个数字，每个位上一个数字，例如上图中位[13, 108, -22, -5, -32, 55]</li>
<li>将数值转换成0,1即可 [13, 108, -22, -5, -32, 55] -&gt; 110001, 正值为1,负值为0即可</li>
</ol>
<p>这样，就可以将一个文档映射成一个数字了，上图中使用6bit,你可以选择合适的大小，比如64比特，可以转化成一个uint64整数。</p>
<p>下一步就是根据simhash值计算两个文档的相似度，使用汉明距离计算，可以方便的使用xor操作。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="literal">A</span> = <span class="number">100111</span><span class="comment">;</span></div><div class="line">B = <span class="number">101010</span><span class="comment">;</span></div><div class="line">hamming_distance(<span class="literal">A</span>, B) = count_1(<span class="literal">A</span> xor B) = count_1(<span class="number">001101</span>) = <span class="number">3</span><span class="comment">;</span></div></pre></td></tr></table></figure>

<p>这个例子中<code>A</code>和<code>B</code>的汉明距离为3。</p>
<p>go标准库中已经有快速计算一个整数的二进制形式中包含1个数的函数：<a href="https://golang.org/pkg/math/bits/#OnesCount64" target="_blank" rel="external">bits.OnesCount64</a>， 使用 &lt;&lt;Hacker&#39;s Delight&gt;&gt;中介绍的算法。</p>
<p>Go有几个simhash的实现， 比如<a href="https://github.com/mfonda/simhash" target="_blank" rel="external">mfonda/simhash</a>、<a href="https://github.com/AllenDang/simhash" target="_blank" rel="external">AllenDang/simhash</a>、<a href="https://github.com/fnargesian/simhash-lsh" target="_blank" rel="external">simhash-lsh</a>、<a href="https://github.com/safeie/simhash" target="_blank" rel="external">safeie/simhash</a>, 但是对于中文来说，还需要一个中文分词和抽取关键字的功能，这些库对中文不友好，中文文档的比较可以使用<a href="https://github.com/yanyiwu/gosimhash" target="_blank" rel="external">yanyiwu/gosimhash</a>以及修改版<a href="https://github.com/HaoyuHu/gosimhash" target="_blank" rel="external">HaoyuHu/gosimhash</a>。</p>
<p>不过我最后计算相似性使用的是<a href="https://github.com/rfguri/bowsi" target="_blank" rel="external">bowsim</a> + <a href="github.com/yanyiwu/gojieba">jieba</a>。</p>
<p>## </p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Locality-sensitive_hashing" target="_blank" rel="external">https://en.wikipedia.org/wiki/Locality-sensitive_hashing</a></li>
<li><a href="http://web.mit.edu/andoni/www/LSH/" target="_blank" rel="external">http://web.mit.edu/andoni/www/LSH/</a></li>
<li><a href="https://medium.com/engineering-brainly/locality-sensitive-hashing-explained-304eb39291e4" target="_blank" rel="external">https://medium.com/engineering-brainly/locality-sensitive-hashing-explained-304eb39291e4</a></li>
<li><a href="https://towardsdatascience.com/understanding-locality-sensitive-hashing-49f6d1f6134" target="_blank" rel="external">https://towardsdatascience.com/understanding-locality-sensitive-hashing-49f6d1f6134</a></li>
<li><a href="http://jacoxu.com/locality-sensitive-hashing归总/" target="_blank" rel="external">http://jacoxu.com/locality-sensitive-hashing归总/</a></li>
<li><a href="http://infolab.stanford.edu/~ullman/mining/2009/similarity3.pdf" target="_blank" rel="external">http://infolab.stanford.edu/~ullman/mining/2009/similarity3.pdf</a></li>
<li><a href="https://janzhou.org/lsh/" target="_blank" rel="external">https://janzhou.org/lsh/</a></li>
<li><a href="http://www.cs.princeton.edu/courses/archive/spring04/cos598B/bib/CharikarEstim.pdf" target="_blank" rel="external">http://www.cs.princeton.edu/courses/archive/spring04/cos598B/bib/CharikarEstim.pdf</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1082465" target="_blank" rel="external">https://cloud.tencent.com/developer/article/1082465</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>传统的Hash当源数据有些许的变化的时候生成的哈希值差异也非常的大， 比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	s1 := []<span class="typename">byte</span>(<span class="string">"你好世界"</span>)</div><div class="line">	s2 := []<span class="typename">byte</span>(<span class="string">"你好,世界"</span>)</div><div class="line"></div><div class="line">	hash1 := md5.Sum(s1)</div><div class="line">	hash2 := md5.Sum(s2)</div><div class="line"></div><div class="line">	fmt.Println(hex.EncodeToString(hash1[:]))</div><div class="line">	fmt.Println(hex.EncodeToString(hash2[:]))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>s1的哈希值是<code>65396ee4aad0b4f17aacd1c6112ee364</code>、s2的哈希值是<code>27444ee2d245c3e8e11ed8b9b035c43b</code>,源数据仅仅是一个逗号的区别，但是哈希值完全不一样。这是我们使用Hash的常见的场景，输出的哈希值经常被称为消息摘要（message digest）或摘要（digest）。</p>
<p>局部敏感哈希(Locality-sensitive hashing， 简称LSH)则不同， LSH则希望相似的源数据计算出来的哈希值越相近越好。<br>LSH经常用在判重、文章摘要、聚类、相似搜索、近邻查找等场景， 用来减少高维度的数据的维度，相近的数据放在同一个桶中。 比如<a href="https://cloud.tencent.com/developer/article/1035600" target="_blank" rel="external">大规模异常滥用检测：基于局部敏感哈希算法——来自Uber Engineering的实践</a></p>
]]>
    
    </summary>
    
      <category term="算法" scheme="https://colobu.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创建最小的Go docker 镜像]]></title>
    <link href="https://colobu.com/2018/08/13/create-minimal-docker-image-for-go-applications/"/>
    <id>https://colobu.com/2018/08/13/create-minimal-docker-image-for-go-applications/</id>
    <published>2018-08-13T10:30:10.000Z</published>
    <updated>2018-08-14T02:57:56.051Z</updated>
    <content type="html"><![CDATA[<p>虽然曾有一些文章介绍了如何创建一个最小的Go Docker镜像，我也曾写过一篇<a href="http://colobu.com/2015/10/12/create-minimal-golang-docker-images/" target="_blank" rel="external">文章</a>，但是随着Go的新的版本的发布， 以及docker本身的进化，有些技巧已经发生了变化， 本文介绍了最新的创建超小的Go镜像的方法。</p>
<a id="more"></a>
<h2 id="一个简单Go程序的镜像">一个简单Go程序的镜像</h2>
<p>首先让我们创建一个很简单的Go程序:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	fmt.Println(<span class="string">"hello world"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行下面的命令会创建一个超小的镜像, 这是我们的<strong>第一种</strong>方式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GOOS=linux CGO_ENABLED<span class="number">=0</span> <span class="keyword">go</span> build -ldflags=<span class="string">"-s -w"</span> -o app app.<span class="keyword">go</span> && tar c app | docker <span class="keyword">import</span> - app:latest</div></pre></td></tr></table></figure>

<blockquote>
<p>下一节介绍其中的编译参数</p>
</blockquote>
<p>查看镜像, 生成的镜像只有 <code>1.21MB</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># docker images app</span></div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">app                 latest              b716e13758<span class="built_in">cd</span>        <span class="number">11</span> seconds ago      <span class="number">1.21</span>MB</div></pre></td></tr></table></figure>

<p>这命令将编译、打包、输入镜像集成到一条命令了。</p>
<p><strong>第二种</strong>方式是使用一个Dockerfile文件:</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> scratch</div><div class="line">ADD app /</div><div class="line">CMD [<span class="string">"/app"</span>]</div></pre></td></tr></table></figure>

<p>运行下面的命令创建一个镜像：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t app2 .</div></pre></td></tr></table></figure>

<p>查看生成的镜像， 也是 <code>1.21MB</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># docker images app2</span></div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">app2                latest              <span class="number">4</span>e2af2ffb695        <span class="number">4</span> seconds ago       <span class="number">1.21</span>MB</div></pre></td></tr></table></figure>

<p><strong>第三种</strong>方式是利用Docker的 multistage 功能，在镜像中编译，Dockerfile文件：</p>
<figure class="highlight docker"><figcaption><span>Dockerfile.multistage</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t app3 <span class="operator">-f</span> Dockerfile.multistage .</div></pre></td></tr></table></figure>

<p>查看生成的镜像， 也是``:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># docker images app3</span></div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">app3                latest              <span class="number">9177859</span>dad64        <span class="number">16</span> seconds ago      <span class="number">1.21</span>MB</div></pre></td></tr></table></figure>

<p>你可以结合你的情况选择一种生成镜像的方式。</p>
<h2 id="编译Go程序">编译Go程序</h2>
<p>上面的例子中我们使用下面的命令编译Go程序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GOOS=linux CGO_ENABLED=<span class="number">0</span> go build -ldflags=<span class="string">"-s -w"</span> -o app app.go</div></pre></td></tr></table></figure>

<p>你可能在其它一些文章中还看到<code>installsuffix</code>参数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">GOOS=</span>linux <span class="variable">CGO_ENABLED=</span><span class="number">0</span> go build <span class="variable">-ldflags=</span><span class="string">"-s -w"</span>  -installsuffix cgo -o app app.go</div></pre></td></tr></table></figure>

<p>自Go 1.10以后，你不必再使用<code>installsuffix</code>参数(或许更早的版本)，Go的核心开发人员Ian Lance Taylor已经<a href="https://plus.google.com/117192131596509381660/posts/eNnNePihYnK" target="_blank" rel="external">确认</a>了这一点。</p>
<p>你可能有人还使用<code>-a</code>参数，它强制重新编译相关的包,一般你不会使用它。</p>
<p><code>-s</code> 忽略符号表和调试信息，<code>-w</code>忽略DWARF符号表，通过这两个参数，可以进一步减少编译的程序的尺寸，更多的参数可以参考<a href="https://golang.org/cmd/link/" target="_blank" rel="external">go link</a>, 或者 <code>go tool link -help</code>(另一个有用的命令是<code>go tool compile -help</code>)。</p>
<p>你也可以使用<code>strip</code>工具对编译的Go程序进行裁剪。</p>
<p>本身Go是静态编译的， 对于CGO, 如果设置<code>CGO_ENABLED=0</code>,则完全静态编译，不会再依赖动态库。</p>
<p>如果设置<code>CGO_ENABLED=0</code>,并且你的代码中使用了标准库的<code>net</code>包的话，有可能编译好的镜像无法运行，报<code>sh: /app: not found</code>的错误，尽管<code>/app</code>这个文件实际存在，并且如果讲基础镜像换为<code>centos</code>或者<code>ubuntu</code>的话就能执行。这是一个奇怪的错误，原因在于：</p>
<p><strong> 默认情况下<code>net</code>包会使用静态链接库， 比如libc</strong></p>
<p>知道了原因，解决办法也很简单，就是完全静态链接或者在基础镜像中加入libc库。</p>
<p>下面是几种解决办法：</p>
<ul>
<li>设置 <code>CGO_ENABLED=0</code></li>
<li>编译是使用纯go的net: <code>go build -tags netgo -a -v</code></li>
<li>使用基础镜像加glibc(或等价库musl、uclibc)， 比如 <a href="https://hub.docker.com/_/busybox/" target="_blank" rel="external">busybox:glibc</a>、alpine + <code>RUN apk add --no-cache libc6-compat</code>、<a href="https://hub.docker.com/r/frolvlad/alpine-glibc/" target="_blank" rel="external">frolvlad/alpine-glibc</a></li>
</ul>
<p>有的同学说了，我代码中确实必须使用CGO,因为需要依赖一些C/C++的库。目前没有对应的Go库可替代， 那么可以使用<code>-extldflags &quot;-static&quot;</code>,<code>go tool link help</code>介绍了<code>extldflags</code>的功能：</p>
<blockquote>
<p>-extldflags flags<br>   Set space-separated flags to pass to the external linker.</p>
<p>   -static means do not link against shared libraries</p>
</blockquote>
<h2 id="基础镜像">基础镜像</h2>
<p>其实前面已经列出了一些常用的基础镜像：</p>
<ul>
<li>scratch: 空的基础镜像，最小的基础镜像</li>
<li>busybox: 带一些常用的工具，方便调试， 以及它的一些扩展busybox:glibc</li>
<li>alpine: 另一个常用的基础镜像，带包管理功能，方便下载其它依赖的包</li>
</ul>
<p>显然。 你应该只在编译阶段使用<a href="https://hub.docker.com/_/golang/" target="_blank" rel="external">Go的镜像</a>，这样才能将你的镜像减小到最小。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然曾有一些文章介绍了如何创建一个最小的Go Docker镜像，我也曾写过一篇<a href="http://colobu.com/2015/10/12/create-minimal-golang-docker-images/" target="_blank" rel="external">文章</a>，但是随着Go的新的版本的发布， 以及docker本身的进化，有些技巧已经发生了变化， 本文介绍了最新的创建超小的Go镜像的方法。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Go HttpServer 最佳实践]]></title>
    <link href="https://colobu.com/2018/07/25/exposing-go-on-the-internet/"/>
    <id>https://colobu.com/2018/07/25/exposing-go-on-the-internet/</id>
    <published>2018-07-25T11:09:15.000Z</published>
    <updated>2018-07-31T08:27:34.556Z</updated>
    <content type="html"><![CDATA[<p>这是 Cloudflare 的 Filippo Valsorda 2016年发表在Gopher Academy的一篇<a href="https://blog.gopheracademy.com/advent-2016/exposing-go-on-the-internet/" target="_blank" rel="external">文章</a>， 虽然过去两年了，但是依然很有意义。</p>
<p>先前 <code>crypto/tls</code> 太慢而<code>net/http</code>也很年轻， 所以对于Go web server来说， 通常我们明智的做法把它放在反向代理的后面， 如nginx等，现在不需要了。</p>
<p>在Cloudflare我们最近试验了直接暴漏纯Go的服务作为主机。 Go 1.8的<code>net/http</code> 和 <code>crypto/tls</code> 提供了稳定的、高性能并且灵活的功能。</p>
<p>然后，需要做一些调优的工作，本文我们将展示怎么去调优和使web服务器更稳定。</p>
<a id="more"></a>
<p><img src="banner.jpg" alt=""></p>
<h2 id="crypto/tls">crypto/tls</h2>
<p>2016年了，你不会再运行一个不加密的HTTP Server，所以你需要<code>crypto/tls</code>。好消息使这个库已经非常<a href="https://blog.cloudflare.com/go-crypto-bridging-the-performance-gap/" target="_blank" rel="external">快</a>了(我们的<a href="https://blog.gopheracademy.com/advent-2016/tls-termination-bench/" target="_blank" rel="external">测试</a>)，目前他的安全攻击追踪也很优秀。</p>
<p>缺省配置是使用Mozilla<a href="https://wiki.mozilla.org/Security/Server_Side_TLS" target="_blank" rel="external">参考</a>中的中级推荐配置,但是　你仍然应该设置<code>PreferServerCipherSuites</code>以确保采用更快更安全的密码库, <code>CurvePreferences</code>避免未优化的曲线。 客户端如果使用<code>CurveP384</code>算法回导致我们的机器多达1秒的cpu消耗。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&tls.Config{</div><div class="line">	<span class="comment">// Causes servers to use Go's default ciphersuite preferences,</span></div><div class="line">	<span class="comment">// which are tuned to avoid attacks. Does nothing on clients.</span></div><div class="line">	PreferServerCipherSuites: <span class="constant">true</span>,</div><div class="line">	<span class="comment">// Only use curves which have assembly implementations</span></div><div class="line">	CurvePreferences: []tls.CurveID{</div><div class="line">		tls.CurveP256,</div><div class="line">		tls.X25519, <span class="comment">// Go 1.8 only</span></div><div class="line">	},</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你想配置兼容性， 你可以设置<code>MinVersion</code>和<code>CipherSuites</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">MinVersion: tls.VersionTLS12,</div><div class="line">CipherSuites: []<span class="typename">uint16</span>{</div><div class="line">	tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,</div><div class="line">	tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,</div><div class="line">	tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305, <span class="comment">// Go 1.8 only</span></div><div class="line">	tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,   <span class="comment">// Go 1.8 only</span></div><div class="line">	tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,</div><div class="line">	tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,</div><div class="line"></div><div class="line">	<span class="comment">// Best disabled, as they don't provide Forward Secrecy,</span></div><div class="line">	<span class="comment">// but might be necessary for some clients</span></div><div class="line">	<span class="comment">// tls.TLS_RSA_WITH_AES_256_GCM_SHA384,</span></div><div class="line">	<span class="comment">// tls.TLS_RSA_WITH_AES_128_GCM_SHA256,</span></div><div class="line">   },</div></pre></td></tr></table></figure>

<p>注意Go的CBC加密套件的实现（上面我们禁用了）很容易收到 <a href="https://www.imperialviolet.org/2013/02/04/luckythirteen.html" target="_blank" rel="external">Lucky13攻击</a>， 即使Go 1.8实现了部分的<a href="https://github.com/golang/go/commit/f28cf8346c4ce7cb74bf97c7c69da21c43a78034" target="_blank" rel="external">处理</a>。</p>
<p>最后需要注意的是， 所有这些建议仅适用 amd64架构因为它可以实现快速的常数级的<a href="https://blog.cloudflare.com/go-crypto-bridging-the-performance-gap/" target="_blank" rel="external">加密原语</a>(AES-GCM, ChaCha20-Poly1305, P256), 其它架构可能不适合产品级应用。</p>
<p>既然是服务要暴漏带互联网上， 它需要一个公开的可信的证书。通过<code>Let’s Encrypt</code>很容易申请， 可以使用<code>golang.org/x/crypto/acme/autocert</code>的<code>GetCertificate</code>函数。</p>
<p>不要忘了将HTTP重定向到HTTPS, 如果你的客户端是浏览器的话，可以考虑 <a href="https://www.owasp.org/index.php/HTTP_Strict_Transport_Security_Cheat_Sheet" target="_blank" rel="external">HSTS</a>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">srv := &http.Server{</div><div class="line">	ReadTimeout: <span class="number"> 5</span> * time.Second,</div><div class="line">	WriteTimeout:<span class="number"> 5</span> * time.Second,</div><div class="line">	Handler: http.HandlerFunc(<span class="keyword">func</span>(w http.ResponseWriter, req *http.Request) {</div><div class="line">		w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</div><div class="line">		url := <span class="string">"https://"</span> + req.Host + req.URL.String()</div><div class="line">		http.Redirect(w, req, url, http.StatusMovedPermanently)</div><div class="line">	}),</div><div class="line">}</div><div class="line"><span class="keyword">go</span> <span class="keyword">func</span>() { log.Fatal(srv.ListenAndServe()) }()</div></pre></td></tr></table></figure>

<p>你可以使用<a href="https://www.ssllabs.com/ssltest/" target="_blank" rel="external">SSL Labs test</a>检查配置是否正确。</p>
<h2 id="net/http">net/http</h2>
<p><code>net/http</code> 包含 <code>HTTP/1.1</code> 和 <code>HTTP/2</code>。你一定已经熟悉了Handler的开发，所以本文不讨论它。我们讨论服务器端背后的一些场景。</p>
<h3 id="Timeout">Timeout</h3>
<p>超时可能是最容易忽略的危险的场景。你的服务可能在受控网络中幸免于难，但是在互联网上就不会那么幸运了， 特别是(不仅仅)受到恶意攻击。</p>
<p>有一系列的资源需要超时控制。尽管goroutine消耗很少，但文件描述符总是有限的。卡住的连接、不工作的连接甚至恶意断掉的连接不应该消耗它们。</p>
<p>一个超过最大文件符的服务器总是不能接受新的连接， 会报下面的失败:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">http</span>: Accept error: accept tcp [::]:<span class="number">80</span>: accept: too many <span class="built_in">open</span> <span class="built_in">files</span>; retrying <span class="operator">in</span> <span class="number">1</span>s</div></pre></td></tr></table></figure>

<p>一个缺省的 <code>http.Server</code>, 、就像包文档中的例子<code>http.ListenAndServe</code> 和 <code>http.ListenAndServeTLS</code>， 没有设置任何超时控制, 你肯定不是你想要的。</p>
<p><img src="timeouts.png" alt=""></p>
<p>在<code>http.Server</code>有三个参数控制timeout: <code>ReadTimeout</code>, <code>WriteTimeout</code> 和 <code>IdleTimeout</code>,你可以显示地设置它们:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">srv := &http.Server{</div><div class="line">    ReadTimeout: <span class="number"> 5</span> * time.Second,</div><div class="line">    WriteTimeout:<span class="number"> 10</span> * time.Second,</div><div class="line">    IdleTimeout: <span class="number"> 120</span> * time.Second,</div><div class="line">    TLSConfig:    tlsConfig,</div><div class="line">    Handler:      serveMux,</div><div class="line">}</div><div class="line">log.Println(srv.ListenAndServeTLS(<span class="string">""</span>, <span class="string">""</span>))</div></pre></td></tr></table></figure>

<p><code>ReadTimeout</code>的时间范围起自连接备接受，止于请求的body完全读出。在<code>net/http</code>的实现中它在连接<code>Accept</code>后通过<code>SetReadDeadline</code><a href="https://github.com/golang/go/blob/3ba31558d1bca8ae6d2f03209b4cae55381175b3/src/net/http/server.go#L750" target="_blank" rel="external">设置</a>。</p>
<p><code>ReadTimeout</code>最大的问题它不允许服务器给客户端更多的时间去请求的body stream。 go 1.8新引入了一个参数<code>ReadHeaderTimeout</code>，它止于读完请求头。然后一直有一些不清楚的方式去设置读超时，相关的设计讨论可以参考<a href="https://golang.org/issue/16100" target="_blank" rel="external">#16100</a>。</p>
<p><code>WriteTimeout</code>超时正常起自读完请求头， 止于response写完(也就是<code>ServeHTTP</code>的生命周期)， 通过<code>readRequest</code>的<a href="https://github.com/golang/go/blob/3ba31558d1bca8ae6d2f03209b4cae55381175b3/src/net/http/server.go#L753-L755" target="_blank" rel="external">结尾</a>处的<code>SetWriteDeadline</code>设置。</p>
<p>然后，当通过HTTPS连接时，<code>SetWriteDeadline</code>在<code>Accept</code>后立即设置， 所以它也包含TLS握手的packet的写。讨厌的是，这意味着<code>WriteTimeout</code>包含http头的读以及第一个字节的等待。</p>
<p><code>ReadTimeout</code>和<code>WriteTimeout</code>是绝对值，无法在Handler中更改它(<a href="https://golang.org/issue/16100" target="_blank" rel="external">#16100</a>)。</p>
<p>Go 1.8还新引入了<code>IdleTimeout</code>参数， 用来限制服务端<code>Keep-Alive</code>连接在重用前idle的数量。</p>
<p>Go 1.8之前的版本， <code>ReadTimeout</code>在请求完成后又立即开始滴答(tick)，这对<code>Keep-Alive</code>连接是不合适的: idle time会消耗客户端允许发送请求的时间，导致一些快的客户端会有不期望的超时。</p>
<p>对于不可信的客户端和网络，你应该设置<code>Read</code>, <code>Write</code> 和 <code>Idle</code>超时， 这样一个读或者写很慢的客户端不会长时间占用一个连接。</p>
<p>对于go 1.8之前的 HTTP/1.1超时的背景知识， 你可以参考Cloudflare的<a href="https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/" target="_blank" rel="external">博客</a>。</p>
<h3 id="HTTP/2">HTTP/2</h3>
<p>HTTP/2在 Go 1.6+中回自动启用， 只要它满足下面的条件：</p>
<ul>
<li>请求通过<code>TLS/HTTPS</code></li>
<li><code>Server.TLSNextProto</code>为nil (如果设置一个空的map，则禁止HTTP/2)</li>
<li><code>Server.TLSConfig</code>已被设置，<code>ListenAndServeTLS</code>被调用或者下一条</li>
<li><code>Serve</code>被调用，并且<code>tls.Config.NextProtos</code>包含<code>h2</code> (比如[]string{&quot;h2&quot;, &quot;http/1.1&quot;)</li>
</ul>
<p>HTTP/2 和 HTTP/1.1有些不同，因为同一个连接同时会服务多个请求，但是Go抽象了统一的超时控制接口。</p>
<p>遗憾的是, Go 1.7中的<code>ReadTimeout</code>会打断 HTTP/2 连接，它不会为每一个连接重置，而是在连接初次建立时就设置而不会重置，当超时后就会断掉 HTTP/2连接。 Go 1.8 修复了这个<a href="https://github.com/golang/go/issues/16450" target="_blank" rel="external">问题</a>。</p>
<p>基于此和<code>ReadTimeout</code>的idle time问题，我强烈建议你尽快升级到1.8。</p>
<h3 id="TCP_Keep-Alives">TCP Keep-Alives</h3>
<p>如果你使用<code>ListenAndServe</code>(与传入<code>net.Listener</code>给<code>Serve</code>不同，这个方法使用缺省值提供了零保护措施)， 3分钟的TCP Keep-Alive会<a href="https://github.com/golang/go/blob/61db2e4efa2a8f558fd3557958d1c86dbbe7d3cc/src/net/http/server.go#L3023-L3039" target="_blank" rel="external">自动设置</a>,它会让彻底消失的client有机会放弃连接， 我的经验是不要完全相信它， 无论如何也要设置超时。</p>
<p>首先， 3分钟太长了，你可以使用你自己的<code>tcpKeepAliveListener</code>调整它。、</p>
<p>更重要的是，<code>Keep-Alive</code>只是保证client还活着，但不会设置连接存活的上限。恶意攻击的客户端会打开非常多的连接，导致你的服务器打开很多文件描述符， 通过未完成的请求， 会导致你的服务拒绝服务。</p>
<p>最后，我的经验是连接往往会导致泄漏，知道<a href="https://github.com/FiloSottile/Heartbleed/commit/4a3332ca1dc07aedf24b8540857792f72624cdf7" target="_blank" rel="external">超时起作用</a>。</p>
<h3 id="ServeMux">ServeMux</h3>
<p>包级别的<code>http.Handle[Func]</code> (和你的web框架)注册handler到全局的<code>http.DefaultServeMux</code>， 如果<code>Server.Handler</code>是nil的话， 你应该避免这样做。</p>
<p>任何你输入的包，不管是直接的还是间接的，都可以访问<code>http.DefaultServeMux</code>，可能会注册你不期望的route。</p>
<p>例如，包依赖中有任何一个库导入了<code>net/http/pprof</code>,客户端都能得到你的应用的CPU的profile。 你可以使用<code>net/http/pprof</code>手工注册。</p>
<p>正确的是， 初始化你自己的<code>http.ServeMux</code>,把handler注册到它的上面， 设置它为<code>Server.Handler</code>, 或者设置你自己的web框架为<code>Server.Handler</code>。</p>
<h3 id="Logging">Logging</h3>
<p>net/http在调用你的handler之前做了大量的工作， 比如<a href="">接受连接</a><a href="https://github.com/golang/go/blob/1106512db54fc2736c7a9a67dd553fc9e1fca742/src/net/http/server.go#L2631-L2653，" target="_blank" rel="external">https://github.com/golang/go/blob/1106512db54fc2736c7a9a67dd553fc9e1fca742/src/net/http/server.go#L2631-L2653，</a> <a href="https://github.com/golang/go/blob/1106512db54fc2736c7a9a67dd553fc9e1fca742/src/net/http/server.go#L1718-L1728" target="_blank" rel="external">TLS握手</a>等等……</p>
<p>当任何一个步骤出错，它会写一行日志到<code>Server.ErrorLog</code>。其中一些错误， 比如超时和连接重置， 在互联网上是正常的。你可以连接大部分错误并把它们加入到metric中，这要归功于这个保证：</p>
<blockquote>
<p>Each logging operation makes a single call to the Writer’s Write method.</p>
</blockquote>
<p>如果在handler中你不想输出堆栈log, 你可以使用<code>panic(nil)</code>或者使用Go 1.8的<code>panic(http.ErrAbortHandler)</code>。</p>
<h3 id="Metrics">Metrics</h3>
<p>metric可以帮助你监控打开的文件描述符。<a href="https://github.com/prometheus/client_golang/blob/575f371f7862609249a1be4c9145f429fe065e32/prometheus/process_collector.go" target="_blank" rel="external">Prometheus使用<code>proc</code>文件系统来帮助你完成这些</a>。</p>
<p>如果你需要调研泄漏问题， 你可以使用<code>Server.ConnState</code>钩子来得到更多的连接的细节metric。注意，不保持state就没有方式能保持一个正确的<code>StateActive</code>数量，所以你需要维护一个<code>map[net.Conn]ConnState</code>。</p>
<h3 id="结论">结论</h3>
<p>使用Nginx做Go服务前端的日志一去不复返了， 但是面对互联网你仍然需要做一些额外的防护措施， 可能需要升级到新的Go 1.8版本。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是 Cloudflare 的 Filippo Valsorda 2016年发表在Gopher Academy的一篇<a href="https://blog.gopheracademy.com/advent-2016/exposing-go-on-the-internet/" target="_blank" rel="external">文章</a>， 虽然过去两年了，但是依然很有意义。</p>
<p>先前 <code>crypto/tls</code> 太慢而<code>net/http</code>也很年轻， 所以对于Go web server来说， 通常我们明智的做法把它放在反向代理的后面， 如nginx等，现在不需要了。</p>
<p>在Cloudflare我们最近试验了直接暴漏纯Go的服务作为主机。 Go 1.8的<code>net/http</code> 和 <code>crypto/tls</code> 提供了稳定的、高性能并且灵活的功能。</p>
<p>然后，需要做一些调优的工作，本文我们将展示怎么去调优和使web服务器更稳定。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[完全静态编译一个Go程序]]></title>
    <link href="https://colobu.com/2018/07/20/totally-static-Go-builds/"/>
    <id>https://colobu.com/2018/07/20/totally-static-Go-builds/</id>
    <published>2018-07-20T00:36:18.000Z</published>
    <updated>2018-07-25T03:37:37.736Z</updated>
    <content type="html"><![CDATA[<p>在Docker化的今天， 我们经常需要静态编译一个Go程序，以便方便放在Docker容器中。 即使你没有引用其它的第三方包，只是在程序中使用了标准库<code>net</code>,你也会发现你编译后的程序依赖glic,这时候你需要glibc-static库，并且静态连接。</p>
<p>不同的Go版本下静态编译方式还有点不同，在go 1.10下， 下面的方式会尽可能做到静态编译：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGO_ENABLED=<span class="number">0</span> go build <span class="operator">-a</span> -ldflags <span class="string">'-extldflags "-static"'</span> .</div></pre></td></tr></table></figure>

<p>有一个<a href="https://github.com/golang/go/issues/26492" target="_blank" rel="external">提案</a>请求给编译加一个<code>static</code>,如果接收了的话也许在将来的go中直接使用<code>static</code>。</p>
<h2 id="参考文档">参考文档</h2>
<ol>
<li><a href="http://blog.wrouesnel.com/articles/Totally%20static%20Go%20builds/" target="_blank" rel="external">http://blog.wrouesnel.com/articles/Totally%20static%20Go%20builds/</a></li>
<li><a href="https://github.com/golang/go/issues/9344" target="_blank" rel="external">https://github.com/golang/go/issues/9344</a></li>
<li><a href="https://github.com/golang/go/issues/26492" target="_blank" rel="external">https://github.com/golang/go/issues/26492</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Docker化的今天， 我们经常需要静态编译一个Go程序，以便方便放在Docker容器中。 即使你没有引用其它的第三方包，只是在程序中使用了标准库<code>net</code>,你也会发现你编译后的程序依赖glic,这时候你需要glibc-static库，并且静态连接。]]>
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ldd、objdump、nm、strings、strip等工具]]></title>
    <link href="https://colobu.com/2018/07/12/some-tools-in-GNU-Binutils/"/>
    <id>https://colobu.com/2018/07/12/some-tools-in-GNU-Binutils/</id>
    <published>2018-07-12T08:11:29.000Z</published>
    <updated>2018-07-12T08:49:03.594Z</updated>
    <content type="html"><![CDATA[<p>最近在做Docker镜像的时候发现镜像文件非常大，需要找出程序的依赖库，减少程序的大小，所以整理了一下相关的工具。基本上这些工具都在<a href="https://www.gnu.org/software/binutils/" target="_blank" rel="external">GNU Binutils</a>中。</p>
<p>GNU Binary Utilities或binutils是一整套的编程语言工具程序，用来处理许多格式的目标文件。当前的版本原本由在Cygnus Solutions的程序员以Binary File Descriptor library（libbfd）所撰写。这个工具程序通常搭配GCC、make、和GDB这些程序来使用。</p>
<p>它包含20个左右的工具，本文介绍了我在创建Docker镜像的时候的使用的几种工具。</p>
<h3 id="ldd">ldd</h3>
<p>ldd不是GNU Binutils工具集中的一个工具，但是却是一个非常有用的工具， 它可以显示程序或者共享库所需的共享库。</p>
<p>例如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   <span class="comment"># ldd main</span></div><div class="line">linux-vdso.so.<span class="number">1</span> =&gt;  (<span class="number">0</span>x00007ffc88fd4000)</div><div class="line">libpthread.so.<span class="number">0</span> =&gt; /lib64/libpthread.so.<span class="number">0</span> (<span class="number">0</span>x00007faee13b8000)</div><div class="line">libc.so.<span class="number">6</span> =&gt; /lib64/libc.so.<span class="number">6</span> (<span class="number">0</span>x00007faee0feb000)</div><div class="line">/lib64/ld-linux-x86-<span class="number">64</span>.so.<span class="number">2</span> (<span class="number">0</span>x00007faee15d4000)</div></pre></td></tr></table></figure>

<p>依照ldd得手册， 有时候ldd会通过执行程序来获取依赖信息，对于来源不明的程序，执行这些程序可能会带来风险，所以对于来源不明的程序，可以使用<code>objdump</code>来分析。</p>
<h3 id="objdump">objdump</h3>
<p>onjdump可以显示目标文件的信息,可以通过参数控制要显示的内容。</p>
<p>比如<code>-p</code>可以显示文件头内容， 通过<code>grep</code>可以查看依赖的库。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># objdump -p  main|grep GLIBC</span></div><div class="line"><span class="number">0</span>x09691a75 <span class="number">0</span>x00 <span class="number">02</span> GLIBC_2.<span class="number">2.5</span></div><div class="line"><span class="number">0</span>x09691972 <span class="number">0</span>x00 <span class="number">03</span> GLIBC_2.<span class="number">3.2</span></div><div class="line"><span class="number">0</span>x09691a75 <span class="number">0</span>x00 <span class="number">04</span> GLIBC_2.<span class="number">2.5</span></div></pre></td></tr></table></figure>

<p>甚至可以查看<code>-T</code>可以查看动态符号表的内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># objdump -T  main|grep GLIBC</span></div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> stderr</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> fwrite</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> vfprintf</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> fputc</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> abort</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> pthread_mutex_lock</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">3.2</span> pthread_cond_wait</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> pthread_mutex_unlock</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">3.2</span> pthread_cond_broadcast</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> pthread_create</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> nanosleep</div><div class="line"><span class="number">0000000000000000</span>      DO *UND*	<span class="number">0000000000000000</span>  GLIBC_2.<span class="number">2.5</span> pthread_detach</div><div class="line">......</div></pre></td></tr></table></figure>

<h3 id="nm">nm</h3>
<p>nm显示目标文件的符号。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># nm go/bin/glide |more</span></div><div class="line"><span class="number">0000000000908680</span> r andMask</div><div class="line"><span class="number">0000000000901</span>d00 r bswapMask</div><div class="line"><span class="number">00000000009036</span>c0 r BSWAP_SHUFB_CTL</div><div class="line"><span class="number">0000000000</span>b000e0 B bufio.ErrAdvanceTooFar</div><div class="line"><span class="number">0000000000</span>b000f0 B bufio.ErrBufferFull</div><div class="line"><span class="number">0000000000</span>b00100 B bufio.ErrFinalToken</div><div class="line"><span class="number">0000000000</span>b00110 B bufio.ErrInvalidUnreadByte</div><div class="line"><span class="number">0000000000</span>b00120 B bufio.ErrInvalidUnreadRune</div><div class="line"><span class="number">0000000000</span>b00130 B bufio.ErrNegativeAdvance</div><div class="line"><span class="number">0000000000</span>b00140 B bufio.ErrNegativeCount</div><div class="line"><span class="number">0000000000</span>b00160 B bufio.errNegativeRead</div><div class="line"><span class="number">0000000000</span>b00170 B bufio.errNegativeWrite</div><div class="line"><span class="number">0000000000</span>b00150 B bufio.ErrTooLong</div><div class="line"><span class="number">00000000004</span>d9140 T bufio.init</div><div class="line"><span class="number">0000000000</span>b21120 B bufio.initdone.</div><div class="line"><span class="number">00000000004</span>d6510 T bufio.(*Reader).Buffered</div><div class="line"><span class="number">00000000004</span>d59d0 T bufio.(*Reader).Discard</div><div class="line"><span class="number">00000000004</span>d5590 T bufio.(*Reader).fill</div><div class="line"><span class="number">00000000004</span>d57c0 T bufio.(*Reader).Peek</div><div class="line"><span class="number">00000000004</span>d5b70 T bufio.(*Reader).Read</div><div class="line">......</div></pre></td></tr></table></figure>

<h3 id="strings">strings</h3>
<p>strings显示文件中的可打印字符。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># strings main|grep GLIBC</span></div><div class="line">GLIBC_2.<span class="number">2.5</span></div><div class="line">GLIBC_2.<span class="number">3.2</span></div><div class="line">GLIBC_2.<span class="number">2.5</span></div></pre></td></tr></table></figure>

<h3 id="strip">strip</h3>
<p>通过上面的工具，可以分析出文件的依赖库，创建Docker镜像的时候只需把所需的依赖库加进去即可。</p>
<p>如果程序本身比较大，可以将程序压缩，去掉不需要的一些数据， 比如使用<code>strip</code>进行裁剪。</p>
<p>你可以通过参数控制要丢掉的哪些符号。<br>比如去除符号表和行号信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">strip</span> main</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>最近在做Docker镜像的时候发现镜像文件非常大，需要找出程序的依赖库，减少程序的大小，所以整理了一下相关的工具。基本上这些工具都在<a href="https://www.gnu.org/software/binutils/" target="_blank" rel="e]]>
    </summary>
    
      <category term="工具" scheme="https://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[解决 error creating overlay mount to /var/lib/docker/overlay2]]></title>
    <link href="https://colobu.com/2018/06/28/Error-response-from-daemon-error-creating-overlay-mount-to-var-lib-docker-overlay2/"/>
    <id>https://colobu.com/2018/06/28/Error-response-from-daemon-error-creating-overlay-mount-to-var-lib-docker-overlay2/</id>
    <published>2018-06-28T08:45:44.000Z</published>
    <updated>2018-06-28T08:59:50.657Z</updated>
    <content type="html"><![CDATA[<p>最近在<code>centos7.1</code>使用docker运行<code>redis</code>镜像，出现下面的错误：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/usr/bin/docker-current: <span class="keyword">Error</span> response <span class="keyword">from</span> daemon: <span class="keyword">error</span> creating overlay mount <span class="keyword">to</span> /var/<span class="keyword">lib</span>/docker/overlay2/<span class="number">65</span>f3c109fb903539820f84856d2725af784f2f03f95b1f0214e34184e4d61ff7-init/merged: invalid argument.</div><div class="line">See <span class="comment">'/usr/bin/docker-current run --help'.</span></div></pre></td></tr></table></figure>

<p>在网上搜索一番后，一个可行的方案如下(改变storage driver类型， 禁用selinux):</p>
<ol>
<li>停止docker服务</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl stop docker</div></pre></td></tr></table></figure>

<ol>
<li>清理镜像</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -rf /var/lib/docker</div></pre></td></tr></table></figure>

<ol>
<li>修改存储类型</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/sysconfig/docker-storage</div></pre></td></tr></table></figure>

<p>把空的DOCKER_STORAGE_OPTIONS参数改为overlay:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DOCKER_STORAGE_OPTIONS=<span class="string">"--storage-driver overlay"</span></div></pre></td></tr></table></figure>

<ol>
<li>禁用selinux</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/sysconfig/docker</div></pre></td></tr></table></figure>

<p>去掉option的<code>--selinux-enabled</code></p>
<ol>
<li>启动docker应该就可以了</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl start docker</div></pre></td></tr></table></figure>

<p>方案抄自 <a href="https://blog.csdn.net/Ysssssssssssssss/article/details/79596367" target="_blank" rel="external">Ysssssssssssssss的博客</a> 和 redis的讨论: <a href="https://github.com/coreos/bugs/issues/2340" target="_blank" rel="external">error creating overlay mount to .../merged: invalid argument.</a>, 基本可以确定是启用selinux导致的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在<code>centos7.1</code>使用docker运行<code>redis</code>镜像，出现下面的错误：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div cl]]>
    </summary>
    
      <category term="Docker" scheme="https://colobu.com/categories/Docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 Go 实现快速排序]]></title>
    <link href="https://colobu.com/2018/06/26/implement-quick-sort-in-golang/"/>
    <id>https://colobu.com/2018/06/26/implement-quick-sort-in-golang/</id>
    <published>2018-06-26T10:29:33.000Z</published>
    <updated>2018-06-26T11:22:30.657Z</updated>
    <content type="html"><![CDATA[<p>快速排序(quick sort)号称是二十世纪最伟大的十大算法之一(<a href="http://www.uta.edu/faculty/rcli/TopTen/topten.pdf" target="_blank" rel="external">The Best of the 20th Century: Editors Name Top 10 Algorithms</a>), 但是快速排序也是最不容易实现的排序算法之一 (<a href=""></a>)。虽然它的原理非常的简单，但实现起来很容易出错。 也曾因为快排导致腥风血雨甚至网站攻击事件。</p>
<p>快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<blockquote>
<p>分治法：将问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。</p>
</blockquote>
<p>利用分治法可将快速排序的分为三步：</p>
<ul>
<li>在数据集之中，选择一个元素作为”基准”（pivot）。</li>
<li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。</li>
<li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li>
</ul>
<p>快速排序平均时间复杂度为<code>O(n log n)</code>,最坏情况为<code>O(n2)</code>，不稳定排序。</p>
<a id="more"></a>
<p>快速排序一般实现为原地排序(in-place),因为非原地排序会设计到大量的容器创建和对象复制。</p>
<p>本文实现了两种快速排序，一种是单线程的快速排序,一种是一定数量的goroutine并行的快速排序。</p>
<p>同时也增加了标准库排序算法和timsort算法的比较。</p>
<p>下面是算法实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"math/rand"</span></div><div class="line">	<span class="string">"sort"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/psilva261/timsort"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> partition(a []<span class="typename">int</span>, lo, hi <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">	pivot := a[hi]</div><div class="line">	i := lo -<span class="number"> 1</span></div><div class="line">	<span class="keyword">for</span> j := lo; j &lt; hi; j++ {</div><div class="line">		<span class="keyword">if</span> a[j] &lt; pivot {</div><div class="line">			i++</div><div class="line">			a[j], a[i] = a[i], a[j]</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">	a[i<span class="number">+1</span>], a[hi] = a[hi], a[i<span class="number">+1</span>]</div><div class="line">	<span class="keyword">return</span> i +<span class="number"> 1</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> quickSort(a []<span class="typename">int</span>, lo, hi <span class="typename">int</span>) {</div><div class="line">	<span class="keyword">if</span> lo &gt;= hi {</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	p := partition(a, lo, hi)</div><div class="line">	quickSort(a, lo, p<span class="number">-1</span>)</div><div class="line">	quickSort(a, p<span class="number">+1</span>, hi)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> quickSort_go(a []<span class="typename">int</span>, lo, hi <span class="typename">int</span>, done <span class="keyword">chan</span> <span class="keyword">struct</span>{}, depth <span class="typename">int</span>) {</div><div class="line">	<span class="keyword">if</span> lo &gt;= hi {</div><div class="line">		done &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	depth--</div><div class="line">	p := partition(a, lo, hi)</div><div class="line">	<span class="keyword">if</span> depth &gt;<span class="number"> 0</span> {</div><div class="line">		childDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 2</span>)</div><div class="line">		<span class="keyword">go</span> quickSort_go(a, lo, p<span class="number">-1</span>, childDone, depth)</div><div class="line">		<span class="keyword">go</span> quickSort_go(a, p<span class="number">+1</span>, hi, childDone, depth)</div><div class="line"></div><div class="line">		&lt;-childDone</div><div class="line">		&lt;-childDone</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		quickSort(a, lo, p<span class="number">-1</span>)</div><div class="line">		quickSort(a, p<span class="number">+1</span>, hi)</div><div class="line">	}</div><div class="line"></div><div class="line">	done &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	rand.Seed(time.Now().UnixNano())</div><div class="line"></div><div class="line">	testData1, testData2, testData3, testData4 := <span class="built_in">make</span>([]<span class="typename">int</span>,<span class="number"> 0</span>,<span class="number"> 100000000</span>), <span class="built_in">make</span>([]<span class="typename">int</span>,<span class="number"> 0</span>,<span class="number"> 100000000</span>), <span class="built_in">make</span>([]<span class="typename">int</span>,<span class="number"> 0</span>,<span class="number"> 100000000</span>), <span class="built_in">make</span>([]<span class="typename">int</span>,<span class="number"> 0</span>,<span class="number"> 100000000</span>)</div><div class="line">	times :=<span class="number"> 100000000</span></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; times; i++ {</div><div class="line">		val := rand.Intn<span class="number">(20000000</span>)</div><div class="line">		testData1 = <span class="built_in">append</span>(testData1, val)</div><div class="line">		testData2 = <span class="built_in">append</span>(testData2, val)</div><div class="line">		testData3 = <span class="built_in">append</span>(testData3, val)</div><div class="line">		testData4 = <span class="built_in">append</span>(testData4, val)</div><div class="line">	}</div><div class="line"></div><div class="line">	start := time.Now()</div><div class="line">	quickSort(testData1,<span class="number"> 0</span>, <span class="built_in">len</span>(testData1<span class="number">)-1</span>)</div><div class="line">	fmt.Println(<span class="string">"single goroutine: "</span>, time.Now().Sub(start))</div><div class="line"></div><div class="line">	<span class="keyword">if</span> !sort.IntsAreSorted(testData1) {</div><div class="line">		fmt.Println(<span class="string">"wrong quick_sort implementation"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})</div><div class="line">	start = time.Now()</div><div class="line">	<span class="keyword">go</span> quickSort_go(testData2,<span class="number"> 0</span>, <span class="built_in">len</span>(testData2<span class="number">)-1</span>, done,<span class="number"> 5</span>)</div><div class="line">	&lt;-done</div><div class="line">	fmt.Println(<span class="string">"multiple goroutine: "</span>, time.Now().Sub(start))</div><div class="line"></div><div class="line">	<span class="keyword">if</span> !sort.IntsAreSorted(testData2) {</div><div class="line">		fmt.Println(<span class="string">"wrong quickSort_go implementation"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	start = time.Now()</div><div class="line">	sort.Ints(testData3)</div><div class="line">	fmt.Println(<span class="string">"std lib: "</span>, time.Now().Sub(start))</div><div class="line"></div><div class="line">	<span class="keyword">if</span> !sort.IntsAreSorted(testData3) {</div><div class="line">		fmt.Println(<span class="string">"wrong std lib implementation"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	start = time.Now()</div><div class="line">	timsort.Ints(testData4, <span class="keyword">func</span>(a, b <span class="typename">int</span>) <span class="typename">bool</span> { <span class="keyword">return</span> a &lt;= b })</div><div class="line">	fmt.Println(<span class="string">"timsort: "</span>, time.Now().Sub(start))</div><div class="line"></div><div class="line">	<span class="keyword">if</span> !sort.IntsAreSorted(testData4) {</div><div class="line">		fmt.Println(<span class="string">"wrong timsort implementation"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>快速排序(quick sort)号称是二十世纪最伟大的十大算法之一(<a href="http://www.uta.edu/faculty/rcli/TopTen/topten.pdf" target="_blank" rel="external">The Best of the 20th Century: Editors Name Top 10 Algorithms</a>), 但是快速排序也是最不容易实现的排序算法之一 (<a href=""></a>)。虽然它的原理非常的简单，但实现起来很容易出错。 也曾因为快排导致腥风血雨甚至网站攻击事件。</p>
<p>快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<blockquote>
<p>分治法：将问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。</p>
</blockquote>
<p>利用分治法可将快速排序的分为三步：</p>
<ul>
<li>在数据集之中，选择一个元素作为”基准”（pivot）。</li>
<li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。</li>
<li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li>
</ul>
<p>快速排序平均时间复杂度为<code>O(n log n)</code>,最坏情况为<code>O(n2)</code>，不稳定排序。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CGO 文章整理]]></title>
    <link href="https://colobu.com/2018/06/13/cgo-articles/"/>
    <id>https://colobu.com/2018/06/13/cgo-articles/</id>
    <published>2018-06-13T10:08:15.000Z</published>
    <updated>2018-08-28T10:56:52.554Z</updated>
    <content type="html"><![CDATA[<p>虽然<code>CGO</code>属于不太常用的技术，但是偶尔在一些场景中还是会用到的，本文搜集了一些<code>CGO</code>的文章, 方便大家学习和参考。</p>
<a id="more"></a>
<h3 id="官方文章">官方文章</h3>
<ul>
<li><a href="https://golang.org/cmd/cgo/" target="_blank" rel="external">cmd/cgo</a>: cgo命令行工具</li>
<li><a href="https://github.com/golang/go/wiki/cgo" target="_blank" rel="external">wiki/cgo</a>: 简介</li>
<li><a href="https://blog.golang.org/c-go-cgo" target="_blank" rel="external">C? Go? Cgo!</a>: 古老的文章</li>
<li><a href="https://github.com/golang/go/wiki/WindowsDLLs" target="_blank" rel="external">WindowsDLLs</a>: 不是CGO</li>
<li><a href="https://docs.hacknode.org/gopl-zh/ch13/ch13-04.html" target="_blank" rel="external">通过cgo调用C代码</a>: Go语言圣经中的介绍</li>
</ul>
<h3 id="相关文章">相关文章</h3>
<ul>
<li><a href="https://dave.cheney.net/2016/01/18/cgo-is-not-go" target="_blank" rel="external">cgo is not Go</a>: Dave Cheney的文章，CGO不好的地方，<a href="https://www.oschina.net/translate/cgo-is-not-go" target="_blank" rel="external">中文</a></li>
<li><a href="http://relistan.com/cgo-when-and-when-not-to-use-it/" target="_blank" rel="external">Cgo: When and (Usually) When Not to Use it</a>:决断</li>
<li><a href="https://www.cockroachlabs.com/blog/the-cost-and-complexity-of-cgo/" target="_blank" rel="external">The Cost and Complexity of Cgo</a>: 实践出真知</li>
<li><a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoCGoStringFunctions" target="_blank" rel="external">CGo&#39;s Go string functions explained</a>: CGO的字符串</li>
<li><a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoCGoCompatibleStructs" target="_blank" rel="external">Getting C-compatible structs in Go with and for cgo</a>: C兼容的 struct</li>
<li><a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoCgoExperienceNotes" target="_blank" rel="external">Some notes on my experience using Go&#39;s cgo system</a>: CGO使用经验</li>
<li><a href="https://medium.com/using-go-in-mobile-apps/using-go-in-mobile-apps-part-1-calling-go-functions-from-c-be1ecf7dfbc6" target="_blank" rel="external">Calling Go functions from C</a>: 在C语言中调用Go函数以及相反</li>
<li><a href="https://medium.com/learning-the-go-programming-language/calling-go-functions-from-other-languages-4c7d8bcc69bf" target="_blank" rel="external">Calling Go Functions from Other Languages</a>:从其它语言调用Go函数</li>
<li><a href="https://blog.filippo.io/rustgo/" target="_blank" rel="external">rustgo: calling Rust from Go with near-zero overhead</a>:使用的不是CGO,而是FFI</li>
<li><a href="https://blog.wallaroolabs.com/2018/04/adventures-with-cgo-part-1--the-pointering/" target="_blank" rel="external">Adventures with cgo: Part 1- The Pointering</a>: 探索</li>
<li><a href="http://akrennmair.github.io/golang-cgo-slides/#1" target="_blank" rel="external">Go &amp; cgo: integrating existing C code with Go</a>: 干货PPT</li>
<li><a href="https://www.jianshu.com/p/7d67068848a4" target="_blank" rel="external">如何在windows上使用cgo</a>: 中文，windows上使用CGO</li>
<li><a href="http://bastengao.com/blog/2017/12/go-cgo-c.html" target="_blank" rel="external">在 Go 语言中调用 C 代码</a>: 高辉的两篇介绍， 手把手教</li>
<li><a href="http://bastengao.com/blog/2017/12/go-cgo-cpp.html" target="_blank" rel="external">在 Go 语言中调用 C++ 代码</a>:</li>
<li><a href="http://blog.sina.com.cn/s/blog_48c95a190102w2ln.html" target="_blank" rel="external">Golang使用pkg-config自动获取头文件和链接库的方法</a>: 使用pkg-config简化CFLAGS和LDFLAGS设置</li>
<li><a href="http://gridengine.eu/index.php/other-stories/232-avoiding-the-ldlibrarypath-with-shared-libs-in-go-cgo-applications-2015-12-21" target="_blank" rel="external">Avoiding the LD_LIBRARY_PATH for Shared Libs in Go (cgo) Applications</a>: 设置CGO_LDFLAGS和CGO_CFLAGS环境变量</li>
<li><a href="https://artem.krylysov.com/blog/2017/04/13/handling-cpp-exceptions-in-go/" target="_blank" rel="external">Handling C++ exceptions in Go</a>: 处理C++的异常</li>
<li><a href="https://hackernoon.com/extending-python-3-in-go-78f3a69552ac" target="_blank" rel="external">Extending Python 3 in Go</a>:使用Go扩展Python</li>
<li><a href="https://dev.to/mattn/call-go-function-from-c-function-1n3" target="_blank" rel="external">Call Go function from C function</a>: c调用go</li>
<li><a href="http://technosophos.com/2013/06/20/go-calling-pointer-functions-c-cgo.html" target="_blank" rel="external">Go: Calling pointer functions in C with CGO</a>: 调用C函数指针</li>
<li><a href="https://www.cnblogs.com/cobbliu/p/5035358.html" target="_blank" rel="external">CGo中传递多维数组给C函数</a>: 多维数组处理</li>
<li><a href="https://github.com/giorgisio/cgo" target="_blank" rel="external">cgo by example</a>: cgo例子</li>
<li><a href="http://www.liuweihua.cn/2018/01/24/golang-cgo/" target="_blank" rel="external">golang cgo</a>: 总结</li>
<li><a href="http://www.swig.org/Doc3.0/Go.html" target="_blank" rel="external">SWIG and Go</a>: C++</li>
<li><a href="https://stackoverflow.com/questions/6125683/call-go-functions-from-c" target="_blank" rel="external">Call Go functions from C</a>: C中调用Go函数</li>
<li><a href="https://github.com/chai2010/advanced-go-programming-book/blob/master/ch2-cgo/readme.md" target="_blank" rel="external">CGO编程</a>:柴树杉 《Go语言高级编程》中的CGO一章</li>
</ul>
<h3 id="辅助工具">辅助工具</h3>
<ul>
<li><a href="https://github.com/xlab/c-for-go" target="_blank" rel="external">c-for-go</a>: cgo产生器</li>
<li><a href="https://github.com/gonuts/ffi" target="_blank" rel="external">ffi</a>: 不使用CGO的另一种方式，ffi</li>
<li><a href="https://github.com/michlabs/cgoutil" target="_blank" rel="external">cgoutil</a>: 字符串数组的便利方法</li>
<li><a href="https://github.com/vitaminwater/cgo.wchar" target="_blank" rel="external">cgo.wchar</a>: wchar_t的便利方法</li>
<li><a href="https://godoc.org/github.com/chai2010/cgo" target="_blank" rel="external">chai2010/cgo</a>: 柴树杉实现的辅助方法</li>
</ul>
<h3 id="CGO应用">CGO应用</h3>
<ul>
<li><a href="https://github.com/draffensperger/go-interlang" target="_blank" rel="external">go-interlang</a>: go与几种语言相互调用的例子</li>
<li><a href="https://github.com/kitech/qt.go" target="_blank" rel="external">qt.go</a>: QT binding</li>
<li><a href="https://github.com/gen2brain/raylib-go" target="_blank" rel="external">raylib-go</a>:光线追踪库</li>
<li><a href="https://github.com/go-opencv/go-opencv" target="_blank" rel="external">go-opencv</a>:</li>
<li><a href="https://github.com/hashicorp/raft-mdb" target="_blank" rel="external">hashicorp/raft-mdb</a>:</li>
<li><a href="https://github.com/mattn/go-sqlite3" target="_blank" rel="external">go-sqlite3</a>:</li>
<li><a href="https://github.com/tecbot/gorocksdb" target="_blank" rel="external">gorocksdb</a>:</li>
<li><a href="https://github.com/AllenDang/w32" target="_blank" rel="external">w32</a>: win32 API包装</li>
<li><a href="https://github.com/quirkey/magick/blob/master/magick.go" target="_blank" rel="external">magick</a>: 代码量少，易学习</li>
<li><a href="https://github.com/imroc/ontts" target="_blank" rel="external">ontts</a>:科大讯飞语音linux在线语音合成后台服务</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然<code>CGO</code>属于不太常用的技术，但是偶尔在一些场景中还是会用到的，本文搜集了一些<code>CGO</code>的文章, 方便大家学习和参考。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[搭建IPFS私有网络]]></title>
    <link href="https://colobu.com/2018/05/29/setup-ipfs-private-network/"/>
    <id>https://colobu.com/2018/05/29/setup-ipfs-private-network/</id>
    <published>2018-05-29T09:05:56.000Z</published>
    <updated>2018-05-29T09:35:26.386Z</updated>
    <content type="html"><![CDATA[<p>IPFS (InterPlanetary File System) 是一个面向全球的、点对点的分布式版本文件系统。它用基于内容的地址替代基于域名的地址，也就是用户寻找的不是某个地址而是储存在某个地方的内容，不需要验证发送者的身份，而只需要验证内容的哈希，通过这样可以让网页的速度更快、更安全、更健壮、更持久。IPFS表示，IPFS未来将替代HTTP（以及其他的许多东西）。</p>
<blockquote>
<p>IPFS 和 BitTorrent 的区别: <a href="https://github.com/ipfs/faq/issues/17" target="_blank" rel="external">How does it compare to BitTorrent&#39;s Project Maelstrom?</a></p>
</blockquote>
<p>IPFS从根本上改变了用户搜索的方式。通过IPFS，用户搜索的是内容。通过HTTP浏览器搜索文件的时候，首先找到服务器的位置（IP地址），然后使用路径名称在服务器上查找文件。按照这个设计，只有文件所有者可以判断这是否是用户要找的文件。此时，必须保证托管者不会通过移除文件或者关闭服务器而对文件做任何更改。</p>
<p>当文件被添加到IPFS节点上，它得到一个新的名字。这个名字实际上是一个加密哈希，它是从文件内容中被计算出来。通过加密保证该哈希始终只表示该文件的内容。哪怕只在文件中修改一个比特的数据，哈希都会完全不同。</p>
<p>当下一步向IPFS分布式网络询问哈希的时候，它通过使用一个分布式哈希表，可以快速（在一个拥有10,000,000个节点的网络中只需要20跳）地找到拥有数据的节点，从而检索该数据，并使用哈希验证这是否是正确的数据。</p>
<p>不幸的是， IPFS 被<strong>墙</strong>了。如果你有幸能翻墙，你可以通过通过下面的命令下载并安装预编译的ipfs工具。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tar xvfz go-ipfs.tar.gz</div><div class="line"><span class="built_in">cd</span> go-ipfs</div><div class="line">./install.sh</div></pre></td></tr></table></figure>

<p>然后初始化仓库:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; ipfs init</div><div class="line"></div><div class="line">initializing ipfs node <span class="keyword">at</span> /Users/jbenet/.go-ipfs</div><div class="line">generating <span class="number">2048</span>-bit RSA keypair...done</div><div class="line">peer identity: Qmcpo2iLBikrdf1d6QU6vXuNb6P7hwrbNPW9kLAH8eG67z</div><div class="line"><span class="built_in">to</span> <span class="built_in">get</span> started, enter:</div><div class="line"></div><div class="line">  ipfs cat /ipfs/QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG/readme</div></pre></td></tr></table></figure>

<p>它默认会在你的Home下创建一个<code>.ipfs</code>文件夹。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ipfs cat /ipfs/QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG/readme</div></pre></td></tr></table></figure>

<p>查看ipfs网络上的一个文件，正常你可以看到这个文件的内容。</p>
<p>你可以使用<code>ipfs add</code>上传文件，<code>ipfs cat</code>查看文件。当然<code>ipfs</code>包含很多的命令，你可以在 <a href="https://ipfs.io/docs/commands/" target="_blank" rel="external">commands</a> 页面查看每个命令。</p>
<p>默认IPFS会通过一些种子连接到IPFS全球网络， 如果你想搭建一个私有的IPFS网络，可以使用本文下面介绍的方法。</p>
<a id="more"></a>
<h2 id="初始化一个私有仓库">初始化一个私有仓库</h2>
<p>命令同上</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ipfs init</div></pre></td></tr></table></figure>

<p>默认<code>$IPFS_PATH</code>为<code>$Home\.ipfs</code>文件夹。</p>
<h2 id="创建共享的key">创建共享的key</h2>
<p>使用<a href="https://github.com/Kubuxu/go-ipfs-swarm-key-gen" target="_blank" rel="external">ipfs-swarm-key-gen</a>创建私有网络共享的key, 私有网络的所有的节点都使用这个key, 不使用这个key的节点无法加入这个私有网络。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">go get github.com/Kubuxu/go-ipfs-swarm-key-gen/ipfs-swarm-key-gen</div><div class="line">ipfs-swarm-key-gen &gt; ~/.ipfs/swarm.key</div></pre></td></tr></table></figure>

<h2 id="移除默认的bootstrap节点">移除默认的bootstrap节点</h2>
<p>为了不连接全球的IPFS网络，你需要将默认的bootstrap的节点信息删除。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ipfs bootstrap rm --all</div></pre></td></tr></table></figure>

<h2 id="加入私有网络">加入私有网络</h2>
<p>如果是第一个节点， 这一步可以省略。</p>
<p>如果你已经知道了私有网络的一些节点，你可以把它们作为bootstrap节点。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ipfs bootstrap add &lt;multiaddr&gt;</div></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ipfs bootstrap add <span class="regexp">/ip4/</span><span class="number">104.236</span>.<span class="number">76.40</span><span class="regexp">/tcp/</span><span class="number">4001</span><span class="regexp">/ipfs/</span>QmSoLV4Bbm51jM9C4gDYZQ9Cy3U6aXMJDAbzgu2fzaDs64</div></pre></td></tr></table></figure>

<h2 id="设置LIBP2P_FORCE_PNET">设置LIBP2P_FORCE_PNET</h2>
<p>设置环境变量<code>LIBP2P_FORCE_PNET</code>为<code>1</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> LIBP2P_FORCE_PNET=<span class="number">1</span></div></pre></td></tr></table></figure>

<h2 id="测试">测试</h2>
<p>在一个节点上增加一个文件，然后在另外一个节点cat这个文件，看看是否成功了。</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="http://www.infoq.com/cn/articles/ipfs" target="_blank" rel="external">http://www.infoq.com/cn/articles/ipfs</a></li>
<li><a href="https://github.com/ipfs/go-ipfs/blob/master/docs/experimental-features.md#private-networks" target="_blank" rel="external">https://github.com/ipfs/go-ipfs/blob/master/docs/experimental-features.md#private-networks</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>IPFS (InterPlanetary File System) 是一个面向全球的、点对点的分布式版本文件系统。它用基于内容的地址替代基于域名的地址，也就是用户寻找的不是某个地址而是储存在某个地方的内容，不需要验证发送者的身份，而只需要验证内容的哈希，通过这样可以让网页的速度更快、更安全、更健壮、更持久。IPFS表示，IPFS未来将替代HTTP（以及其他的许多东西）。</p>
<blockquote>
<p>IPFS 和 BitTorrent 的区别: <a href="https://github.com/ipfs/faq/issues/17" target="_blank" rel="external">How does it compare to BitTorrent&#39;s Project Maelstrom?</a></p>
</blockquote>
<p>IPFS从根本上改变了用户搜索的方式。通过IPFS，用户搜索的是内容。通过HTTP浏览器搜索文件的时候，首先找到服务器的位置（IP地址），然后使用路径名称在服务器上查找文件。按照这个设计，只有文件所有者可以判断这是否是用户要找的文件。此时，必须保证托管者不会通过移除文件或者关闭服务器而对文件做任何更改。</p>
<p>当文件被添加到IPFS节点上，它得到一个新的名字。这个名字实际上是一个加密哈希，它是从文件内容中被计算出来。通过加密保证该哈希始终只表示该文件的内容。哪怕只在文件中修改一个比特的数据，哈希都会完全不同。</p>
<p>当下一步向IPFS分布式网络询问哈希的时候，它通过使用一个分布式哈希表，可以快速（在一个拥有10,000,000个节点的网络中只需要20跳）地找到拥有数据的节点，从而检索该数据，并使用哈希验证这是否是正确的数据。</p>
<p>不幸的是， IPFS 被<strong>墙</strong>了。如果你有幸能翻墙，你可以通过通过下面的命令下载并安装预编译的ipfs工具。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tar xvfz go-ipfs.tar.gz</div><div class="line"><span class="built_in">cd</span> go-ipfs</div><div class="line">./install.sh</div></pre></td></tr></table></figure>

<p>然后初始化仓库:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; ipfs init</div><div class="line"></div><div class="line">initializing ipfs node <span class="keyword">at</span> /Users/jbenet/.go-ipfs</div><div class="line">generating <span class="number">2048</span>-bit RSA keypair...done</div><div class="line">peer identity: Qmcpo2iLBikrdf1d6QU6vXuNb6P7hwrbNPW9kLAH8eG67z</div><div class="line"><span class="built_in">to</span> <span class="built_in">get</span> started, enter:</div><div class="line"></div><div class="line">  ipfs cat /ipfs/QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG/readme</div></pre></td></tr></table></figure>

<p>它默认会在你的Home下创建一个<code>.ipfs</code>文件夹。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ipfs cat /ipfs/QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG/readme</div></pre></td></tr></table></figure>

<p>查看ipfs网络上的一个文件，正常你可以看到这个文件的内容。</p>
<p>你可以使用<code>ipfs add</code>上传文件，<code>ipfs cat</code>查看文件。当然<code>ipfs</code>包含很多的命令，你可以在 <a href="https://ipfs.io/docs/commands/" target="_blank" rel="external">commands</a> 页面查看每个命令。</p>
<p>默认IPFS会通过一些种子连接到IPFS全球网络， 如果你想搭建一个私有的IPFS网络，可以使用本文下面介绍的方法。</p>
]]>
    
    </summary>
    
      <category term="IPFS" scheme="https://colobu.com/tags/IPFS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[停止、删除所有的docker容器和镜像]]></title>
    <link href="https://colobu.com/2018/05/15/Stop-and-remove-all-docker-containers-and-images/"/>
    <id>https://colobu.com/2018/05/15/Stop-and-remove-all-docker-containers-and-images/</id>
    <published>2018-05-15T10:10:59.000Z</published>
    <updated>2018-05-31T12:25:32.094Z</updated>
    <content type="html"><![CDATA[<p>这些命令总是记不住，或者说不用心去记，所以记录在本文中，以便将来查询。</p>
<a id="more"></a>
<h2 id="列出所有的容器_ID">列出所有的容器 ID</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">ps</span> -aq</div></pre></td></tr></table></figure>

<h2 id="停止所有的容器">停止所有的容器</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">stop</span> $(docker <span class="keyword">ps</span> -aq)</div></pre></td></tr></table></figure>

<h2 id="删除所有的容器">删除所有的容器</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm $(docker <span class="keyword">ps</span> -aq)</div></pre></td></tr></table></figure>

<h2 id="删除所有的镜像">删除所有的镜像</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi <span class="variable">$(</span>docker images -q)</div></pre></td></tr></table></figure>

<h2 id="复制文件">复制文件</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker cp mycontainer:/opt/<span class="built_in">file</span>.txt /opt/<span class="built_in">local</span>/</div><div class="line">docker cp /opt/<span class="built_in">local</span>/<span class="built_in">file</span>.txt mycontainer:/opt/</div></pre></td></tr></table></figure>

<p><strong>更新</strong>: @snakeliwei 的提醒， 现在的docker有了专门清理资源(container、image、网络)的命令。 docker 1.13 中增加了 <code>docker system prune</code>的命令，针对container、image可以使用<code>docker container prune</code>、<code>docker image prune</code>命令。</p>
<ul>
<li><code>docker image prune --force --all</code>或者docker image prune -f -a` : 删除所有不使用的镜像</li>
<li><code>docker container prune -f</code>: 删除所有停止的容器</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这些命令总是记不住，或者说不用心去记，所以记录在本文中，以便将来查询。</p>
]]>
    
    </summary>
    
      <category term="Docker" scheme="https://colobu.com/categories/Docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2018微博内部技术分享春晚专场]]></title>
    <link href="https://colobu.com/2018/04/24/weibo-share-2018/"/>
    <id>https://colobu.com/2018/04/24/weibo-share-2018/</id>
    <published>2018-04-24T10:29:50.000Z</published>
    <updated>2018-04-24T10:32:10.251Z</updated>
    <content type="html"><![CDATA[<p>这是公司内部分享的各部门春晚保障的技术分享。我将其中的和公司隐私相关的数据删除了，只保留了技术的介绍，总结了一些知识点。</p>
<p>Tim开场白。</p>
<p>双十一、微信红包和微博的区别（无法预期）。</p>
<p>三条军规。</p>
<a id="more"></a>
<h2 id="孟兆飞_混合云架构下微博春晚保障">孟兆飞 混合云架构下微博春晚保障</h2>
<h3 id="流量">流量</h3>
<ul>
<li>突发流量： 日常、异常</li>
<li>春晚</li>
<li>央视合作</li>
</ul>
<h3 id="万台扩容挑战">万台扩容挑战</h3>
<ul>
<li>联路长</li>
<li>依赖多</li>
<li>高并发</li>
</ul>
<p>15分钟1000台全公司随时随地</p>
<h3 id="自动化">自动化</h3>
<ul>
<li>智能弹性</li>
<li>混合云平台</li>
<li>监控信息</li>
<li>容量评估</li>
</ul>
<p>双仓库(公司内网、阿里云)</p>
<h3 id="高可用">高可用</h3>
<p>传统扩容，由于资源限制会失败</p>
<p>优化扩容：基于多种策略</p>
<p>DCP高可用双机房</p>
<h3 id="春节保障">春节保障</h3>
<p>春节X台扩容、云上X台<br>流量监控</p>
<p>DNS问题、扩容 （16台支持万台client） UDP session?</p>
<p>全链路压测。演练。共享池。重点监控。</p>
<h2 id="熊超_让红包飞春晚55万qps解决方案">熊超 让红包飞春晚55万qps解决方案</h2>
<p>超预期</p>
<h3 id="战队红包">战队红包</h3>
<h4 id="业务">业务</h4>
<p>满N万开奖</p>
<ul>
<li>瞬间QPS高</li>
<li>参与人数越多，开奖越快</li>
<li>瞬间开奖</li>
<li>参与规则复杂，单次参与动作资源交互次数10+</li>
</ul>
<h4 id="实现">实现</h4>
<p>5台扫描， 扔队列， 30台队列机， 64组redis， 发奖发私信等</p>
<p>前端： 缓存、不可缓存</p>
<h3 id="红包雨">红包雨</h3>
<h4 id="业务-1">业务</h4>
<p>3次机会，10分钟任意点</p>
<ul>
<li>参与用户多</li>
<li>拼手速、qps 55万</li>
<li>每次点击都有请求</li>
<li>中出数量巨大， 5次红包雨1.6亿</li>
</ul>
<h4 id="实现-1">实现</h4>
<ul>
<li>传送门 检查用户等，加密防刷、垃圾用户过滤、入口处错峰</li>
<li>抽奖: 特别快的请求、根据用户区分奖项</li>
<li>中出</li>
<li>队列机</li>
</ul>
<h4 id="优化">优化</h4>
<ul>
<li>代码： 重复资源链接重用、耗时步骤优化、根据日志</li>
<li>DBA： 监控平台</li>
</ul>
<h4 id="压测评估">压测评估</h4>
<h2 id="温情_陈新伍_春节百万答题">温情 陈新伍 春节百万答题</h2>
<p>两三周紧急开发。</p>
<h3 id="背景">背景</h3>
<p>大家都在做，拉新拉活。</p>
<p>产品经理介绍这个产品。</p>
<h3 id="技术挑战">技术挑战</h3>
<ul>
<li>快速扩所容</li>
<li>快速下发push设计</li>
</ul>
<h3 id="简介">简介</h3>
<ul>
<li>视频流</li>
<li>消息互动</li>
<li>问答</li>
</ul>
<p>发题阶段 -&gt; 答题阶段 -&gt; 颁奖阶段</p>
<h3 id="技术挑战-1">技术挑战</h3>
<ul>
<li>消息实时性</li>
<li><p>同步答题、实时到达率</p>
</li>
<li><p>每秒千万推送</p>
</li>
<li>百万在线</li>
</ul>
<h3 id="长连推送">长连推送</h3>
<ul>
<li>百万长连接</li>
<li><p>水平弹性伸缩</p>
<ul>
<li>无状态服务</li>
<li>减少资源的依赖</li>
</ul>
</li>
<li><p>消息分发队列: Reids的PubSub (apiServer  -&gt; redis)</p>
</li>
</ul>
<h3 id="问答服务">问答服务</h3>
<ul>
<li>上行: 接口https</li>
<li>下行方案:<ul>
<li>互动消息下发</li>
<li>轮训 (西瓜视频)</li>
<li>加入房间时全量下发(容易漏题)</li>
<li>视频流(SEI)下发(丢包)</li>
</ul>
</li>
</ul>
<p>微博方案: 1为主，2为辅</p>
<p>发题方案：  </p>
<ul>
<li>Push+ACK： 有条件重传</li>
<li>Push + Push: 无条件重传</li>
</ul>
<p>轮训：长链接断后自动重连降级</p>
<p>发题设计：根据服务器NTP， 题目和视频校准同时弹出</p>
<p>答题阶段</p>
<ul>
<li>客户端答题服务器判题</li>
<li>复活</li>
<li>答题结果推送</li>
<li>答题汇总</li>
<li>汇总推送</li>
</ul>
<p>10万级别的qps</p>
<p>判题方案：</p>
<ul>
<li>异步判题</li>
<li>随机重试机制</li>
</ul>
<p>服务压测</p>
<ul>
<li>第一场就全量push,无灰度</li>
<li>峰值速度快，第一题为峰值</li>
<li>百万用户</li>
</ul>
<h2 id="关里_微博搜索架构">关里 微博搜索架构</h2>
<h3 id="架构">架构</h3>
<p>trigger -&gt; 数据转换 -&gt; 预处理 -&gt; 数据分发 --&gt; 索引库</p>
<p>各种检索模块</p>
<p>热点爆发白页</p>
<p>数据分层：优质、筛选、全量</p>
<p>自动扩容、自动降级</p>
<p>1000多亿次数据需要索引</p>
<p>单机7、8亿</p>
<h2 id="朱伟_支撑百亿级请求的微博广告运维技术实践">朱伟 支撑百亿级请求的微博广告运维技术实践</h2>
<p>运维在微博广告体系中的价值。</p>
<p>人工 -&gt; 工具 -&gt; DevOps -&gt; AiOps</p>
<ul>
<li>监控: 数据采集、清洗、存储。Filebeat -&gt; kafka -&gt; OLS -&gt; Druid, kafka -&gt; graphite, kafka -&gt; logstash -&gt; ES, 多存储graphite,druid,ES, clickhouse</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是公司内部分享的各部门春晚保障的技术分享。我将其中的和公司隐私相关的数据删除了，只保留了技术的介绍，总结了一些知识点。</p>
<p>Tim开场白。</p>
<p>双十一、微信红包和微博的区别（无法预期）。</p>
<p>三条军规。</p>
]]>
    
    </summary>
    
      <category term="分享" scheme="https://colobu.com/categories/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go Channel 应用模式]]></title>
    <link href="https://colobu.com/2018/03/26/channel-patterns/"/>
    <id>https://colobu.com/2018/03/26/channel-patterns/</id>
    <published>2018-03-26T14:00:35.000Z</published>
    <updated>2018-08-30T03:11:58.563Z</updated>
    <content type="html"><![CDATA[<p>Channel是Go中的一种类型，和goroutine一起为Go提供了并发技术， 它在开发中得到了广泛的应用。Go鼓励人们通过Channel在goroutine之间传递数据的引用(就像把数据的owner从一个goroutine传递给另外一个goroutine), <a href="http://golang.org/doc/effective_go.html" target="_blank" rel="external">Effective Go</a>总结了这么一句话：</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<p>在 <a href="https://golang.org/ref/mem" target="_blank" rel="external">Go内存模型</a>指出了channel作为并发控制的一个特性：</p>
<blockquote>
<p>A send on a channel happens before the corresponding receive from that channel completes. (Golang Spec)</p>
</blockquote>
<p>除了正常的在goroutine之间安全地传递共享数据， Channel还可以玩出很多的花样(模式)， 本文列举了一些channel的应用模式。</p>
<p>促成本文诞生的因素主要包括：</p>
<ol>
<li>eapache的channels库</li>
<li>concurrency in go 这本书</li>
<li>Francesc Campoy的 justforfun系列中关于merge channel的实现</li>
<li>我在出版Scala集合手册这本书中对Scala集合的启发</li>
</ol>
<p>下面就让我们以实例的方式看看这么模式吧。</p>
<a id="more"></a>
<h2 id="Lock/TryLock_模式">Lock/TryLock 模式</h2>
<p>我们知道， Go的标准库<code>sync</code>有<code>Mutex</code>,可以用来作为锁，但是<code>Mutex</code>却没有实现<code>TryLock</code>方法。</p>
<p>我们对于<code>TryLock</code>的定义是当前goroutine尝试获得锁， 如果成功，则获得了锁，返回true, 否则返回false。我们可以使用这个方法避免在获取锁的时候当前goroutine被阻塞住。</p>
<p>本来，这是一个常用的功能，在一些其它编程语言中都有实现，为什么Go中没有实现的？<a href="https://github.com/golang/go/issues/6123" target="_blank" rel="external">issue#6123</a>有详细的讨论，在我看来，Go核心组成员本身对这个特性没有积极性，并且认为通过channel可以实现相同的方式。</p>
<h3 id="Hacked_Lock/TryLock_模式">Hacked Lock/TryLock 模式</h3>
<p>其实，对于标准库的<code>sync.Mutex</code>要增加这个功能很简单，下面的方式就是通过<code>hack</code>的方式为<code>Mutex</code>实现了<code>TryLock</code>的功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mutexLocked =<span class="number"> 1</span> &lt;&lt; <span class="constant">iota</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> {</div><div class="line">	mu sync.Mutex</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) Lock() {</div><div class="line">	m.mu.Lock()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) Unlock() {</div><div class="line">	m.mu.Unlock()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> atomic.CompareAndSwapInt32((*<span class="typename">int32</span>)(unsafe.Pointer(&m.mu)),<span class="number"> 0</span>, mutexLocked)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) IsLocked() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> atomic.LoadInt32((*<span class="typename">int32</span>)(unsafe.Pointer(&m.mu))) == mutexLocked</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你看一下<code>Mutex</code>实现的源代码，就很容易理解上面的这段代码了，因为<code>mutex</code>实现锁主要利用<code>CAS</code>对它的一个int32字段做操作。</p>
<p>上面的代码还额外增加了一个<code>IsLocked</code>方法，不过这个方法一般不常用，因为查询和加锁这两个方法执行的时候不是一个原子的操作，素以这个方法一般在调试和打日志的时候可能有用。</p>
<h3 id="TryLock_By_Channel">TryLock By Channel</h3>
<p>既然标准库中不准备在<code>Mutex</code>上增加这个方法，而是推荐使用channel来实现，那么就让我们看看如何使用 channel来实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> {</div><div class="line">	ch <span class="keyword">chan</span> <span class="keyword">struct</span>{}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> NewMutex() *Mutex {</div><div class="line">	mu := &Mutex{<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 1</span>)}</div><div class="line">	mu.ch &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">	<span class="keyword">return</span> mu</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) Lock() {</div><div class="line">	&lt;-m.ch</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) Unlock() {</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> m.ch &lt;- <span class="keyword">struct</span>{}{}:</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"unlock of unlocked mutex"</span>)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> &lt;-m.ch:</div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) IsLocked() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(m.ch) ==<span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>主要是利用channel边界情况下的阻塞特性实现的。</p>
<p>你还可以将缓存的大小从1改为n,用来处理n个锁(资源)。</p>
<h3 id="TryLock_with_Timeout">TryLock with Timeout</h3>
<p>有时候，我们在获取一把锁的时候，由于有竞争的关系，在锁被别的goroutine拥有的时候，当前goroutine没有办法立即获得锁，只能阻塞等待。标准库并没有提供等待超时的功能，我们尝试实现它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> {</div><div class="line">	ch <span class="keyword">chan</span> <span class="keyword">struct</span>{}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> NewMutex() *Mutex {</div><div class="line">	mu := &Mutex{<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 1</span>)}</div><div class="line">	mu.ch &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">	<span class="keyword">return</span> mu</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) Lock() {</div><div class="line">	&lt;-m.ch</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) Unlock() {</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> m.ch &lt;- <span class="keyword">struct</span>{}{}:</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"unlock of unlocked mutex"</span>)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) TryLock(timeout time.Duration) <span class="typename">bool</span> {</div><div class="line">	timer := time.NewTimer(timeout)</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> &lt;-m.ch:</div><div class="line">		timer.Stop()</div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	<span class="keyword">case</span> &lt;-time.After(timeout):</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) IsLocked() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(m.ch) ==<span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>你也可以把它用<code>Context</code>来改造，不是利用超时，而是利用<code>Context</code>来取消/超时获得锁的操作，这个作业留给读者来实现。</p>
<h2 id="Or_Channel_模式">Or Channel 模式</h2>
<p>当你等待多个信号的时候，如果收到任意一个信号， 就执行业务逻辑，忽略其它的还未收到的信号。</p>
<p>举个例子， 我们往提供相同服务的n个节点发送请求，只要任意一个服务节点返回结果，我们就可以执行下面的业务逻辑，其它n-1的节点的请求可以被取消或者忽略。当n=2的时候，这就是<code>back request</code>模式。 这样可以用资源来换取latency的提升。</p>
<p>需要注意的是，当收到任意一个信号的时候，<strong>其它信号都被忽略</strong>。如果用channel来实现，只要从任意一个channel中接收到一个数据，那么所有的channel都可以被关闭了(依照你的实现，但是输出的channel肯定会被关闭)。</p>
<p>有三种实现的方式: goroutine、reflect和递归。</p>
<h3 id="Goroutine方式">Goroutine方式</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> or(chans ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">var</span> once sync.Once</div><div class="line">		<span class="keyword">for</span> _, c := <span class="keyword">range</span> chans {</div><div class="line">			<span class="keyword">go</span> <span class="keyword">func</span>(c &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) {</div><div class="line">				<span class="keyword">select</span> {</div><div class="line">				<span class="keyword">case</span> &lt;-c:</div><div class="line">					once.Do(<span class="keyword">func</span>() { <span class="built_in">close</span>(out) })</div><div class="line">				<span class="keyword">case</span> &lt;-out:</div><div class="line">				}</div><div class="line">			}(c)</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> out</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>or</code>函数可以处理n个channel,它为每个channel启动一个goroutine，只要任意一个goroutine从channel读取到数据，输出的channel就被关闭掉了。</p>
<p>为了避免并发关闭输出channel的问题，关闭操作只执行一次。</p>
<h3 id="Reflect方式">Reflect方式</h3>
<p>Go的反射库针对select语句有专门的数据(<code>reflect.SelectCase</code>)和函数(<code>reflect.Select</code>)处理。<br>所以我们可以利用反射“随机”地从一组可选的channel中接收数据，并关闭输出channel。</p>
<p>这种方式看起来更简洁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> or(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	<span class="keyword">switch</span> <span class="built_in">len</span>(channels) {</div><div class="line">	<span class="keyword">case</span><span class="number"> 0</span>:</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">	<span class="keyword">case</span><span class="number"> 1</span>:</div><div class="line">		<span class="keyword">return</span> channels<span class="number">[0</span>]</div><div class="line">	}</div><div class="line"></div><div class="line">	orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</div><div class="line">		<span class="keyword">var</span> cases []reflect.SelectCase</div><div class="line">		<span class="keyword">for</span> _, c := <span class="keyword">range</span> channels {</div><div class="line">			cases = <span class="built_in">append</span>(cases, reflect.SelectCase{</div><div class="line">				Dir:  reflect.SelectRecv,</div><div class="line">				Chan: reflect.ValueOf(c),</div><div class="line">			})</div><div class="line">		}</div><div class="line"></div><div class="line">		reflect.Select(cases)</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> orDone</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="递归方式">递归方式</h3>
<p>递归方式一向是比较开脑洞的实现，下面的方式就是分而治之的方式，逐步合并channel，最终返回一个channel。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> or(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	<span class="keyword">switch</span> <span class="built_in">len</span>(channels) {</div><div class="line">	<span class="keyword">case</span><span class="number"> 0</span>:</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">	<span class="keyword">case</span><span class="number"> 1</span>:</div><div class="line">		<span class="keyword">return</span> channels<span class="number">[0</span>]</div><div class="line">	}</div><div class="line"></div><div class="line">	orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</div><div class="line"></div><div class="line">		<span class="keyword">switch</span> <span class="built_in">len</span>(channels) {</div><div class="line">		<span class="keyword">case</span><span class="number"> 2</span>:</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-channels<span class="number">[0</span>]:</div><div class="line">			<span class="keyword">case</span> &lt;-channels<span class="number">[1</span>]:</div><div class="line">			}</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			m := <span class="built_in">len</span>(channels) /<span class="number"> 2</span></div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-or(channels[:m]...):</div><div class="line">			<span class="keyword">case</span> &lt;-or(channels[m:]...):</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> orDone</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在后面的扇入(合并)模式中，我们还是会使用相同样的递归模式来合并多个输入channel，根据 justforfun 的测试结果，这种递归的方式要比goroutine、Reflect更有效。</p>
<h2 id="Or-Done-Channel模式">Or-Done-Channel模式</h2>
<p>这种模式是我们经常使用的一种模式，通过一个信号channel(done)来控制(取消)输入channel的处理。</p>
<p>一旦从done channel中读取到一个信号，或者done channel被关闭， 输入channel的处理则被取消。</p>
<p>这个模式提供一个简便的方法，把done channel 和 输入 channel 融合成一个输出channel。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> orDone(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, c &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	valStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(valStream)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> v, ok := &lt;-c:</div><div class="line">				<span class="keyword">if</span> ok == <span class="constant">false</span> {</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				<span class="keyword">select</span> {</div><div class="line">				<span class="keyword">case</span> valStream &lt;- v:</div><div class="line">				<span class="keyword">case</span> &lt;-done:</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> valStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="扇入模式">扇入模式</h2>
<p>扇入模式(FanIn)是将多个同样类型的输入channel合并成一个同样类型的输出channel，也就是channel的合并。</p>
<h3 id="Goroutine方式-1">Goroutine方式</h3>
<p>每个channel起一个goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fanIn(chans ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">		wg.Add(<span class="built_in">len</span>(chans))</div><div class="line"></div><div class="line">		<span class="keyword">for</span> _, c := <span class="keyword">range</span> chans {</div><div class="line">			<span class="keyword">go</span> <span class="keyword">func</span>(c &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) {</div><div class="line">				<span class="keyword">for</span> v := <span class="keyword">range</span> c {</div><div class="line">					out &lt;- v</div><div class="line">				}</div><div class="line">				wg.Done()</div><div class="line">			}(c)</div><div class="line">		}</div><div class="line"></div><div class="line">		wg.Wait()</div><div class="line">		<span class="built_in">close</span>(out)</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> out</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Reflect">Reflect</h3>
<p>利用反射库针对select语句的处理合并输入channel。</p>
<p>下面这种实现方式其实还是有些问题的， 在输入channel读取比较均匀的时候比较有效，否则性能比较低下。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">func fanInReflect(chans <span class="keyword">...</span>&lt;-chan interface{}) &lt;-chan interface{} {</div><div class="line">	out := make(chan interface{})</div><div class="line">	go func() {</div><div class="line">		defer close(out)</div><div class="line">		var cases []reflect.SelectCase</div><div class="line">		<span class="keyword">for</span> _, c := range chans {</div><div class="line">			cases = append(cases, reflect.SelectCase{</div><div class="line">				Dir:  reflect.SelectRecv,</div><div class="line">				Chan: reflect.ValueOf(c),</div><div class="line">			})</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">for</span> len(cases) &gt; <span class="number">0</span> {</div><div class="line">			i, v, ok := reflect.Select(cases)</div><div class="line">			<span class="keyword">if</span> !ok { //remove this case</div><div class="line">				cases = append(cases[:i], cases[i+<span class="number">1</span>:]<span class="keyword">...</span>)</div><div class="line">				continue</div><div class="line">			}</div><div class="line">			out &lt;- v.Interface()</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> out</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="递归方式-1">递归方式</h3>
<p>这种方式虽然理解起来不直观，但是性能还是不错的(输入channel不是很多的情况下递归层级不会很高，不会成为瓶颈)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fanInRec(chans ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	<span class="keyword">switch</span> <span class="built_in">len</span>(chans) {</div><div class="line">	<span class="keyword">case</span><span class="number"> 0</span>:</div><div class="line">		c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">		<span class="built_in">close</span>(c)</div><div class="line">		<span class="keyword">return</span> c</div><div class="line">	<span class="keyword">case</span><span class="number"> 1</span>:</div><div class="line">		<span class="keyword">return</span> chans<span class="number">[0</span>]</div><div class="line">	<span class="keyword">case</span><span class="number"> 2</span>:</div><div class="line">		<span class="keyword">return</span> mergeTwo(chans<span class="number">[0</span>], chans<span class="number">[1</span>])</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		m := <span class="built_in">len</span>(chans) /<span class="number"> 2</span></div><div class="line">		<span class="keyword">return</span> mergeTwo(</div><div class="line">			fanInRec(chans[:m]...),</div><div class="line">			fanInRec(chans[m:]...))</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> mergeTwo(a, b &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(c)</div><div class="line">		<span class="keyword">for</span> a != <span class="constant">nil</span> || b != <span class="constant">nil</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> v, ok := &lt;-a:</div><div class="line">				<span class="keyword">if</span> !ok {</div><div class="line">					a = <span class="constant">nil</span></div><div class="line">					<span class="keyword">continue</span></div><div class="line">				}</div><div class="line">				c &lt;- v</div><div class="line">			<span class="keyword">case</span> v, ok := &lt;-b:</div><div class="line">				<span class="keyword">if</span> !ok {</div><div class="line">					b = <span class="constant">nil</span></div><div class="line">					<span class="keyword">continue</span></div><div class="line">				}</div><div class="line">				c &lt;- v</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> c</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tee模式">Tee模式</h2>
<p>扇出模式(FanOut)是将一个输入channel扇出为多个channel。</p>
<p>扇出行为至少可以分为两种：</p>
<ol>
<li>从输入channel中读取一个数据，发送给每个输入channel，这种模式称之为Tee模式</li>
<li>从输入channel中读取一个数据，在输出channel中选择一个channel发送</li>
</ol>
<p>本节只介绍第一种情况，下一节介绍第二种情况</p>
<h3 id="Goroutine方式-2">Goroutine方式</h3>
<p>将读取的值发送给每个输出channel， 异步模式可能会产生很多的goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fanOut(ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, out []<span class="keyword">chan</span> <span class="keyword">interface</span>{}, async <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(out); i++ {</div><div class="line">				<span class="built_in">close</span>(out[i])</div><div class="line">			}</div><div class="line">		}()</div><div class="line"></div><div class="line">		<span class="keyword">for</span> v := <span class="keyword">range</span> ch {</div><div class="line">			v := v</div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(out); i++ {</div><div class="line">				i := i</div><div class="line">				<span class="keyword">if</span> async {</div><div class="line">					<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">						out[i] &lt;- v</div><div class="line">					}()</div><div class="line">				} <span class="keyword">else</span> {</div><div class="line">					out[i] &lt;- v</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Reflect方式-1">Reflect方式</h3>
<p>这种模式一旦一个输出channel被阻塞，可能会导致后续的处理延迟。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fanOutReflect(ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, out []<span class="keyword">chan</span> <span class="keyword">interface</span>{}) {</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(out); i++ {</div><div class="line">				<span class="built_in">close</span>(out[i])</div><div class="line">			}</div><div class="line">		}()</div><div class="line"></div><div class="line">		cases := <span class="built_in">make</span>([]reflect.SelectCase, <span class="built_in">len</span>(out))</div><div class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> cases {</div><div class="line">			cases[i].Dir = reflect.SelectSend</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">for</span> v := <span class="keyword">range</span> ch {</div><div class="line">			v := v</div><div class="line">			<span class="keyword">for</span> i := <span class="keyword">range</span> cases {</div><div class="line">				cases[i].Chan = reflect.ValueOf(out[i])</div><div class="line">				cases[i].Send = reflect.ValueOf(v)</div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="keyword">for</span> _ = <span class="keyword">range</span> cases { <span class="comment">// for each channel</span></div><div class="line">				chosen, _, _ := reflect.Select(cases)</div><div class="line">				cases[chosen].Chan = reflect.ValueOf(<span class="constant">nil</span>)</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="分布模式">分布模式</h2>
<p>分布模式将从输入channel中读取的值往输出channel中的其中一个发送。</p>
<h3 id="Goroutine方式-3">Goroutine方式</h3>
<p>roundrobin的方式选择输出channel。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fanOut(ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, out []<span class="keyword">chan</span> <span class="keyword">interface</span>{}) {</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(out); i++ {</div><div class="line">				<span class="built_in">close</span>(out[i])</div><div class="line">			}</div><div class="line">		}()</div><div class="line"></div><div class="line">		<span class="comment">// roundrobin</span></div><div class="line">		<span class="keyword">var</span> i =<span class="number"> 0</span></div><div class="line">		<span class="keyword">var</span> n = <span class="built_in">len</span>(out)</div><div class="line">		<span class="keyword">for</span> v := <span class="keyword">range</span> ch {</div><div class="line">			v := v</div><div class="line">			out[i] &lt;- v</div><div class="line">			i = (i +<span class="number"> 1</span>) % n</div><div class="line">		}</div><div class="line">	}()</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Reflect方式-2">Reflect方式</h3>
<p>利用发射随机的选择。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fanOutReflect(ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, out []<span class="keyword">chan</span> <span class="keyword">interface</span>{}) {</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(out); i++ {</div><div class="line">				<span class="built_in">close</span>(out[i])</div><div class="line">			}</div><div class="line">		}()</div><div class="line"></div><div class="line">		cases := <span class="built_in">make</span>([]reflect.SelectCase, <span class="built_in">len</span>(out))</div><div class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> cases {</div><div class="line">			cases[i].Dir = reflect.SelectSend</div><div class="line">			cases[i].Chan = reflect.ValueOf(out[i])</div><div class="line"></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">for</span> v := <span class="keyword">range</span> ch {</div><div class="line">			v := v</div><div class="line">			<span class="keyword">for</span> i := <span class="keyword">range</span> cases {</div><div class="line">				cases[i].Send = reflect.ValueOf(v)</div><div class="line">			}</div><div class="line">			_, _, _ = reflect.Select(cases)</div><div class="line">		}</div><div class="line">	}()</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="eapache">eapache</h2>
<p><a href="https://github.com/eapache/channels" target="_blank" rel="external">eapache/channels</a>提供了一些channel应用模式的方法，比如上面的扇入扇出模式等。</p>
<p>因为go本身的channel无法再进行扩展， <code>eapache/channels</code>库定义了自己的channel接口，并提供了与channel方便的转换。</p>
<p><code>eapache/channels</code> 提供了四个方法:</p>
<ul>
<li>Distribute： 从输入channel读取值，发送到其中一个输出channel中。当输入channel关闭后，输出channel都被关闭</li>
<li>Tee: 从输入channel读取值，发送到所有的输出channel中。当输入channel关闭后，输出channel都被关闭</li>
<li>Multiplex: 合并输入channel为一个输出channel， 当所有的输入都关闭后，输出才关闭</li>
<li>Pipe: 将两个channel串起来</li>
</ul>
<p>同时对上面的四个函数还提供了<code>WeakXXX</code>的函数，输入关闭后不会关闭输出。</p>
<p>下面看看对应的函数的例子。</p>
<h3 id="Distribute">Distribute</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> testDist() {</div><div class="line">	fmt.Println(<span class="string">"dist:"</span>)</div><div class="line">	a := channels.NewNativeChannel(channels.None)</div><div class="line">	outputs := []channels.Channel{</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">	}</div><div class="line"></div><div class="line">	channels.Distribute(a, outputs<span class="number">[0</span>], outputs<span class="number">[1</span>], outputs<span class="number">[2</span>], outputs<span class="number">[3</span>])</div><div class="line">	<span class="comment">//channels.WeakDistribute(a, outputs[0], outputs[1], outputs[2], outputs[3])</span></div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 5</span>; i++ {</div><div class="line">			a.In() &lt;- i</div><div class="line">		}</div><div class="line">		a.Close()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 6</span>; i++ {</div><div class="line">		<span class="keyword">var</span> v <span class="keyword">interface</span>{}</div><div class="line">		<span class="keyword">var</span> j <span class="typename">int</span></div><div class="line">		<span class="keyword">select</span> {</div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[0</span>].Out():</div><div class="line">			j =<span class="number"> 0</span></div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[1</span>].Out():</div><div class="line">			j =<span class="number"> 1</span></div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[2</span>].Out():</div><div class="line">			j =<span class="number"> 2</span></div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[3</span>].Out():</div><div class="line">			j =<span class="number"> 3</span></div><div class="line">		}</div><div class="line">		fmt.Printf(<span class="string">"channel#%d: %d\n"</span>, j, v)</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Tee">Tee</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> testTee() {</div><div class="line">	fmt.Println(<span class="string">"tee:"</span>)</div><div class="line">	a := channels.NewNativeChannel(channels.None)</div><div class="line">	outputs := []channels.Channel{</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">	}</div><div class="line"></div><div class="line">	channels.Tee(a, outputs<span class="number">[0</span>], outputs<span class="number">[1</span>], outputs<span class="number">[2</span>], outputs<span class="number">[3</span>])</div><div class="line">	<span class="comment">//channels.WeakTee(a, outputs[0], outputs[1], outputs[2], outputs[3])</span></div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 5</span>; i++ {</div><div class="line">			a.In() &lt;- i</div><div class="line">		}</div><div class="line">		a.Close()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 20</span>; i++ {</div><div class="line">		<span class="keyword">var</span> v <span class="keyword">interface</span>{}</div><div class="line">		<span class="keyword">var</span> j <span class="typename">int</span></div><div class="line">		<span class="keyword">select</span> {</div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[0</span>].Out():</div><div class="line">			j =<span class="number"> 0</span></div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[1</span>].Out():</div><div class="line">			j =<span class="number"> 1</span></div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[2</span>].Out():</div><div class="line">			j =<span class="number"> 2</span></div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[3</span>].Out():</div><div class="line">			j =<span class="number"> 3</span></div><div class="line">		}</div><div class="line">		fmt.Printf(<span class="string">"channel#%d: %d\n"</span>, j, v)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Multiplex">Multiplex</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> testMulti() {</div><div class="line">	fmt.Println(<span class="string">"multi:"</span>)</div><div class="line">	a := channels.NewNativeChannel(channels.None)</div><div class="line">	inputs := []channels.Channel{</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">	}</div><div class="line"></div><div class="line">	channels.Multiplex(a, inputs<span class="number">[0</span>], inputs<span class="number">[1</span>], inputs<span class="number">[2</span>], inputs<span class="number">[3</span>])</div><div class="line">	<span class="comment">//channels.WeakMultiplex(a, inputs[0], inputs[1], inputs[2], inputs[3])</span></div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 5</span>; i++ {</div><div class="line">			<span class="keyword">for</span> j := <span class="keyword">range</span> inputs {</div><div class="line">				inputs[j].In() &lt;- i</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> inputs {</div><div class="line">			inputs[i].Close()</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> a.Out() {</div><div class="line">		fmt.Printf(<span class="string">"%d "</span>, v)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Pipe">Pipe</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> testPipe() {</div><div class="line">	fmt.Println(<span class="string">"pipe:"</span>)</div><div class="line">	a := channels.NewNativeChannel(channels.None)</div><div class="line">	b := channels.NewNativeChannel(channels.None)</div><div class="line"></div><div class="line">	channels.Pipe(a, b)</div><div class="line">	<span class="comment">// channels.WeakPipe(a, b)</span></div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 5</span>; i++ {</div><div class="line">			a.In() &lt;- i</div><div class="line">		}</div><div class="line">		a.Close()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> b.Out() {</div><div class="line">		fmt.Printf(<span class="string">"%d "</span>, v)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="集合操作">集合操作</h2>
<p>从channel的行为来看，它看起来很像一个数据流，所以我们可以实现一些类似Scala 集合的操作。</p>
<p>Scala的集合类提供了丰富的操作(方法)， 当然其它的一些编程语言或者框架也提供了类似的方法， 比如Apache Spark、Java Stream、ReactiveX等。</p>
<p>下面列出了一些方法的实现，我相信经过一些人的挖掘，相关的方法可以变成一个很好的类库，但是目前我们先看一些例子。</p>
<h3 id="skip">skip</h3>
<p>skip函数是从一个channel中跳过开一些数据，然后才开始读取。</p>
<h4 id="skipN">skipN</h4>
<p>skipN跳过开始的N个数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> skipN(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, num <span class="typename">int</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; num; i++ {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> &lt;-valueStream:</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> takeStream &lt;- &lt;-valueStream:</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> takeStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="skipFn">skipFn</h4>
<p>skipFn 提供Fn函数为true的数据，比如跳过偶数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> skipFn(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, fn <span class="keyword">func</span>(<span class="keyword">interface</span>{}) <span class="typename">bool</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> v := &lt;-valueStream:</div><div class="line">				<span class="keyword">if</span> !fn(v) {</div><div class="line">					takeStream &lt;- v</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> takeStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="skipWhile">skipWhile</h4>
<p>跳过开头函数fn为true的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> skipWhile(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, fn <span class="keyword">func</span>(<span class="keyword">interface</span>{}) <span class="typename">bool</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</div><div class="line">		take := <span class="constant">false</span></div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> v := &lt;-valueStream:</div><div class="line">				<span class="keyword">if</span> !take {</div><div class="line">					take = !fn(v)</div><div class="line">					<span class="keyword">if</span> !take {</div><div class="line">						<span class="keyword">continue</span></div><div class="line">					}</div><div class="line">				}</div><div class="line">				takeStream &lt;- v</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> takeStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="take">take</h3>
<p>skip的反向操作，读取一部分数据。</p>
<h4 id="takeN">takeN</h4>
<p>takeN 读取开头N个数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> takeN(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, num <span class="typename">int</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; num; i++ {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> takeStream &lt;- &lt;-valueStream:</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> takeStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="takeFn">takeFn</h4>
<p>takeFn 只筛选满足fn的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> takeFn(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, fn <span class="keyword">func</span>(<span class="keyword">interface</span>{}) <span class="typename">bool</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> v := &lt;-valueStream:</div><div class="line">				<span class="keyword">if</span> fn(v) {</div><div class="line">					takeStream &lt;- v</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> takeStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="takeWhile">takeWhile</h4>
<p>takeWhile只挑选开头满足fn的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> takeWhile(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, fn <span class="keyword">func</span>(<span class="keyword">interface</span>{}) <span class="typename">bool</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> v := &lt;-valueStream:</div><div class="line">				<span class="keyword">if</span> !fn(v) {</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				takeStream &lt;- v</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> takeStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="flat">flat</h3>
<p>平展(flat)操作是一个有趣的操作。</p>
<p>如果输入是一个channel,channel中的数据还是相同类型的channel， 那么flat将返回一个输出channel,输出channel中的数据是输入的各个channel中的数据。</p>
<p>它与扇入不同，扇入的输入channel在调用的时候就是固定的，并且以数组的方式提供，而flat的输入是一个channel，可以运行时随时的加入channel。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> orDone(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, c &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	valStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(valStream)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> v, ok := &lt;-c:</div><div class="line">				<span class="keyword">if</span> ok == <span class="constant">false</span> {</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				<span class="keyword">select</span> {</div><div class="line">				<span class="keyword">case</span> valStream &lt;- v:</div><div class="line">				<span class="keyword">case</span> &lt;-done:</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> valStream</div><div class="line">}</div><div class="line"><span class="keyword">func</span> flat(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, chanStream &lt;-<span class="keyword">chan</span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	valStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(valStream)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">var</span> stream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> maybeStream, ok := &lt;-chanStream:</div><div class="line">				<span class="keyword">if</span> ok == <span class="constant">false</span> {</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				stream = maybeStream</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			}</div><div class="line">			<span class="keyword">for</span> val := <span class="keyword">range</span> orDone(done, stream) {</div><div class="line">				<span class="keyword">select</span> {</div><div class="line">				<span class="keyword">case</span> valStream &lt;- val:</div><div class="line">				<span class="keyword">case</span> &lt;-done:</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> valStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="map">map</h3>
<p>map和reduce是一组常用的操作。</p>
<p>map将一个channel映射成另外一个channel， channel的类型可以不同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> mapChan(in &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, fn <span class="keyword">func</span>(<span class="keyword">interface</span>{}) <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">if</span> in == <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">close</span>(out)</div><div class="line">		<span class="keyword">return</span> out</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(out)</div><div class="line"></div><div class="line">		<span class="keyword">for</span> v := <span class="keyword">range</span> in {</div><div class="line">			out &lt;- fn(v)</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> out</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为<code>map</code>是go的关键字，所以我们不能命名函数类型为<code>map</code>,这里用<code>mapChan</code>代替。</p>
<p>比如你可以处理一个公司员工工资的channel， 输出一个扣税之后的员工工资的channel。</p>
<h3 id="reduce">reduce</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> reduce(in &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, fn <span class="keyword">func</span>(r, v <span class="keyword">interface</span>{}) <span class="keyword">interface</span>{}) <span class="keyword">interface</span>{} {</div><div class="line">	<span class="keyword">if</span> in == <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">	}</div><div class="line"></div><div class="line">	out := &lt;-in</div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> in {</div><div class="line">		out = fn(out, v)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> out</div><div class="line">}</div><div class="line"></div><div class="line">你可以用<span class="string">`reduce`</span>实现<span class="string">`sum`</span>、<span class="string">`max`</span>、<span class="string">`min`</span>等聚合操作。</div></pre></td></tr></table></figure>

<h2 id="总结">总结</h2>
<p>本文列出了channel的一些深入应用的模式，相信通过阅读本文，你可以更加深入的了解Go的channel类型，并在开发中灵活的应用channel。也欢迎你在评论中提出更多的 channel的应用模式。</p>
<p>所有的代码可以在github上找到: <a href="https://github.com/smallnest/channels" target="_blank" rel="external">smallnest/channels</a>。</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://github.com/kat-co/concurrency-in-go-src" target="_blank" rel="external">https://github.com/kat-co/concurrency-in-go-src</a></li>
<li><a href="https://github.com/campoy/justforfunc/tree/master/27-merging-chans" target="_blank" rel="external">https://github.com/campoy/justforfunc/tree/master/27-merging-chans</a></li>
<li><a href="https://github.com/eapache/channels" target="_blank" rel="external">https://github.com/eapache/channels</a></li>
<li><a href="https://github.com/LK4D4/trylock" target="_blank" rel="external">https://github.com/LK4D4/trylock</a></li>
<li><a href="https://stackoverflow.com/questions/36391421/explain-dont-communicate-by-sharing-memory-share-memory-by-communicating" target="_blank" rel="external">https://stackoverflow.com/questions/36391421/explain-dont-communicate-by-sharing-memory-share-memory-by-communicating</a></li>
<li><a href="https://github.com/lrita/gosync" target="_blank" rel="external">https://github.com/lrita/gosync</a></li>
<li><a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html" target="_blank" rel="external">https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html</a> </li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Channel是Go中的一种类型，和goroutine一起为Go提供了并发技术， 它在开发中得到了广泛的应用。Go鼓励人们通过Channel在goroutine之间传递数据的引用(就像把数据的owner从一个goroutine传递给另外一个goroutine), <a href="http://golang.org/doc/effective_go.html" target="_blank" rel="external">Effective Go</a>总结了这么一句话：</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<p>在 <a href="https://golang.org/ref/mem" target="_blank" rel="external">Go内存模型</a>指出了channel作为并发控制的一个特性：</p>
<blockquote>
<p>A send on a channel happens before the corresponding receive from that channel completes. (Golang Spec)</p>
</blockquote>
<p>除了正常的在goroutine之间安全地传递共享数据， Channel还可以玩出很多的花样(模式)， 本文列举了一些channel的应用模式。</p>
<p>促成本文诞生的因素主要包括：</p>
<ol>
<li>eapache的channels库</li>
<li>concurrency in go 这本书</li>
<li>Francesc Campoy的 justforfun系列中关于merge channel的实现</li>
<li>我在出版Scala集合手册这本书中对Scala集合的启发</li>
</ol>
<p>下面就让我们以实例的方式看看这么模式吧。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DHT 分布式哈希表]]></title>
    <link href="https://colobu.com/2018/03/26/distributed-hash-table/"/>
    <id>https://colobu.com/2018/03/26/distributed-hash-table/</id>
    <published>2018-03-26T08:02:45.000Z</published>
    <updated>2018-03-26T10:36:13.842Z</updated>
    <content type="html"><![CDATA[<p>本文主要整理维基百科中英文和百度百科等资料，算是对 <code>DHT</code> 技术做一个综述，基本都是摘自参考资料中的文档。</p>
<a id="more"></a>
<h2 id="DHT">DHT</h2>
<p><img src="DHT.png" alt=""></p>
<p>分布式哈希表（distributed hash table，缩写DHT）是分布式计算系统中的一类，用来将一个键（key）的集合分散到所有在分布式系统中的节点。这里的节点类似哈希表中的存储位置。分布式哈希表通常是为了拥有大量节点的系统，而且系统的节点常常会加入或离开。</p>
<p>研究分布式哈希表的主要动机是为了开发点对点系统，像是Napster、Gnutella、BitTorrent及Freenet。这些系统使用分散在互联网上的各项资源以提供文件分享服务，特别在带宽及硬盘存储空间上受益良多。</p>
<p>这些系统使用不同的方法来解决如何找到拥有某数据的节点的问题。Napster使用中央的索引服务器：每个节点加入网络的同时，会将他们所拥有的文件列表发送给服务器，这使得服务器可以进行搜索并将结果回传给进行查询的节点。但中央索引服务器让整个系统易受攻击，且可能造成法律问题。于是，Gnutella和相似的网络改用大量查询模式（flooding query model）：每次搜索都会把查询消息广播给网络上的所有节点。虽然这个方式能够防止单点故障（single point of failure），但比起Napster来说却极没效率。</p>
<p>最后，Freenet使用了完全分布式的系统，但它建置了一套使用经验法则的基于键的路由方法（key based routing）。在这个方法中，每个文件与一个键相结合，而拥有相似键的文件会倾向被相似的节点构成的集合所保管。于是查询消息就可以根据它所提供的键被路由到该集合，而不需要经过所有的节点。然而，Freenet并不保证存在网络上的数据在查询时一定会被找到。</p>
<p>分布式哈希表为了达到Gnutella与Freenet的分散性（decentralization）以及Napster的效率与正确结果，使用了较为结构化的基于键的路由方法。不过分布式哈希表也有个Freenet有的缺点，就是只能作精确搜索，而不能只提供部分的关键字；但这个功能可以在分布式哈希表的上层实现。</p>
<p>最初的四项分布式哈希表技术——内容可定址网络（Content addressable network，CAN）、Chord（Chord project）、Pastry（Pastry (DHT)），以及Tapestry (DHT)（Tapestry (DHT)）皆同时于2001年发表。从那时开始，相关的研究便一直十分活跃。在学术领域以外，分布式哈希表技术已经被应用在BitTorrent及CoralCDN（Coral Content Distribution Network）等。</p>
<p>分布式散列表本质上强调以下特性：</p>
<ul>
<li><strong>离散性</strong>：构成系统的节点并没有任何中央式的协调机制。</li>
<li><strong>伸缩性</strong>：即使有成千上万个节点，系统仍然应该十分有效率。</li>
<li><strong>容错性</strong>：即使节点不断地加入、离开或是停止工作，系统仍然必须达到一定的可靠度。</li>
</ul>
<p>要达到以上的目标，有一个关键的技术：任一个节点只需要与系统中的部分节点沟通，当成员改变的时候，只有一部分的工作（例如数据或键的发送，哈希表的改变等）必须要完成。</p>
<p>分布式散列表的结构可以分成几个主要的组件。其基础是一个抽象的<code>键空间</code>（keyspace），例如说所有<strong>160</strong>位长的字符串集合。<code>键空间分区</code>（keyspace partitioning）将<code>键空间</code>分区成数个，并指定到在此系统的节点中。而<code>延展网络</code>则连接这些节点，并让他们能够借由在<code>键空间</code>内的任一值找到拥有该值的节点。</p>
<p>假设<code>键空间</code>是一个160位长的字符串集合。为了在分布式散列表中存储一个文件，名称为<code>filename</code>且内容为<code>data</code>，我们计算出<code>filename</code>的SHA1散列值——一个160位的键<code>k</code>——并将消息<code>put(k,data)</code>送给分布式散列表中的任意参与节点。此消息在延展网络中被路由，直到抵达在键空间分区中被指定负责存储关键值<code>k</code>的节点。而<code>(k,data)</code>即存储在该节点。其他的节点只需要重新计算<code>filename</code>的散列值<code>k</code>，然后提交消息<code>get(k)</code>给分布式哈希表中的任意参与节点，以此来找与<code>k</code>相关的数据。此消息也会在延展网络中被路由到负责存储<code>k</code>的节点。而此节点则会负责传回存储的数据<code>data</code>。</p>
<p>基本上，就是一种映射key和节点的算法以及路由的算法。</p>
<p>其一为保证任何的路由路径长度必须尽量短，因而请求能快速地被完成；<br>其二为任一节点的邻近节点数目（又称最大节点度（Degree (graph theory)））必须尽量少，因此维护的花费不会过多。</p>
<h2 id="分布式哈希与一致性哈希">分布式哈希与一致性哈希</h2>
<p>分布式哈希和一致性哈希有什么区别呢？lintong 的<a href="https://www.jianshu.com/p/7beeb52376cc" target="_blank" rel="external">分布式哈希与一致性哈希</a> 一文对它做了清晰而简洁的解释。</p>
<ul>
<li><strong>分布式哈希</strong>: 将哈希表分散在不同的节点上，并且能提供相应的方法来查找， 比如DHT算法</li>
<li><strong>一致性哈希</strong>: 当节点宕机或者扩容的时候，需要重新哈希，一致性哈希实现的 DHT 避免对大量的数据重新哈希, 比如<a href="https://en.wikipedia.org/wiki/Chord_(peer-to-peer" target="_blank" rel="external">Chord DHT</a>). 所以一致性哈希是 DHT 的一种实现，避免在节点变化的时候出现的全部重新哈希的现象. 我不知道为什么wikipedia没有列出memcached client中常用的<a href="https://www.metabrew.com/article/libketama-consistent-hashing-algo-memcached-clients" target="_blank" rel="external">libketama</a>，在我看来它也是一个易于理解的一致性哈希的实现。</li>
</ul>
<p>其它的 DHT 的分区实现(Keyspace partitioning)还有:</p>
<ul>
<li><strong>Rendezvous hashing</strong>: 最高随机权重哈希。每个client都会获得服务节点相同的指示符<code>{S1, S2, ..., Sn }</code>， 对于键<code>k</code>, client使用相同的哈希函数计算服务节点的权重<code>w1 = h(S1, k), w2 = h(S2, k), ..., wn = h(Sn, k)</code>，然后总是选择最高权重的节点。</li>
<li><strong>Locality-preserving hashing</strong>: 相近的键总是指派给相近的对象。</li>
</ul>
<h2 id="Kademlia算法">Kademlia算法</h2>
<p><strong>Kademlia</strong>是一种通过 DHT 的协议算法，它是由Petar和David在2002年为P2P网络而设计的。Kademlia规定了网络的结构，也规定了通过节点查询进行信息交换的方式。<br>Kademlia网络节点之间使用<strong>UDP</strong>进行通讯。参与通讯的所有节点形成一张虚拟网（或者叫做覆盖网）。这些节点通过一组数字（或称为节点ID）来进行身份标识。节点ID不仅可以用来做身份标识，还可以用来进行值定位（值通常是文件的散列或者关键词）。</p>
<p>当我们在网络中搜索某些值（即通常搜索存储文件散列或关键词的节点）的时候，Kademlia算法需要知道与这些值相关的键，然后逐步在网络中开始搜索。每一步都会找到一些节点，这些节点的ID与键更为接近，如果有节点直接返回搜索的值或者再也无法找到与键更为接近的节点ID的时候搜索便会停止。</p>
<p>这种搜索值的方法是非常高效的：与其他的分布式哈希表的实现类似，在一个包含n个节点的系统的值的搜索中，Kademlia仅访问<code>O(log(n))</code>个节点。</p>
<p><code>Kademlia</code>简称为<code>Kad</code>,它使用了一个精妙的算法，来计算节点之间的&quot;距离&quot; (这里的距离不是地理空间的距离，而是路由的跳数)，这个算法就是<code>XOR</code>操作(异或)，因为这个操作和距离的计算类似：</p>
<ul>
<li><code>(A ⊕ B) == (B ⊕ A)</code>:     XOR 符合“交换律”，具备对称性。A和B的距离从哪一个节点计算都是相同的。</li>
<li><code>(A ⊕ A) == 0</code>:    反身性，自己和自己的距离为零。</li>
<li><code>(A ⊕ B) &gt; 0</code>:    两个不同的 key 之间的距离必大于零。</li>
<li><code>(A ⊕ B) + (B ⊕ C) &gt;= (A ⊕ C)</code>:    三角不等式,  A经过B到C的距离总是大于A直接到C的距离。</li>
</ul>
<p>(精妙啊!是如何想起和距离计算联系在一起的？)</p>
<p>Kad使用160位的哈希算法（比如 SHA1），完整的 key 用二进制表示有160位，这样可以容纳2<sup>160</sup>个节点，可以说是不计其数了。</p>
<p>Kad把 key 映射到一个二叉树，每一个 key 都是这个二叉树的<code>叶子</code>。</p>
<h3 id="映射规则"><strong>映射规则</strong></h3>
<ol>
<li>先把 key 以二进制形式表示，然后从高位到低位依次处理。</li>
<li>二进制的第 n 个位就对应了二叉树的第 n 层</li>
<li>如果该位是1，进入左子树，是0则进入右子树（这只是人为约定，反过来处理也可以）</li>
<li>全部位都处理完后，这个 key 就对应了二叉树上的某个叶子</li>
</ol>
<h3 id="二叉树的拆分规则"><strong>二叉树的拆分规则</strong></h3>
<p><img src="kad.png" alt=""></p>
<p>对每一个节点，都可以<strong>按照自己的视角</strong>对整个二叉树进行拆分成最多160个子树。</p>
<p>拆分的规则是：先从根节点开始，把<strong>不包含</strong>自己的那个子树拆分出来；然后在剩下的子树再拆分不包含自己的第二层子树；以此类推，直到最后只剩下自己。</p>
<p>Kad 默认的散列值空间是 <code>m=160</code>（散列值有 160 bit），因此拆分出来的子树<strong>最多</strong>有 160 个（考虑到实际的节点数<strong>远远小于</strong>2<sup>160</sup>，子树的个数会明显小于 160）。</p>
<p>对于每一个节点而言，当它以自己的视角完成子树拆分后，会得到 n 个子树；对于每个子树，如果它都能知道里面的一个节点，那么它就可以利用这 n 个节点进行递归路由，从而到达整个二叉树的<strong>任何一个</strong>节点。</p>
<h3 id="拆子树"><strong>拆子树</strong></h3>
<p>每个节点在完成子树拆分后，只需要知道每个子树里面的一个节点，就足以实现全遍历。但是考虑到健壮性（节点可能宕机或者退出），光知道<strong>一个</strong>显然是不够的，需要知道<strong>多个</strong>才比较保险。</p>
<p>所以 Kad 论文中给出了一个<code>K-桶（K-bucket）</code>的概念。也就是说：每个节点在完成子树拆分后，要记录每个子树里面的 <code>K</code> 个节点。这里所说的 <code>K</code> 值是一个<strong>系统级</strong>的常量。由使用 Kad 的软件系统自己设定（比如 BT 下载使用的 Kad 网络，K 设定为 8）。<br>　　<br><strong>K 桶</strong>其实就是<strong>路由表</strong>。对于某个节点而言，如果<strong>以它自己为视角</strong>拆分了 <strong>n</strong> 个子树，那么它就需要维护 <strong>n</strong> 个路由表，并且每个路由表的<strong>上限</strong>是 K。<br>　<br>说 K 只是一个<strong>上限</strong>，是因为有两种情况使得 K 桶的尺寸会小于 K:</p>
<ol>
<li>距离越近的子树就越小。如果整个子树<strong>可能存在的</strong>节点数小于 K，那么该子树的 K 桶尺寸永远也不可能达到 K。(这是由于K桶对应的距离越近，节点数越少)</li>
<li>有些子树虽然实际上线的节点数超过 K，但是因为种种原因，没有收集到该子树足够多的节点，这也会使得该子树的 K 桶尺寸小于 K。</li>
</ol>
<p>如果选择这 K 个节点呢？<br>Kademlia选择把那些长时间在线的节点存入K桶，这一方法增长了未来某一时刻有效节点的数量，同时也提供了更为稳定的网络。当某个K桶已满，而又发现了相应于该桶的新节点的时候，那么，就首先检查K桶中最早访问的节点，假如该节点仍然存活，那么新节点就被安排到一个附属列表中（作为一个替代缓存）.只有当K桶中的某个节点停止响应的时候，替代cache才被使用。换句话说，新发现的节点只有在老的节点消失后才被使用。</p>
<h3 id="Kademlia协议"><strong>Kademlia协议</strong></h3>
<p>Kademlia协议共有四种消息。</p>
<ul>
<li><strong>PING</strong>消息: 用来测试节点是否仍然在线。</li>
<li><strong>STORE</strong>消息: 在某个节点中存储一个键值对。</li>
<li><strong>FIND_NODE</strong>消息: 消息请求的接收者将返回自己桶中离请求键值最近的K个节点。</li>
<li><strong>FIND_VALUE</strong>消息: 与FIND_NODE一样，不过当请求的接收者存有请求者所请求的键的时候，它将返回相应键的值。</li>
</ul>
<p>每一个RPC消息中都包含一个发起者加入的随机值，这一点确保响应消息在收到的时候能够与前面发送的请求消息匹配。</p>
<h3 id="定位节点"><strong>定位节点</strong></h3>
<p>节点查询可以异步进行，也可以同时进行，同时查询的数量由α表示，一般是3。</p>
<ol>
<li>由查询发起者从自己的k-桶中筛选出若干距离目标ID最近的节点，并向这些节点同时发送异步查询请求；</li>
<li>被查询节点收到请求之后，将从自己的k-桶中找出自己所知道的距离查询目标ID最近的若干个节点，并返回给发起者；</li>
<li>发起者在收到这些返回信息之后，更新自己的结果列表，再次从自己所有已知的距离目标较近的节点中挑选出若干没有请求过的，并重复步骤1；</li>
<li>上述步骤不断重复，直至无法获得比查询者当前已知的k个节点更接近目标的活动节点为止。</li>
<li>在查询过程中，没有及时响应的节点将立即被排除；查询者必须保证最终获得的k个最节点都是活动的。</li>
</ol>
<h3 id="定位资源"><strong>定位资源</strong></h3>
<p>通过把资源信息与键进行映射，资源即可进行定位，杂凑表是典型的用来映射的手段。由于以前的STORE消息，存储节点将会有对应STORE所存储的相关资源的信息。定位资源时，如果一个节点存有相应的资源的值的时候，它就返回该资源，搜索便结束了，除了该点以外，定位资源与定位离键最近的节点的过程相似。</p>
<p>考虑到节点未必都在线的情况，资源的值被存在多个节点上（节点中的K个），并且，为了提供冗余，还有可能在更多的节点上储存值。储存值的节点将定期搜索网络中与储存值所对应的键接近的K个节点并且把值复制到这些节点上，这些节点可作为那些下线的节点的补充。另外还有缓存技术。</p>
<h3 id="加入网络"><strong>加入网络</strong></h3>
<ol>
<li>新节点A必须知道某个引导节点B，并把它加入到自己相应的K-桶中</li>
<li>生成一个随机的节点ID,直到离开网络，该节点会一直使用该ID号</li>
<li>向B（A目前知道的唯一节点）发起一个查询请求（FIND_NODE），请求的ID是自己（就是查询自己）</li>
<li>B收到该请求之后，会先把A的ID加入自己的相应的 K-桶中。并且根据 FIND_NODE 请求的约定，B会找到K个最接近 A 的节点，并返回给 A</li>
<li>A收到这K个节点的ID之后，把他们加入自己的 K-桶</li>
<li>然后A会继续向刚刚拿到的这批节点(还未发送过请求的节点)发送查询请求（协议类型 FIND_NODE），如此往复，直至A建立了足够详细的路由表。</li>
<li>这种“自我定位”将使得Kad的其他节点（收到请求的节点）能够使用A的ID填充他们的K-桶，同时也能够使用那些查询过程的中间节点来填充A的K-桶。这已过程既让A获得了详细的路由表，也让其它节点知道了A节点的加入</li>
</ol>
<h2 id="kad在p2p网络中的应用">kad在p2p网络中的应用</h2>
<p>Kademlia可在文件分享网络中使用，通过制作Kademlia关键字搜索，我们能够在文件分享网络中找到我们需要的文件以供我们下载。由于没有中央服务器存储文件的索引，这部分工作就被平均地分配到所有的客户端中去：</p>
<p>假如一个节点希望分享某个文件，它先根据文件的内容来处理该文件，通过运算，把文件的内容散列成一组数字，该数字在文件分享网络中可被用来标识文件。这组散列数字必须和节点ID有同样的长度，<br>然后，该节点便在网络中搜索ID值与文件的散列值相近的节点，并把它自己的IP地址存储在那些搜索到的节点上，也就是说，它把自己作为文件的源进行了发布。正在进行文件搜索的客户端将使用Kademlia协议来寻找网络上ID值与希望寻找的文件的散列值最近的那个节点，然后取得存储在那个节点上的文件源列表。<br>由于一个键可以对应很多值，即同一个文件可以有多个源，每一个存储源列表的节点可能有不同的文件的源的信息，这样的话，源列表可以从与键值相近的K个节点获得。</p>
<p>文件的散列值通常可以从其他的一些特别的Internet链接的地方获得，或者被包含在从其他某处获得的索引文件中。<br>文件名的搜索可以使用关键词来实现，文件名可以分割成连续的几个关键词，这些关键词都可以散列并且可以和相应的文件名和文件散列储存在网络中。搜索者可以使用其中的某个关键词，联系ID值与关键词散列最近的那个节点，取得包含该关键词的文件列表。由于在文件列表中的文件都有相关的散列值，通过该散列值就可利用上述通常取文件的方法获得要搜索的文件。</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://zh.wikipedia.org/wiki/分散式雜湊表" target="_blank" rel="external">https://zh.wikipedia.org/wiki/分散式雜湊表</a></li>
<li><a href="https://en.wikipedia.org/wiki/Distributed_hash_table" target="_blank" rel="external">https://en.wikipedia.org/wiki/Distributed_hash_table</a></li>
<li><a href="https://baike.baidu.com/item/DHT/1007999" target="_blank" rel="external">https://baike.baidu.com/item/DHT/1007999</a></li>
<li><a href="https://www.jianshu.com/p/7beeb52376cc" target="_blank" rel="external">https://www.jianshu.com/p/7beeb52376cc</a></li>
<li><a href="https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html" target="_blank" rel="external">https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要整理维基百科中英文和百度百科等资料，算是对 <code>DHT</code> 技术做一个综述，基本都是摘自参考资料中的文档。</p>
]]>
    
    </summary>
    
      <category term="p2p" scheme="https://colobu.com/tags/p2p/"/>
    
      <category term="区块链" scheme="https://colobu.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java8 和 Java 9中并发工具的改变]]></title>
    <link href="https://colobu.com/2018/03/12/Concurrency-Utilities-Enhancements-in-Java-8-Java-9/"/>
    <id>https://colobu.com/2018/03/12/Concurrency-Utilities-Enhancements-in-Java-8-Java-9/</id>
    <published>2018-03-12T09:14:11.000Z</published>
    <updated>2018-03-12T11:36:03.558Z</updated>
    <content type="html"><![CDATA[<p>Java 8 和 Java 9中 <code>concurrent</code>包有了一些改变， 本文对这些改变做了汇总。</p>
<a id="more"></a>
<h2 id="Java_8_中_Concurrent_package的改变">Java 8 中 Concurrent package的改变</h2>
<h3 id="java-util-concurrent中新的类和接口">java.util.concurrent中新的类和接口</h3>
<p>增加了两个新接口和4个新类:</p>
<ol>
<li>接口<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.AsynchronousCompletionTask.html" target="_blank" rel="external">CompletableFuture.AsynchronousCompletionTask</a></li>
<li><p>接口<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html" target="_blank" rel="external">CompletionStage<t></t></a></p>
</li>
<li><p>类<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" target="_blank" rel="external">CompletableFuture<t></t></a></p>
</li>
<li>类<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.KeySetView.html" target="_blank" rel="external">ConcurrentHashMap.KeySetView<k,v></k,v></a></li>
<li>类<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountedCompleter.html" target="_blank" rel="external">CountedCompleter<t></t></a></li>
<li>类<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionException.html" target="_blank" rel="external">CompletionException</a></li>
</ol>
<h3 id="java-util-concurrent-ConcurrentHashMap的新方法">java.util.concurrent.ConcurrentHashMap的新方法</h3>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html" target="_blank" rel="external">集合框架</a>在Java 8中做了修订，基于<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/lambda_api_jdk8.html" target="_blank" rel="external">stream</a>和<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/enhancements.html#javase8" target="_blank" rel="external">lambda表达式</a>添加了很多聚合方法。因此<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html" target="_blank" rel="external"> ConcurrentHashMap </a>也引入了30几个新方法，包括各种<code>foreach</code>方法(<code>forEach</code>, <code>forEachKey</code>, <code>forEachValue</code>, 和 <code>forEachEntry</code>)、搜索方法(<code>search</code>, <code>searchKeys</code>, <code>searchValues</code>, 和 <code>searchEntries</code>)和reduction方法(<code>reduce</code>, <code>reduceToDouble</code>, <code>reduceToLong</code>等)。</p>
<p>也添加了一些其它方法，比如 <code>mappingCount</code>和<code>newKeySet</code>。并且当前版本的<code>ConcurrentHashMap</code>的更适合做cache，因为增加了当键值不存在的时候的检查方法。</p>
<h3 id="java-util-concurrent-atomic中的新类">java.util.concurrent.atomic中的新类</h3>
<p>为了并发计算count、sum， 新引入了<code>DoubleAccumulator</code>, <code>DoubleAdder</code>, <code>LongAccumulator</code>, <code>LongAdder</code>类，比Atomic提供更高的吞吐率。</p>
<h3 id="java-util-concurrent-ForkJoinPool的新方法">java.util.concurrent.ForkJoinPool的新方法</h3>
<p>静态的<code>commonPool()</code>新加入，可以为ForkJoinTask提供通用池。</p>
<p>两个方法 <code>getCommonPoolParallelism()</code> 和 <code>commonPool()</code>提供不同的配置。 </p>
<h3 id="新类_java-util-concurrent-locks-StampedLock">新类 java.util.concurrent.locks.StampedLock</h3>
<p>新类<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/util/concurrent/package-summary.html" target="_blank" rel="external">StampedLock</a>提供三种模式(写，读，乐观读)，用来提高性能。</p>
<h2 id="Java_9_中_Concurrent_package的改变">Java 9 中 Concurrent package的改变</h2>
<p>主要是<a href="http://openjdk.java.net/jeps/266" target="_blank" rel="external"> JEP 266: More Concurrency Updates</a>, 包括publish-subscribe, <code>CompletableFuture</code>接口的加强等。</p>
<ul>
<li>支持Reactive Streams publish-subscribe框架，四个接口<code>Processor</code>、<code>Publisher</code>、<code>Subscriber</code>、<code>Subscription</code>，容器类<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html" target="_blank" rel="external">java.util.concurrent.Flow</a>、<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/SubmissionPublisher.html" target="_blank" rel="external">java.util.concurrent.SubmissionPublisher</a></li>
<li>CompletableFuture类加强，支持delays, timeout, subclassing 以及其它方法</li>
<li>调优以及修改javadoc</li>
</ul>
<h2 id="参考文档">参考文档</h2>
<ol>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/changes8.html" target="_blank" rel="external">Concurrency Utilities Enhancements in Java SE 8</a></li>
<li><a href="https://www.javaworld.com/article/3198904/learn-java/java-9s-other-new-enhancements-part-6-concurrency.html" target="_blank" rel="external">Java 9&#39;s other new enhancements, Part 6: Concurrency</a></li>
<li><a href="https://blog.takipi.com/the-essential-java-9-feature-you-probably-never-heard-of/" target="_blank" rel="external">The Essential Java 9 Feature You Probably Never Heard Of</a></li>
<li><a href="https://www.infoworld.com/article/3169289/java/java-9s-other-new-enhancements-part-2.html" target="_blank" rel="external">Java 9&#39;s other new enhancements</a></li>
<li><a href="http://openjdk.java.net/jeps/266" target="_blank" rel="external">JEP 266: More Concurrency Updates</a></li>
<li><a href="https://www.voxxed.com/2016/10/java-9-series-concurrency-updates/" target="_blank" rel="external">Java 9 series: Concurrency Updates</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java 8 和 Java 9中 <code>concurrent</code>包有了一些改变， 本文对这些改变做了汇总。</p>
]]>
    
    </summary>
    
      <category term="Java" scheme="https://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]20个使用 Java CompletableFuture的例子]]></title>
    <link href="https://colobu.com/2018/03/12/20-Examples-of-Using-Java%E2%80%99s-CompletableFuture/"/>
    <id>https://colobu.com/2018/03/12/20-Examples-of-Using-Java’s-CompletableFuture/</id>
    <published>2018-03-12T06:52:48.000Z</published>
    <updated>2018-03-12T11:36:23.781Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>在Java中异步编程，不一定非要使用rxJava, Java本身的库中的CompletableFuture可以很好的应对大部分的场景。</p>
</blockquote>
<p>原文: <a href="https://mahmoudanouti.wordpress.com/2018/01/26/20-examples-of-using-javas-completablefuture/" target="_blank" rel="external">20 Examples of Using Java’s CompletableFuture</a>, 作者 Mahmoud Anouti。</p>
<p>这篇文章介绍 Java 8 的 <a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CompletionStage.html" target="_blank" rel="external">CompletionStage API</a>和它的标准库的实现 <a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CompletableFuture.html" target="_blank" rel="external">CompletableFuture</a>。API通过例子的方式演示了它的行为，每个例子演示一到两个行为。</p>
<p>既然<code>CompletableFuture</code>类实现了<code>CompletionStage</code>接口，首先我们需要理解这个接口的契约。它代表了一个特定的计算的阶段，可以同步或者异步的被完成。你可以把它看成一个计算流水线上的一个单元，最终会产生一个最终结果，这意味着几个<code>CompletionStage</code>可以串联起来，一个完成的阶段可以触发下一阶段的执行，接着触发下一次，接着……</p>
<p>除了实现<code>CompletionStage</code>接口， <code>CompletableFuture</code>也实现了<code>future</code>接口, 代表一个未完成的异步事件。<code>CompletableFuture</code>提供了方法，能够显式地完成这个future,所以它叫<code>CompletableFuture</code>。</p>
<a id="more"></a>
<p>1、 创建一个完成的CompletableFuture</p>
<p>最简单的例子就是使用一个预定义的结果创建一个完成的CompletableFuture,通常我们会在计算的开始阶段使用它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> completedFutureExample() {</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(<span class="string">"message"</span>);</div><div class="line">    assertTrue(cf.isDone());</div><div class="line">    assertEquals(<span class="string">"message"</span>, cf.getNow(<span class="keyword">null</span>));</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>getNow(null)</code>方法在future完成的情况下会返回结果，就比如上面这个例子，否则返回null (传入的参数)。</p>
<p>2、运行一个简单的异步阶段</p>
<p>这个例子创建一个一个异步执行的阶段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> runAsyncExample() {</div><div class="line">    CompletableFuture cf = CompletableFuture.runAsync(() -&gt; {</div><div class="line">        assertTrue(Thread.currentThread().isDaemon());</div><div class="line">        randomSleep();</div><div class="line">    });</div><div class="line">    assertFalse(cf.isDone());</div><div class="line">    sleepEnough();</div><div class="line">    assertTrue(cf.isDone());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>通过这个例子可以学到两件事情：</p>
<p>CompletableFuture的方法如果以<code>Async</code>结尾，它会异步的执行(没有指定executor的情况下)， 异步执行通过<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ForkJoinPool.html" target="_blank" rel="external">ForkJoinPool</a>实现， 它使用守护线程去执行任务。注意这是CompletableFuture的特性， 其它CompletionStage可以override这个默认的行为。</p>
<p>3、在前一个阶段上应用函数</p>
<p>下面这个例子使用前面 <strong>#1</strong> 的完成的CompletableFuture， #1返回结果为字符串<code>message</code>,然后应用一个函数把它变成大写字母。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> thenApplyExample() {</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(<span class="string">"message"</span>).thenApply(s -&gt; {</div><div class="line">        assertFalse(Thread.currentThread().isDaemon());</div><div class="line">        <span class="keyword">return</span> s.toUpperCase();</div><div class="line">    });</div><div class="line">    assertEquals(<span class="string">"MESSAGE"</span>, cf.getNow(<span class="keyword">null</span>));</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意<code>thenApply</code>方法名称代表的行为。</p>
<p><code>then</code>意味着这个阶段的动作发生当前的阶段正常完成之后。本例中，当前节点完成，返回字符串<code>message</code>。</p>
<p><code>Apply</code>意味着返回的阶段将会对结果前一阶段的结果应用一个函数。</p>
<p>函数的执行会被<strong>阻塞</strong>，这意味着<code>getNow()</code>只有打斜操作被完成后才返回。</p>
<p>4、在前一个阶段上异步应用函数</p>
<p>通过调用异步方法(方法后边加Async后缀)，串联起来的CompletableFuture可以异步地执行（使用ForkJoinPool.commonPool()）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> thenApplyAsyncExample() {</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(<span class="string">"message"</span>).thenApplyAsync(s -&gt; {</div><div class="line">        assertTrue(Thread.currentThread().isDaemon());</div><div class="line">        randomSleep();</div><div class="line">        <span class="keyword">return</span> s.toUpperCase();</div><div class="line">    });</div><div class="line">    assertNull(cf.getNow(<span class="keyword">null</span>));</div><div class="line">    assertEquals(<span class="string">"MESSAGE"</span>, cf.join());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>5、使用定制的Executor在前一个阶段上异步应用函数</p>
<p>异步方法一个非常有用的特性就是能够提供一个<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Executor.html" target="_blank" rel="external">Executor</a>来异步地执行CompletableFuture。这个例子演示了如何使用一个固定大小的线程池来应用大写函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>, <span class="keyword">new</span> ThreadFactory() {</div><div class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line"> </div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> Thread <span class="title">newThread</span>(Runnable runnable) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(runnable, <span class="string">"custom-executor-"</span> + count++);</div><div class="line">    }</div><div class="line">});</div><div class="line"> </div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> thenApplyAsyncWithExecutorExample() {</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(<span class="string">"message"</span>).thenApplyAsync(s -&gt; {</div><div class="line">        assertTrue(Thread.currentThread().getName().startsWith(<span class="string">"custom-executor-"</span>));</div><div class="line">        assertFalse(Thread.currentThread().isDaemon());</div><div class="line">        randomSleep();</div><div class="line">        <span class="keyword">return</span> s.toUpperCase();</div><div class="line">    }, executor);</div><div class="line"> </div><div class="line">    assertNull(cf.getNow(<span class="keyword">null</span>));</div><div class="line">    assertEquals(<span class="string">"MESSAGE"</span>, cf.join());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>6、消费前一阶段的结果</p>
<p>如果下一阶段接收了当前阶段的结果，但是在计算的时候不需要返回值(它的返回类型是void)， 那么它可以不应用一个函数，而是一个消费者， 调用方法也变成了<code>thenAccept</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> thenAcceptExample() {</div><div class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">    CompletableFuture.completedFuture(<span class="string">"thenAccept message"</span>)</div><div class="line">            .thenAccept(s -&gt; result.append(s));</div><div class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>本例中消费者同步地执行，所以我们不需要在CompletableFuture调用<code>join</code>方法。</p>
<p>7、异步地消费迁移阶段的结果</p>
<p>同样，可以使用<code>thenAcceptAsync</code>方法， 串联的CompletableFuture可以异步地执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> thenAcceptAsyncExample() {</div><div class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(<span class="string">"thenAcceptAsync message"</span>)</div><div class="line">            .thenAcceptAsync(s -&gt; result.append(s));</div><div class="line">    cf.join();</div><div class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>8、完成计算异常</p>
<p>现在我们来看一下异步操作如何显式地返回异常，用来指示计算失败。我们简化这个例子，操作处理一个字符串，把它转换成答谢，我们模拟延迟一秒。</p>
<p>我们使用<code>thenApplyAsync(Function, Executor)</code>方法，第一个参数传入大写函数， executor是一个delayed executor,在执行前会延迟一秒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> completeExceptionallyExample() {</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(<span class="string">"message"</span>).thenApplyAsync(String::toUpperCase,</div><div class="line">            CompletableFuture.delayedExecutor(<span class="number">1</span>, TimeUnit.SECONDS));</div><div class="line">    CompletableFuture exceptionHandler = cf.handle((s, th) -&gt; { <span class="keyword">return</span> (th != <span class="keyword">null</span>) ? <span class="string">"message upon cancel"</span> : <span class="string">""</span>; });</div><div class="line">    cf.completeExceptionally(<span class="keyword">new</span> RuntimeException(<span class="string">"completed exceptionally"</span>));</div><div class="line">assertTrue(<span class="string">"Was not completed exceptionally"</span>, cf.isCompletedExceptionally());</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        cf.join();</div><div class="line">        fail(<span class="string">"Should have thrown an exception"</span>);</div><div class="line">    } <span class="keyword">catch</span>(CompletionException ex) { <span class="comment">// just for testing</span></div><div class="line">        assertEquals(<span class="string">"completed exceptionally"</span>, ex.getCause().getMessage());</div><div class="line">    }</div><div class="line"> </div><div class="line">    assertEquals(<span class="string">"message upon cancel"</span>, exceptionHandler.join());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>让我们看一下细节。</p>
<p>首先我们创建了一个CompletableFuture, 完成后返回一个字符串<code>message</code>,接着我们调用<code>thenApplyAsync</code>方法，它返回一个CompletableFuture。这个方法在第一个函数完成后，异步地应用转大写字母函数。</p>
<p>这个例子还演示了如何通过<code>delayedExecutor(timeout, timeUnit)</code>延迟执行一个异步任务。</p>
<p>我们创建了一个分离的<code>handler</code>阶段： exceptionHandler， 它处理异常异常，在异常情况下返回<code>message upon cancel</code>。</p>
<p>下一步我们显式地用异常完成第二个阶段。 在阶段上调用<code>join</code>方法，它会执行大写转换，然后抛出CompletionException（正常的join会等待1秒，然后得到大写的字符串。不过我们的例子还没等它执行就完成了异常）， 然后它触发了handler阶段。</p>
<p>9、取消计算</p>
<p>和完成异常类似，我们可以调用<code>cancel(boolean mayInterruptIfRunning)</code>取消计算。对于CompletableFuture类，布尔参数并没有被使用，这是因为它并没有使用中断去取消操作，相反，<code>cancel</code>等价于<code>completeExceptionally(new CancellationException())</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> cancelExample() {</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(<span class="string">"message"</span>).thenApplyAsync(String::toUpperCase,</div><div class="line">            CompletableFuture.delayedExecutor(<span class="number">1</span>, TimeUnit.SECONDS));</div><div class="line">    CompletableFuture cf2 = cf.exceptionally(throwable -&gt; <span class="string">"canceled message"</span>);</div><div class="line">    assertTrue(<span class="string">"Was not canceled"</span>, cf.cancel(<span class="keyword">true</span>));</div><div class="line">    assertTrue(<span class="string">"Was not completed exceptionally"</span>, cf.isCompletedExceptionally());</div><div class="line">    assertEquals(<span class="string">"canceled message"</span>, cf2.join());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>10、在两个完成的阶段其中之一上应用函数</p>
<p>下面的例子创建了<code>CompletableFuture</code>, <code>applyToEither</code>处理两个阶段， 在其中之一上应用函数(包保证哪一个被执行)。 本例中的两个阶段一个是应用大写转换在原始的字符串上， 另一个阶段是应用小些转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> applyToEitherExample() {</div><div class="line">    String original = <span class="string">"Message"</span>;</div><div class="line">    CompletableFuture cf1 = CompletableFuture.completedFuture(original)</div><div class="line">            .thenApplyAsync(s -&gt; delayedUpperCase(s));</div><div class="line">    CompletableFuture cf2 = cf1.applyToEither(</div><div class="line">            CompletableFuture.completedFuture(original).thenApplyAsync(s -&gt; delayedLowerCase(s)),</div><div class="line">            s -&gt; s + <span class="string">" from applyToEither"</span>);</div><div class="line">    assertTrue(cf2.join().endsWith(<span class="string">" from applyToEither"</span>));</div><div class="line">}</div></pre></td></tr></table></figure>

<p>11、在两个完成的阶段其中之一上调用消费函数</p>
<p>和前一个例子很类似了，只不过我们调用的是消费者函数 (Function变成Consumer):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> acceptEitherExample() {</div><div class="line">    String original = <span class="string">"Message"</span>;</div><div class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(original)</div><div class="line">            .thenApplyAsync(s -&gt; delayedUpperCase(s))</div><div class="line">            .acceptEither(CompletableFuture.completedFuture(original).thenApplyAsync(s -&gt; delayedLowerCase(s)),</div><div class="line">                    s -&gt; result.append(s).append(<span class="string">"acceptEither"</span>));</div><div class="line">    cf.join();</div><div class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.toString().endsWith(<span class="string">"acceptEither"</span>));</div><div class="line">}</div></pre></td></tr></table></figure>

<p>12、在两个阶段都执行完后运行一个 <code>Runnable</code></p>
<p>这个例子演示了依赖的CompletableFuture如果等待两个阶段完成后执行了一个Runnable。 注意下面所有的阶段都是同步执行的，第一个阶段执行大写转换，第二个阶段执行小写转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> runAfterBothExample() {</div><div class="line">    String original = <span class="string">"Message"</span>;</div><div class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">    CompletableFuture.completedFuture(original).thenApply(String::toUpperCase).runAfterBoth(</div><div class="line">            CompletableFuture.completedFuture(original).thenApply(String::toLowerCase),</div><div class="line">            () -&gt; result.append(<span class="string">"done"</span>));</div><div class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>13、 使用BiConsumer处理两个阶段的结果</p>
<p>上面的例子还可以通过BiConsumer来实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> thenAcceptBothExample() {</div><div class="line">    String original = <span class="string">"Message"</span>;</div><div class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">    CompletableFuture.completedFuture(original).thenApply(String::toUpperCase).thenAcceptBoth(</div><div class="line">            CompletableFuture.completedFuture(original).thenApply(String::toLowerCase),</div><div class="line">            (s1, s2) -&gt; result.append(s1 + s2));</div><div class="line">    assertEquals(<span class="string">"MESSAGEmessage"</span>, result.toString());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>14、使用BiFunction处理两个阶段的结果</p>
<p>如果CompletableFuture依赖两个前面阶段的结果， 它复合两个阶段的结果再返回一个结果，我们就可以使用<code>thenCombine()</code>函数。整个流水线是同步的，所以<code>getNow()</code>会得到最终的结果，它把大写和小写字符串连接起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> thenCombineExample() {</div><div class="line">    String original = <span class="string">"Message"</span>;</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(original).thenApply(s -&gt; delayedUpperCase(s))</div><div class="line">            .thenCombine(CompletableFuture.completedFuture(original).thenApply(s -&gt; delayedLowerCase(s)),</div><div class="line">                    (s1, s2) -&gt; s1 + s2);</div><div class="line">    assertEquals(<span class="string">"MESSAGEmessage"</span>, cf.getNow(<span class="keyword">null</span>));</div><div class="line">}</div></pre></td></tr></table></figure>

<p>15、异步使用BiFunction处理两个阶段的结果</p>
<p>类似上面的例子，但是有一点不同： 依赖的前两个阶段异步地执行，所以<code>thenCombine()</code>也异步地执行，即时它没有<code>Async</code>后缀。</p>
<p>Javadoc中有注释：</p>
<blockquote>
<p>Actions supplied for dependent completions of non-async methods may be performed by the thread that completes the current CompletableFuture, or by any other caller of a completion method</p>
</blockquote>
<p>所以我们需要<code>join</code>方法等待结果的完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> thenCombineAsyncExample() {</div><div class="line">    String original = <span class="string">"Message"</span>;</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(original)</div><div class="line">            .thenApplyAsync(s -&gt; delayedUpperCase(s))</div><div class="line">            .thenCombine(CompletableFuture.completedFuture(original).thenApplyAsync(s -&gt; delayedLowerCase(s)),</div><div class="line">                    (s1, s2) -&gt; s1 + s2);</div><div class="line">    assertEquals(<span class="string">"MESSAGEmessage"</span>, cf.join());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>16、组合 CompletableFuture</p>
<p>我们可以使用<code>thenCompose()</code>完成上面两个例子。这个方法等待第一个阶段的完成(大写转换)， 它的结果传给一个指定的返回CompletableFuture函数，它的结果就是返回的CompletableFuture的结果。</p>
<p>有点拗口，但是我们看例子来理解。函数需要一个大写字符串做参数，然后返回一个CompletableFuture, 这个CompletableFuture会转换字符串变成小写然后连接在大写字符串的后面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> thenComposeExample() {</div><div class="line">    String original = <span class="string">"Message"</span>;</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(original).thenApply(s -&gt; delayedUpperCase(s))</div><div class="line">            .thenCompose(upper -&gt; CompletableFuture.completedFuture(original).thenApply(s -&gt; delayedLowerCase(s))</div><div class="line">                    .thenApply(s -&gt; upper + s));</div><div class="line">    assertEquals(<span class="string">"MESSAGEmessage"</span>, cf.join());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>17、当几个阶段中的一个完成，创建一个完成的阶段</p>
<p>下面的例子演示了当任意一个CompletableFuture完成后， 创建一个完成的CompletableFuture.</p>
<p>待处理的阶段首先创建， 每个阶段都是转换一个字符串为大写。因为本例中这些阶段都是同步地执行(thenApply), 从<code>anyOf</code>中创建的CompletableFuture会立即完成，这样所有的阶段都已完成，我们使用<code>whenComplete(BiConsumer&lt;? super Object, ? super Throwable&gt; action)</code>处理完成的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> anyOfExample() {</div><div class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">    List messages = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</div><div class="line">    List&lt;CompletableFuture&gt; futures = messages.stream()</div><div class="line">            .map(msg -&gt; CompletableFuture.completedFuture(msg).thenApply(s -&gt; delayedUpperCase(s)))</div><div class="line">            .collect(Collectors.toList());</div><div class="line">    CompletableFuture.anyOf(futures.toArray(<span class="keyword">new</span> CompletableFuture[futures.size()])).whenComplete((res, th) -&gt; {</div><div class="line">        <span class="keyword">if</span>(th == <span class="keyword">null</span>) {</div><div class="line">            assertTrue(isUpperCase((String) res));</div><div class="line">            result.append(res);</div><div class="line">        }</div><div class="line">    });</div><div class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>18、当所有的阶段都完成后创建一个阶段</p>
<p>上一个例子是当任意一个阶段完成后接着处理，接下来的两个例子演示当所有的阶段完成后才继续处理, 同步地方式和异步地方式两种。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> allOfExample() {</div><div class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">    List messages = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</div><div class="line">    List&lt;CompletableFuture&gt; futures = messages.stream()</div><div class="line">            .map(msg -&gt; CompletableFuture.completedFuture(msg).thenApply(s -&gt; delayedUpperCase(s)))</div><div class="line">            .collect(Collectors.toList());</div><div class="line">    CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> CompletableFuture[futures.size()])).whenComplete((v, th) -&gt; {</div><div class="line">        futures.forEach(cf -&gt; assertTrue(isUpperCase(cf.getNow(<span class="keyword">null</span>))));</div><div class="line">        result.append(<span class="string">"done"</span>);</div><div class="line">    });</div><div class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>19、当所有的阶段都完成后异步地创建一个阶段<br>使用<code>thenApplyAsync()</code>替换那些单个的CompletableFutures的方法，<code>allOf()</code>会在通用池中的线程中异步地执行。所以我们需要调用<code>join</code>方法等待它完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> allOfAsyncExample() {</div><div class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">    List messages = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</div><div class="line">    List&lt;CompletableFuture&gt; futures = messages.stream()</div><div class="line">            .map(msg -&gt; CompletableFuture.completedFuture(msg).thenApplyAsync(s -&gt; delayedUpperCase(s)))</div><div class="line">            .collect(Collectors.toList());</div><div class="line">    CompletableFuture allOf = CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> CompletableFuture[futures.size()]))</div><div class="line">            .whenComplete((v, th) -&gt; {</div><div class="line">                futures.forEach(cf -&gt; assertTrue(isUpperCase(cf.getNow(<span class="keyword">null</span>))));</div><div class="line">                result.append(<span class="string">"done"</span>);</div><div class="line">            });</div><div class="line">    allOf.join();</div><div class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>20、真实的例子</p>
<p>Now that the functionality of CompletionStage and specifically CompletableFuture is explored, the below example applies them in a practical scenario:</p>
<p>现在你已经了解了CompletionStage 和 CompletableFuture 的一些函数的功能，下面的例子是一个实践场景：</p>
<ol>
<li>首先异步调用<code>cars</code>方法获得Car的列表，它返回CompletionStage场景。<code>cars</code>消费一个远程的REST API。</li>
<li>然后我们复合一个CompletionStage填写每个汽车的评分，通过<code>rating(manufacturerId)</code>返回一个CompletionStage, 它会异步地获取汽车的评分(可能又是一个REST API调用)</li>
<li>当所有的汽车填好评分后，我们结束这个列表，所以我们调用<code>allOf</code>得到最终的阶段， 它在前面阶段所有阶段完成后才完成。</li>
<li>在最终的阶段调用<code>whenComplete()</code>,我们打印出每个汽车和它的评分。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">cars().thenCompose(cars -&gt; {</div><div class="line">    List&lt;CompletionStage&gt; updatedCars = cars.stream()</div><div class="line">            .map(car -&gt; rating(car.manufacturerId).thenApply(r -&gt; {</div><div class="line">                car.setRating(r);</div><div class="line">                <span class="keyword">return</span> car;</div><div class="line">            })).collect(Collectors.toList());</div><div class="line"> </div><div class="line">    CompletableFuture done = CompletableFuture</div><div class="line">            .allOf(updatedCars.toArray(<span class="keyword">new</span> CompletableFuture[updatedCars.size()]));</div><div class="line">    <span class="keyword">return</span> done.thenApply(v -&gt; updatedCars.stream().map(CompletionStage::toCompletableFuture)</div><div class="line">            .map(CompletableFuture::join).collect(Collectors.toList()));</div><div class="line">}).whenComplete((cars, th) -&gt; {</div><div class="line">    <span class="keyword">if</span> (th == <span class="keyword">null</span>) {</div><div class="line">        cars.forEach(System.out::println);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(th);</div><div class="line">    }</div><div class="line">}).toCompletableFuture().join();</div></pre></td></tr></table></figure>

<p>因为每个汽车的实例都是独立的，得到每个汽车的评分都可以异步地执行，这会提高系统的性能(延迟)，而且，等待所有的汽车评分被处理使用的是<code>allOf</code>方法，而不是手工的线程等待(Thread#join() 或 a CountDownLatch)。</p>
<p>这些例子可以帮助你更好的理解相关的API,你可以在<a href="https://github.com/manouti/completablefuture-examples" target="_blank" rel="external">github</a>上得到所有的例子的代码。</p>
<p><strong>其它参考文档</strong></p>
<ol>
<li><a href="https://medium.com/@johnmcclean/reactive-programming-with-java-8-and-simple-react-the-tutorial-3634f512eeb1" target="_blank" rel="external">Reactive programming with Java 8 and simple-react : The Tutorial</a></li>
<li><a href="http://javaday.org.ua/completablefuture-overview/" target="_blank" rel="external">CompletableFuture Overview</a></li>
<li><a href="https://blog.takipi.com/back-to-the-completablefuture-java-8-feature-highlight/" target="_blank" rel="external">CompletableFuture vs Future: going async with Java 8 new features</a></li>
<li><a href="https://github.com/spotify/completable-futures" target="_blank" rel="external">spotify/completable-futures</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>在Java中异步编程，不一定非要使用rxJava, Java本身的库中的CompletableFuture可以很好的应对大部分的场景。</p>
</blockquote>
<p>原文: <a href="https://mahmoudanouti.wordpress.com/2018/01/26/20-examples-of-using-javas-completablefuture/" target="_blank" rel="external">20 Examples of Using Java’s CompletableFuture</a>, 作者 Mahmoud Anouti。</p>
<p>这篇文章介绍 Java 8 的 <a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CompletionStage.html" target="_blank" rel="external">CompletionStage API</a>和它的标准库的实现 <a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CompletableFuture.html" target="_blank" rel="external">CompletableFuture</a>。API通过例子的方式演示了它的行为，每个例子演示一到两个行为。</p>
<p>既然<code>CompletableFuture</code>类实现了<code>CompletionStage</code>接口，首先我们需要理解这个接口的契约。它代表了一个特定的计算的阶段，可以同步或者异步的被完成。你可以把它看成一个计算流水线上的一个单元，最终会产生一个最终结果，这意味着几个<code>CompletionStage</code>可以串联起来，一个完成的阶段可以触发下一阶段的执行，接着触发下一次，接着……</p>
<p>除了实现<code>CompletionStage</code>接口， <code>CompletableFuture</code>也实现了<code>future</code>接口, 代表一个未完成的异步事件。<code>CompletableFuture</code>提供了方法，能够显式地完成这个future,所以它叫<code>CompletableFuture</code>。</p>
]]>
    
    </summary>
    
      <category term="Java" scheme="https://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]使用 LLDB 调试 Go 程序]]></title>
    <link href="https://colobu.com/2018/03/12/Debugging-Go-Code-with-LLDB/"/>
    <id>https://colobu.com/2018/03/12/Debugging-Go-Code-with-LLDB/</id>
    <published>2018-03-12T04:09:38.000Z</published>
    <updated>2018-03-13T03:25:21.000Z</updated>
    <content type="html"><![CDATA[<p>我一般调试Go程序都是通过log日志，性能调试的话通过 pprof 、trace、flamegraph等，主要是Go没有一个很好的集成的debugger,前两年虽然关注了delve，但是在IDE中集成比较粗糙，调试也很慢，所以基本不使用debugger进行调试， 最近看到滴滴的工程师分享的使用debugger在调试Go程序，我觉得有必要在尝试一下这方面的技术了。</p>
<p>本文翻译自 <a href="http://ribrdb.github.io/lldb/" target="_blank" rel="external">Debugging Go Code with LLDB</a>, 更好的调试Go程序的工具是<a href="https://github.com/derekparker/delve" target="_blank" rel="external">delve</a>, 因为它是专门为Go开发， 使用起来也很简单，并且还可以远程调试。delve的命令还可参考： <a href="https://github.com/derekparker/delve/tree/master/Documentation/cli" target="_blank" rel="external">dlv cli</a>，但是流行的通用的基础的debugger也是常用的手段之一。我在译文后面也列出了几篇其它关于go debug的相关文章，有兴趣的话也可以扩展阅读一下。</p>
<a id="more"></a>
<blockquote>
<p>本文主要介绍应用于glang compiler 工具链的技术， 除了本文的介绍外，你还可以参考 <a href="http://lldb.llvm.org/tutorial.html" target="_blank" rel="external">LLDB 手册</a></p>
</blockquote>
<h2 id="介绍">介绍</h2>
<p>在 Linux、Mac OS X, FreeBSD 或者 NetBSD环境中，当你使用 gc工具链编译和链接Go程序的时候， 编译出的二进制文件会携带<a href="http://dwarfstd.org/Dwarf3Std.php" target="_blank" rel="external">DWARFv3</a>调试信息。 LLDB调试器( &gt; 3.7)可以使用这个信息调试进程或者core dump文件。</p>
<blockquote>
<p>使用<code>-w</code>可以告诉链接器忽略这个调试信息， 比如<code>go build -ldflags &quot;-w&quot; prog.go</code>。</p>
</blockquote>
<p>gc编译器产生的代码可能会包含内联的优化，这不方便调试器调试，为了禁止内联， 你可以使用<code>-gcflags &quot;-N -l&quot;</code>参数。</p>
<h3 id="安装lldb">安装lldb</h3>
<p>MacOS下如果你安装了XCode,应该已经安装了LLDB， LLDB是XCode默认的调试器。</p>
<p>Linux/MacOS/Windows下的安装方法可以参考： <a href="https://github.com/vadimcn/vscode-lldb/wiki/Installing-LLDB" target="_blank" rel="external">Installing-LLDB</a>。</p>
<h3 id="通用操作">通用操作</h3>
<ul>
<li>显示文件和行号，设置断点以及反编译:</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(lldb) l</div><div class="line">(lldb) l <span class="built_in">line</span></div><div class="line">(lldb) l <span class="built_in">file</span>.go:<span class="built_in">line</span></div><div class="line">(lldb) b <span class="built_in">line</span></div><div class="line">(lldb) b <span class="built_in">file</span>.go:<span class="built_in">line</span></div><div class="line">(lldb) disas</div></pre></td></tr></table></figure>

<ul>
<li>显示 backtrace 和 unwind stack frame:</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) <span class="keyword">bt</span></div><div class="line">(lldb) frame n</div></pre></td></tr></table></figure>

<ul>
<li>Show the name, type and location on the stack frame of local variables, arguments and return values:</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) frame <span class="built_in">variable</span></div><div class="line">(lldb) p varname</div><div class="line">(lldb) expr -T <span class="comment">-- varname</span></div></pre></td></tr></table></figure>

<h2 id="Go扩展">Go扩展</h2>
<h3 id="表达式解析">表达式解析</h3>
<p>LLDB支持Go表达式:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) p x</div><div class="line">(lldb) <span class="type">expr</span> *(*<span class="type">int32</span>)(t)</div><div class="line">(lldb) help <span class="type">expr</span></div></pre></td></tr></table></figure>

<h3 id="Interface">Interface</h3>
<p>默认LLDB显示接口的动态类型。通常它是一个指针， 比如<code>func foo(a interface{}) { ... }</code>, 如果你调用<code>callfoo(1.0)</code>, lldb会把<code>a</code>看作<code>*float64inside</code>，你也可以禁止为一个表达式禁止这种处理，或者在全局禁用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) expr -<span class="keyword">d</span> <span class="keyword">no</span>-dynamic-<span class="built_in">values</span> -- <span class="keyword">a</span></div><div class="line">(lldb) settings <span class="keyword">set</span> target.prefer-dynamic-<span class="built_in">values</span> <span class="keyword">no</span>-dynamic-<span class="built_in">values</span></div></pre></td></tr></table></figure>

<h3 id="Data_Formatter">Data Formatter</h3>
<p>LLDB包含 go string 和 slice的格式化输出器，查看<a href="http://lldb.llvm.org/varformats.html" target="_blank" rel="external">LLDB docs</a>文档学习定制格式化输出。如果你想扩展内建的格式化方式，可以参考<a href="https://github.com/ribrdb/lldb/blob/gogogo/source/Plugins/LanguageRuntime/Go/GoLanguageRuntime.cpp" target="_blank" rel="external">GoLanguageRuntime.cpp</a>。</p>
<p>Channel和map被看作引用类型，lldb把它们作为指针类型， 就像C++的类型<code>hash&lt;int,string&gt;*</code>。Dereferencing会显示类型内部的表示。</p>
<h3 id="Goroutine">Goroutine</h3>
<p>LLDB 把 Goroutine 看作 thread。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) <span class="keyword">thread</span> <span class="built_in">list</span></div><div class="line">(lldb) bt <span class="literal">all</span></div><div class="line">(lldb) <span class="keyword">thread</span> <span class="keyword">select</span> <span class="number">2</span></div></pre></td></tr></table></figure>

<h3 id="已知问题">已知问题</h3>
<ul>
<li>如果编译时开启优化，调试信息可能是错误的。请确保开启参数 <code>-gcflags &quot;-N -l&quot;</code></li>
<li>不能改变变量的值，或者调用goh函数</li>
<li>需要更好的支持 chan 和 map 类型</li>
<li>调试信息不包含输入的package, 所以你在表达式中需要package的全路径。当package中包含 non-identifier 字符的时候你需要用引号包含它: <code>x.(*foo/bar.BarType)</code> 或者 <code>(*“v.io/x/foo”.FooType)(x)</code></li>
<li>调试信息不包含作用域，所以变量在它们初始化之前是可见的。 如果有同名的本地变量，比如shadowed 变量， 你不知道哪个是哪个</li>
<li>调试信息仅仅描述了变量在内存中的位置,所以你可能看到寄存器中的变量的stale数据</li>
<li>不能打印函数类型</li>
</ul>
<h2 id="教程">教程</h2>
<p>在这个例子中我们可以检查标准库正则表达式。为了构建二进制文件， 进入<code>$GOROOT/src/regexp</code>然后运行<code>run go test -gcflags &quot;-N -l&quot; -c</code>,这会产生可执行文件 <code>regexp.test</code>。</p>
<h3 id="启动">启动</h3>
<p>启动 lldb, 调试 regexp.test:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ lldb regexp.test</div><div class="line">(lldb) target <span class="operator"><span class="keyword">create</span> <span class="string">"regexp.test"</span></span></div><div class="line"><span class="keyword">Current</span> executable <span class="keyword">set</span> <span class="keyword">to</span> <span class="string">'regexp.test'</span> (x86_64).</div><div class="line">(lldb)</div></pre></td></tr></table></figure>

<h3 id="设置断点">设置断点</h3>
<p>在TestFind 函数上设置断点:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) b <span class="built_in">regexp</span>.TestFind</div></pre></td></tr></table></figure>

<p>有时候 go编译器会使用全路径为函数名添加前缀，如果你不能使用上面简单的名称，你可以使用正则表达式设置断点：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) break <span class="operator"><span class="keyword">set</span> -r <span class="keyword">regexp</span>.TestFind$</span></div><div class="line">Breakpoint <span class="number">5</span>: <span class="keyword">where</span> = <span class="keyword">regexp</span>.test<span class="string">`_/code/go/src/regexp.TestFind + 37 at find_test.go:149, address = 0x00000000000863a5</span></div></pre></td></tr></table></figure>

<p>运行程序:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(lldb) run <span class="subst">--</span>test<span class="built_in">.</span>run<span class="subst">=</span>TestFind</div><div class="line">Process <span class="number">8496</span> launched: <span class="string">'/code/go/src/regexp/regexp.test'</span> (x86_64)</div><div class="line">Process <span class="number">8496</span> stopped</div><div class="line"><span class="subst">*</span> <span class="keyword">thread</span> <span class="variable">#9</span>: tid <span class="subst">=</span> <span class="number">0x0017</span>, <span class="number">0x00000000000863a5</span> regexp<span class="built_in">.</span>test<span class="string">`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 37 at find_test.go:149, stop reason = breakpoint 2.1 3.1 5.1</span></div><div class="line">    frame #0: 0x00000000000863a5 regexp.test`_/code/go/src/regexp<span class="built_in">.</span>TestFind(t<span class="subst">=</span><span class="number">0x000000020834a000</span>) <span class="subst">+</span> <span class="number">37</span> at find_test<span class="built_in">.</span>go:<span class="number">149</span></div><div class="line">   <span class="number">146</span>         <span class="comment">// First the simple cases.</span></div><div class="line">   <span class="number">147</span></div><div class="line">   <span class="number">148</span>         func TestFind(t <span class="subst">*</span>testing<span class="built_in">.</span>T) {</div><div class="line"><span class="subst">-&gt; </span><span class="number">149</span>                 for _, test <span class="subst">:=</span> range findTests {</div><div class="line">   <span class="number">150</span>                         re <span class="subst">:=</span> MustCompile(test<span class="built_in">.</span>pat)</div><div class="line">   <span class="number">151</span>                         <span class="keyword">if</span> re<span class="built_in">.</span><span class="built_in">String</span>() <span class="subst">!=</span> test<span class="built_in">.</span>pat {</div><div class="line">   <span class="number">152</span>                                 t<span class="built_in">.</span>Errorf(<span class="string">"String() = `%s`; should be `%s`"</span>, re<span class="built_in">.</span><span class="built_in">String</span>(), test<span class="built_in">.</span>pat)</div></pre></td></tr></table></figure>

<p>程序会运行到设置的断点上，查看运行的goroutine以及它们在做什么：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(lldb) thread list</div><div class="line">Process 8496 stopped</div><div class="line">  thread #1: tid = 0x12201, 0x000000000003c0ab regexp.test`runtime.mach_semaphore_wait + 11 at sys_darwin_amd64.s:412</div><div class="line">  thread #2: tid = 0x122fa, 0x000000000003bf7c regexp.test`runtime.usleep + 44 at sys_darwin_amd64.s:290</div><div class="line">  thread #4: tid = 0x0001, 0x0000000000015865 regexp.test`runtime.gopark(unlockf=0x00000000000315a0, <span class="operator"><span class="keyword">lock</span>=<span class="number">0x00000002083220b8</span>, reason=<span class="string">"chan receive"</span>) + <span class="number">261</span> <span class="keyword">at</span> proc.<span class="keyword">go</span>:<span class="number">131</span></span></div><div class="line">  thread #<span class="number">5</span>: tid = <span class="number">0x0002</span>, <span class="number">0x0000000000015865</span> <span class="keyword">regexp</span>.test<span class="string">`runtime.gopark(unlockf=0x00000000000315a0, lock=0x00000000002990d0, reason="force gc (idle)") + 261 at proc.go:131</span></div><div class="line">  thread #6: tid = 0x0003, 0x0000000000015754 regexp.test`runtime.Gosched + <span class="number">20</span> <span class="keyword">at</span> proc.<span class="keyword">go</span>:<span class="number">114</span></div><div class="line">  thread #<span class="number">7</span>: tid = <span class="number">0x0004</span>, <span class="number">0x0000000000015865</span> <span class="keyword">regexp</span>.test<span class="string">`runtime.gopark(unlockf=0x00000000000315a0, lock=0x00000000002a07d8, reason="finalizer wait") + 261 at proc.go:131</span></div><div class="line">* thread #9: tid = 0x0017, 0x00000000000863a5 regexp.test`_/code/<span class="keyword">go</span>/src/<span class="keyword">regexp</span>.TestFind(t=<span class="number">0x000000020834a000</span>) + <span class="number">37</span> <span class="keyword">at</span> find_test.<span class="keyword">go</span>:<span class="number">149</span>, <span class="keyword">stop</span> reason = breakpoint <span class="number">2.1</span> <span class="number">3.1</span> <span class="number">5.1</span></div></pre></td></tr></table></figure>

<p>用<code>*</code>标出的那个goroutine是当前的goroutine。</p>
<h3 id="查看代码">查看代码</h3>
<p>使用<code>l</code>或者<code>list</code>查看代码， <code>#</code>重复最后的命令：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) <span class="keyword">l</span></div><div class="line">(lldb) # Hit enter <span class="keyword">to</span> <span class="built_in">repeat</span> <span class="keyword">last</span> <span class="keyword">command</span>. Here, <span class="keyword">list</span> the <span class="keyword">next</span> few lines</div></pre></td></tr></table></figure>

<h3 id="命名">命名</h3>
<p>变量和函数名必须使用它们所隶属的package的全名， 比如<code>Compile</code>函数的名称是<code>regexp.Compile</code>。</p>
<p>方法必须使用receiver类型的全程， 比如<code>*Regexp</code>类型的<code>String</code>方法是<code>regexp.(*Regexp).String</code>。</p>
<p>被closure引用的变量会有<code>&amp;</code>前缀。</p>
<h3 id="查看堆栈">查看堆栈</h3>
<p>查看程序暂停的位置处的堆栈：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(lldb) bt</div><div class="line">* thread #9: tid = 0x0017, 0x00000000000863a5 regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 37 at find_test.go:149, <span class="operator"><span class="keyword">stop</span> reason = breakpoint <span class="number">2.1</span> <span class="number">3.1</span> <span class="number">5.1</span></span></div><div class="line">  * frame #<span class="number">0</span>: <span class="number">0x00000000000863a5</span> <span class="keyword">regexp</span>.test<span class="string">`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 37 at find_test.go:149</span></div><div class="line">    frame #1: 0x0000000000056e3f regexp.test`testing.tRunner(t=<span class="number">0x000000000003b671</span>, test=<span class="number">0x000000020834a000</span>) + <span class="number">191</span> <span class="keyword">at</span> testing.<span class="keyword">go</span>:<span class="number">447</span></div><div class="line">    frame #<span class="number">2</span>: <span class="number">0x00000000002995a0</span> <span class="keyword">regexp</span>.test<span class="string">`/code/go/src/regexp.statictmp_3759 + 96</span></div><div class="line">    frame #3: 0x000000000003b671 regexp.test`runtime.goexit + <span class="number">1</span> <span class="keyword">at</span> asm_amd64.s:<span class="number">2232</span></div><div class="line">The stack frame shows we’re currently executing the <span class="keyword">regexp</span>.TestFind <span class="keyword">function</span>, <span class="keyword">as</span> expected.</div></pre></td></tr></table></figure>

<p>命令<code>frame variable</code>会列出这个函数所有的本地变量以及它们的值。但是使用它有点危险，因为它会尝试打印出未初始化的变量。未初始化的slice可能会导致lldb打印出巨大的数组。</p>
<p>函数参数:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag"><span class="php"><span class="function"><span class="params">(lldb)</span> <span class="title">frame</span> <span class="title">var</span> -<span class="title">l</span></span></span></span></span></div><div class="line"><span class="params">(*testing.T)</span> <span class="title">t</span> = 0<span class="title">x000000020834a000</span></div></pre></td></tr></table></figure>

<p>打印这个参数的时候，你会注意到它是一个指向<code>Regexp</code>的指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">(lldb) p re</div><div class="line">(*_/code/<span class="keyword">go</span>/src/regexp.Regexp) <span class="number">$3</span> =<span class="number"> 0</span>x000000020834a090</div><div class="line">(lldb) p t</div><div class="line">(*testing.T) <span class="number">$4</span> =<span class="number"> 0</span>x000000020834a000</div><div class="line">(lldb) p *t</div><div class="line">(testing.T) <span class="number">$5</span> = {</div><div class="line">  testing.common = {</div><div class="line">    mu = {</div><div class="line">      w = (state =<span class="number"> 0</span>, sema =<span class="number"> 0</span>)</div><div class="line">      writerSem =<span class="number"> 0</span></div><div class="line">      readerSem =<span class="number"> 0</span></div><div class="line">      readerCount =<span class="number"> 0</span></div><div class="line">      readerWait =<span class="number"> 0</span></div><div class="line">    }</div><div class="line">    output = (<span class="built_in">len</span><span class="number"> 0</span>, <span class="built_in">cap</span><span class="number"> 0</span>) {}</div><div class="line">    failed = <span class="constant">false</span></div><div class="line">    skipped = <span class="constant">false</span></div><div class="line">    finished = <span class="constant">false</span></div><div class="line">    start = {</div><div class="line">      sec =<span class="number"> 63579066045</span></div><div class="line">      nsec =<span class="number"> 777400918</span></div><div class="line">      loc =<span class="number"> 0</span>x00000000002995a0</div><div class="line">    }</div><div class="line">    duration =<span class="number"> 0</span></div><div class="line">    self =<span class="number"> 0</span>x000000020834a000</div><div class="line">    signal =<span class="number"> 0</span>x0000000208322060</div><div class="line">  }</div><div class="line">  name = <span class="string">"TestFind"</span></div><div class="line">  startParallel =<span class="number"> 0</span>x0000000208322240</div><div class="line">}</div><div class="line">(lldb) p *t.startParallel</div><div class="line">(hchan&lt;<span class="typename">bool</span>&gt;) <span class="number">$3</span> = {</div><div class="line">  qcount =<span class="number"> 0</span></div><div class="line">  dataqsiz =<span class="number"> 0</span></div><div class="line">  buf =<span class="number"> 0</span>x0000000208322240</div><div class="line">  elemsize =<span class="number"> 1</span></div><div class="line">  closed =<span class="number"> 0</span></div><div class="line">  elemtype =<span class="number"> 0</span>x000000000014eda0</div><div class="line">  sendx =<span class="number"> 0</span></div><div class="line">  recvx =<span class="number"> 0</span></div><div class="line">  recvq = {</div><div class="line">    first =<span class="number"> 0</span>x0000000000000000</div><div class="line">    last =<span class="number"> 0</span>x0000000000000000</div><div class="line">  }</div><div class="line">  sendq = {</div><div class="line">    first =<span class="number"> 0</span>x0000000000000000</div><div class="line">    last =<span class="number"> 0</span>x0000000000000000</div><div class="line">  }</div><div class="line">  lock = (key =<span class="number"> 0</span>x0000000000000000)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>hchan&lt;bool&gt;</code>是这个channel的在运行时的内部数据结构。</p>
<p>步进:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">(lldb) n <span class="comment"># execute next line</span></div><div class="line">(lldb) <span class="comment"># enter is repeat</span></div><div class="line">(lldb) <span class="comment"># enter is repeat</span></div><div class="line">Process <span class="number">17917</span> stopped</div><div class="line">* thread <span class="comment">#8: tid = 0x0017, 0x000000000008648f regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 271 at find_test.go:151, stop reason = step over</span></div><div class="line">    frame <span class="comment">#0: 0x000000000008648f regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 271 at find_test.go:151</span></div><div class="line">   <span class="number">148</span>         func TestFind(t *testing.T) {</div><div class="line">   <span class="number">149</span>                 for _, test := range findTests {</div><div class="line">   <span class="number">150</span>                         re := MustCompile(test.pat)</div><div class="line">-&gt; <span class="number">151</span>                         <span class="keyword">if</span> re.String() != test.pat {</div><div class="line">   <span class="number">152</span>                                 t.Errorf(<span class="string">"String() = `%s`; should be `%s`"</span>, re.String(), test.pat)</div><div class="line">   <span class="number">153</span>                         }</div><div class="line">   <span class="number">154</span>                         result := re.Find([]byte(test.text))</div><div class="line">(lldb) p test.pat</div><div class="line">(string) $<span class="number">4</span> = <span class="string">""</span></div><div class="line">(lldb) p re</div><div class="line">(*_/code/go/src/regexp.Regexp) $<span class="number">5</span> = <span class="number">0</span>x0000000208354320</div><div class="line">(lldb) p *re</div><div class="line">(_/code/go/src/regexp.Regexp) $<span class="number">6</span> = {</div><div class="line">  <span class="variable">expr =</span> <span class="string">""</span></div><div class="line">  <span class="variable">prog =</span> <span class="number">0</span>x0000000208ac6090</div><div class="line">  <span class="variable">onepass =</span> <span class="number">0</span>x0000000000000000</div><div class="line">  <span class="variable">prefix =</span> <span class="string">""</span></div><div class="line">  <span class="variable">prefixBytes =</span> (len <span class="number">0</span>, cap <span class="number">0</span>) {}</div><div class="line">  <span class="variable">prefixComplete =</span> <span class="constant">true</span></div><div class="line">  <span class="variable">prefixRune =</span> <span class="number">0</span></div><div class="line">  <span class="variable">prefixEnd =</span> <span class="number">0</span></div><div class="line">  <span class="variable">cond =</span> <span class="number">0</span></div><div class="line">  <span class="variable">numSubexp =</span> <span class="number">0</span></div><div class="line">  <span class="variable">subexpNames =</span> (len <span class="number">1</span>, cap <span class="number">1</span>) {</div><div class="line">    [<span class="number">0</span>] = <span class="string">""</span></div><div class="line">  }</div><div class="line">  <span class="variable">longest =</span> <span class="constant">false</span></div><div class="line">  <span class="variable">mu =</span> (<span class="variable">state =</span> <span class="number">0</span>, <span class="variable">sema =</span> <span class="number">0</span>)</div><div class="line">  <span class="variable">machine =</span> (len <span class="number">0</span>, cap <span class="number">0</span>) {}</div><div class="line">}</div><div class="line">(lldb) p *re.prog</div><div class="line">(regexp/syntax.Prog) $<span class="number">7</span> = {</div><div class="line">  <span class="variable">Inst =</span> (len <span class="number">3</span>, cap <span class="number">4</span>) {</div><div class="line">    [<span class="number">0</span>] = {</div><div class="line">      <span class="variable">Op =</span> <span class="number">5</span></div><div class="line">      <span class="variable">Out =</span> <span class="number">0</span></div><div class="line">      <span class="variable">Arg =</span> <span class="number">0</span></div><div class="line">      <span class="variable">Rune =</span> (len <span class="number">0</span>, cap <span class="number">0</span>) {}</div><div class="line">    }</div><div class="line">    [<span class="number">1</span>] = {</div><div class="line">      <span class="variable">Op =</span> <span class="number">6</span></div><div class="line">      <span class="variable">Out =</span> <span class="number">2</span></div><div class="line">      <span class="variable">Arg =</span> <span class="number">0</span></div><div class="line">      <span class="variable">Rune =</span> (len <span class="number">0</span>, cap <span class="number">0</span>) {}</div><div class="line">    }</div><div class="line">    [<span class="number">2</span>] = {</div><div class="line">      <span class="variable">Op =</span> <span class="number">4</span></div><div class="line">      <span class="variable">Out =</span> <span class="number">0</span></div><div class="line">      <span class="variable">Arg =</span> <span class="number">0</span></div><div class="line">      <span class="variable">Rune =</span> (len <span class="number">0</span>, cap <span class="number">0</span>) {}</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="variable">Start =</span> <span class="number">1</span></div><div class="line">  <span class="variable">NumCap =</span> <span class="number">2</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们还可以通过<code>s</code>命令 <code>Step Into</code>:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(lldb) s</div><div class="line">Process <span class="number">17917</span> stopped</div><div class="line"><span class="subst">*</span> <span class="keyword">thread</span> <span class="variable">#8</span>: tid <span class="subst">=</span> <span class="number">0x0017</span>, <span class="number">0x0000000000067332</span> regexp<span class="built_in">.</span>test<span class="string">`_/code/go/src/regexp.(re=0x0000000208354320, ~r0="").String + 18 at regexp.go:104, stop reason = step in</span></div><div class="line">    frame #0: 0x0000000000067332 regexp.test`_/code/go/src/regexp<span class="built_in">.</span>(re<span class="subst">=</span><span class="number">0x0000000208354320</span>, ~r0<span class="subst">=</span><span class="string">""</span>)<span class="built_in">.</span><span class="built_in">String</span> <span class="subst">+</span> <span class="number">18</span> at regexp<span class="built_in">.</span>go:<span class="number">104</span></div><div class="line">   <span class="number">101</span></div><div class="line">   <span class="number">102</span>         <span class="comment">// String returns the source text used to compile the regular expression.</span></div><div class="line">   <span class="number">103</span>         func (re <span class="subst">*</span>Regexp) <span class="built_in">String</span>() <span class="built_in">string</span> {</div><div class="line"><span class="subst">-&gt; </span><span class="number">104</span>                 <span class="keyword">return</span> re<span class="built_in">.</span>expr</div><div class="line">   <span class="number">105</span>         }</div><div class="line">   <span class="number">106</span></div><div class="line">   <span class="number">107</span>         <span class="comment">// Compile parses a regular expression and returns, if successful,</span></div></pre></td></tr></table></figure>

<p>查看堆栈信息，看看目前我们停在哪儿：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(lldb) bt</div><div class="line">* thread #<span class="number">8</span>: tid = <span class="number">0x0017</span>, <span class="number">0x0000000000067332</span> <span class="built_in">regexp</span>.test`_/code/go/src/<span class="built_in">regexp</span>.(re=<span class="number">0x0000000208354320</span>, ~r0=<span class="string">""</span>).<span class="built_in">String</span> + <span class="number">18</span> at <span class="built_in">regexp</span>.go:<span class="number">104</span>, <span class="keyword">stop</span> reason = <span class="keyword">step</span> <span class="keyword">in</span></div><div class="line">  * frame #<span class="number">0</span>: <span class="number">0x0000000000067332</span> <span class="built_in">regexp</span>.test`_/code/go/src/<span class="built_in">regexp</span>.(re=<span class="number">0x0000000208354320</span>, ~r0=<span class="string">""</span>).<span class="built_in">String</span> + <span class="number">18</span> at <span class="built_in">regexp</span>.go:<span class="number">104</span></div><div class="line">    frame #<span class="number">1</span>: <span class="number">0x00000000000864a0</span> <span class="built_in">regexp</span>.test`_/code/go/src/<span class="built_in">regexp</span>.TestFind(t=<span class="number">0x000000020834a000</span>) + <span class="number">288</span> at find_test.go:<span class="number">151</span></div><div class="line">    frame #<span class="number">2</span>: <span class="number">0x0000000000056e3f</span> <span class="built_in">regexp</span>.test`testing.tRunner(t=<span class="number">0x000000000003b671</span>, test=<span class="number">0x000000020834a000</span>) + <span class="number">191</span> at testing.go:<span class="number">447</span></div><div class="line">    frame #<span class="number">3</span>: <span class="number">0x00000000002995a0</span> <span class="built_in">regexp</span>.test`/code/go/src/<span class="built_in">regexp</span>.statictmp_3759 + <span class="number">96</span></div><div class="line">    frame #<span class="number">4</span>: <span class="number">0x000000000003b671</span> <span class="built_in">regexp</span>.test`runtime.goexit + <span class="number">1</span> at asm_amd64.s:<span class="number">2232</span></div></pre></td></tr></table></figure>

<h2 id="其它调试参考文章">其它调试参考文章</h2>
<ol>
<li><a href="https://github.com/Microsoft/vscode-go/wiki/Debugging-Go-code-using-VS-Code" target="_blank" rel="external">Debugging Go code using VS Code</a></li>
<li><a href="https://golang.org/doc/gdb" target="_blank" rel="external">Debugging Go Code with GDB</a></li>
<li><a href="https://lincolnloop.com/blog/debugging-go-code/" target="_blank" rel="external">Debugging Go Code</a></li>
<li><a href="https://blog.gopheracademy.com/advent-2015/debugging-with-delve/" target="_blank" rel="external">Debugging Go programs with Delve</a></li>
<li><a href="https://www.youtube.com/watch?v=iPBUaDcehJo" target="_blank" rel="external">debug by Goland</a></li>
<li><a href="https://blog.codeship.com/using-gdb-debugger-with-go/" target="_blank" rel="external">Using the gdb debugger with Go</a></li>
<li><a href="https://gocn.io/article/657" target="_blank" rel="external">用 debugger 学习 golang</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>我一般调试Go程序都是通过log日志，性能调试的话通过 pprof 、trace、flamegraph等，主要是Go没有一个很好的集成的debugger,前两年虽然关注了delve，但是在IDE中集成比较粗糙，调试也很慢，所以基本不使用debugger进行调试， 最近看到滴滴的工程师分享的使用debugger在调试Go程序，我觉得有必要在尝试一下这方面的技术了。</p>
<p>本文翻译自 <a href="http://ribrdb.github.io/lldb/" target="_blank" rel="external">Debugging Go Code with LLDB</a>, 更好的调试Go程序的工具是<a href="https://github.com/derekparker/delve" target="_blank" rel="external">delve</a>, 因为它是专门为Go开发， 使用起来也很简单，并且还可以远程调试。delve的命令还可参考： <a href="https://github.com/derekparker/delve/tree/master/Documentation/cli" target="_blank" rel="external">dlv cli</a>，但是流行的通用的基础的debugger也是常用的手段之一。我在译文后面也列出了几篇其它关于go debug的相关文章，有兴趣的话也可以扩展阅读一下。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go网络开发中的两个技术点]]></title>
    <link href="https://colobu.com/2018/03/08/two-issues-in-go-development/"/>
    <id>https://colobu.com/2018/03/08/two-issues-in-go-development/</id>
    <published>2018-03-08T07:32:50.000Z</published>
    <updated>2018-03-08T07:59:36.714Z</updated>
    <content type="html"><![CDATA[<p>最近碰到群里网友问如果检查网络连接的Timeout,联想最近看到的另一个问题， 在这篇文章统一记录一下。</p>
<a id="more"></a>
<h3 id="如果检查一个网络错误是Timeout导致的？">如果检查一个网络错误是Timeout导致的？</h3>
<p>自 Go 1.6开始， 所有的超时导致的网络错误都可以通过<code>net.Error</code>的<code>Timeout()</code>方法检查。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> err, ok := err.(net.Error); ok && err.Timeout() {</div><div class="line">    ……</div><div class="line">}</div></pre></td></tr></table></figure>

<p>更早版本的Go并没有专门的检查Timeout方法。</p>
<p>可以参考： <a href="https://stackoverflow.com/questions/23494950/specifically-check-for-timeout-error" target="_blank" rel="external">https://stackoverflow.com/questions/23494950/specifically-check-for-timeout-error</a></p>
<h3 id="产品中一定不要使用默认的http-Get">产品中一定不要使用默认的<code>http.Get</code></h3>
<p>如果你觉得方便，直接使用<code>http.Get</code>或者类似的方法发送请求，可能会导致一些问题， 因为这默认是使用<code>DefaultClient</code>作为client:</p>
<ol>
<li>多goroutine共享，这意味着在别处对<code>DefaultClient</code>的改动会影响你当前的使用</li>
<li>未设置connection timeout和 read/write timeout</li>
<li>默认的idle connection等设置可能不满足你的需求</li>
</ol>
<p>一个具体的使用默认的client导致的问题可以参考 <a href="https://medium.com/@nate510/don-t-use-go-s-default-http-client-4804cb19f779" target="_blank" rel="external">Don’t use Go’s default HTTP client (in production)</a>。</p>
<p>所以Go开发过程中最好使用自己定制的Client:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> timeout = time.Duration<span class="number">(2</span> * time.Second)</div><div class="line"></div><div class="line"><span class="keyword">func</span> dialTimeout(network, addr <span class="typename">string</span>) (net.Conn, error) {</div><div class="line">    <span class="keyword">return</span> net.DialTimeout(network, addr, timeout)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    transport := http.Transport{</div><div class="line">        Dial: dialTimeout,</div><div class="line">        Proxy: ...,</div><div class="line">        MaxIdleConns: ...,</div><div class="line">        MaxIdleConnsPerHost: ...,</div><div class="line">        IdleConnTimeout: ...,</div><div class="line">        ResponseHeaderTimeout: ...,</div><div class="line">        DisableCompression:...,</div><div class="line">    }</div><div class="line"></div><div class="line">    client := http.Client{</div><div class="line">        Transport: &transport,</div><div class="line">    }</div><div class="line"></div><div class="line">    resp, err := client.Get(<span class="string">"http://some.url"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>酌情设置<code>Transport</code>的参数。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近碰到群里网友问如果检查网络连接的Timeout,联想最近看到的另一个问题， 在这篇文章统一记录一下。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
</feed>
