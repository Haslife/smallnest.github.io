<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://colobu.com/"/>
  <updated>2017-10-27T03:08:14.717Z</updated>
  <id>http://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[如何整个替换git master分支?]]></title>
    <link href="http://colobu.com/2017/10/24/How-to-replace-master-branch-in-git/"/>
    <id>http://colobu.com/2017/10/24/How-to-replace-master-branch-in-git/</id>
    <published>2017-10-24T06:18:24.000Z</published>
    <updated>2017-10-24T06:45:19.000Z</updated>
    <content type="html"><![CDATA[<p>最近需要将一个项目的master分支用另一个分支完全替换， 查找了相关资料，最后追溯到stackoverflow上的一个提问: <a href="https://stackoverflow.com/questions/2862590/how-to-replace-master-branch-in-git-entirely-from-another-branch" target="_blank" rel="external">How to replace master branch in git, entirely, from another branch？</a>。</p>
<p>网友给出了两种方案。</p>
<p>假设需要将<code>seotweaks</code>分支替换成<code>master</code>。</p>
<p><strong>1、</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git checkout seotweaks</div><div class="line">git merge <span class="operator">-s</span> ours master</div><div class="line">git checkout master</div><div class="line">git merge seotweaks</div></pre></td></tr></table></figure>

<p><code>-s ours</code>是<code>--strategy=ours</code>的简写。</p>
<p><strong>2、</strong><br>如果上面的操作有问题， 还可以使用下面这个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git branch -m master old-master</div><div class="line">git branch -m seotweaks master</div><div class="line">git push -f origin master</div></pre></td></tr></table></figure>

<p><code>-m</code>用来重命名分支。</p>
<p><strong>This might remove commits in origin master</strong>。</p>
<p><a href="https://git-scm.com/docs" target="_blank" rel="external">git cmd</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近需要将一个项目的master分支用另一个分支完全替换， 查找了相关资料，最后追溯到stackoverflow上的一个提问: <a href="https://stackoverflow.com/questions/2862590/how-to-replace-maste]]>
    </summary>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译] Kafka 存储的工作机制]]></title>
    <link href="http://colobu.com/2017/10/12/How-Kafka%E2%80%99s-Storage-Internals-Work/"/>
    <id>http://colobu.com/2017/10/12/How-Kafka’s-Storage-Internals-Work/</id>
    <published>2017-10-12T07:35:15.000Z</published>
    <updated>2017-10-12T11:40:40.000Z</updated>
    <content type="html"><![CDATA[<p>翻译自 Kafka/Confluent 公司的工程师 Travis Jeffery 的文章: <a href="https://thehoard.blog/how-Kafkas-storage-internals-work-3a29b02e026" target="_blank" rel="external">How Kafka’s Storage Internals Work</a>。</p>
<p>通过本文我会帮助你理解Kafka是如何存储它的数据的。<br>对于调优Kafka的性能以及了解broker配置实际是干什么的， 了解Kafka的存储很有用。 我受Kafka的简单性的启发， 用我所学开始实现一个Go的Kafka: <a href="https://github.com/travisjeffery/jocko" target="_blank" rel="external">jocko</a>。</p>
<p>那么， Kafka存储内部是如何工作的呢？<br><a id="more"></a></p>
<h2 id="Kafka_的存储单元是分区">Kafka 的存储单元是分区</h2>
<p>分区(partition)是有序的， 新的不可变的消息增加到尾部。一个分区不能扩多个boker，甚至不能跨多个磁盘。</p>
<p><img src="1.png" alt=""></p>
<h2 id="保留策略管理kakfa如何保留消息">保留策略管理kakfa如何保留消息</h2>
<p>你可以指定保留多少数据和多久的数据(大小和时间策略)， 之后kakfa会按照顺序清理数据， 不管数据是否已经倍消费。</p>
<h2 id="分区被分割成多个分段">分区被分割成多个分段</h2>
<p>所以Kafka会定期地查找磁盘中需要清理的消息。如果一个分区单一的文件比较打， 操作会很慢，而且容易出错。为了解决这个问题(和其它问题)， 分区文件被分割成几个分段(segment)。</p>
<p>当Kafka往分区中写数据时， 它实际是往分段文件中写的。如果这个分段文件达到文件大小的限制，一个新的分段文件会被创建，以后往这个分区上写的数据会写入到这个新的分段文件中。</p>
<p>分段文件使用它们的基偏移量(<code>base offset</code>)作为文件名。 一个分段文件的基偏移量 要大于前一个分段中的偏移量， 小于或者等于本分段文件中的偏移量。</p>
<p><img src="2.png" alt=""></p>
<p>在磁盘中， 每个分区一个文件夹， 包含分段文件， 分段文件由索引文件和log文件两个文件组成。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ tree Kafka | head -<span class="keyword">n</span> <span class="number">6</span></div><div class="line">Kafka</div><div class="line">├── events-<span class="number">1</span></div><div class="line">│ ├── <span class="number">00000000003064504069</span>.<span class="built_in">index</span></div><div class="line">│ ├── <span class="number">00000000003064504069</span>.<span class="built_in">log</span></div><div class="line">│ ├── <span class="number">00000000003065011416</span>.<span class="built_in">index</span></div><div class="line">│ ├── <span class="number">00000000003065011416</span>.<span class="built_in">log</span></div></pre></td></tr></table></figure>

<h2 id="分段日志文件存储消息">分段日志文件存储消息</h2>
<p>每个消息包含它的值，偏移量，时间戳，key,消息大小、编解码器器、checksum 以及消息的版本。</p>
<p>磁盘上的数据格式和broker从producer接收到网络消息时一样的， 也和发送给consumer的消息格式一样。这种设计的好处时可以使用<a href="https://www.ibm.com/developerworks/library/j-zerocopy/" target="_blank" rel="external">零拷贝</a>进行数据传输。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ bin/Kafka-<span class="command">run</span>-<span class="type">class</span>.sh Kafka.tools.DumpLogSegments <span class="comment">--deep-iteration --print-data-log --files /data/Kafka/events-1/00000000003065011416.log | head -n 4</span></div><div class="line">Dumping /data/Kafka/appusers-<span class="number">1</span>/<span class="number">00000000003065011416.</span><span class="command">log</span></div><div class="line">Starting <span class="command">offset</span>: <span class="number">3065011416</span></div><div class="line"><span class="command">offset</span>: <span class="number">3065011416</span> position: <span class="number">0</span> isvalid: <span class="constant">true</span> payloadsize: <span class="number">2820</span> magic: <span class="number">1</span> compresscodec: NoCompressionCodec crc: <span class="number">811055132</span> payload: {<span class="string">"name"</span>: <span class="string">"Travis"</span>, msg: <span class="string">"Hey, what's up?"</span>}</div><div class="line"><span class="command">offset</span>: <span class="number">3065011417</span> position: <span class="number">1779</span> isvalid: <span class="constant">true</span> payloadsize: <span class="number">2244</span> magic: <span class="number">1</span> compresscodec: NoCompressionCodec crc: <span class="number">151590202</span> payload: {<span class="string">"name"</span>: <span class="string">"Wale"</span>, msg: <span class="string">"Starving."</span>}</div></pre></td></tr></table></figure>

<h2 id="分段索引文件记录消息在日志文件中的位置(偏移量)">分段索引文件记录消息在日志文件中的位置(偏移量)</h2>
<p>分段索引文件记录消息在日志文件中的位置(偏移量)。</p>
<p><img src="3.png" alt=""></p>
<p>索引文件映射到内存中。偏移量的查找使用二分查找， 找到最接近偏移量的位置(小于或者等于目标偏移量)。</p>
<p>索引文件是由8字节的entry组成。4个字节存储相相对偏移量， 4个字节存储位置。相对偏移量加上基偏移量才是实际偏移量，这样只用4个字节久可以了。 例如，假设基偏移量是<code>10000000000000000000</code>，之后的偏移量<code>10000000000000000001</code>、<code>10000000000000000002</code>只需用<code>1</code>、<code>2</code>来表示即可。</p>
<h2 id="Kafka保持压缩的消息">Kafka保持压缩的消息</h2>
<p>Producer发送的一批消息会呗压缩在一起，作为一个消息的payload发送给broker。和前面的介绍一样，数据保持原样压缩存在磁盘上。</p>
<p><img src="4.png" alt=""></p>
<h2 id="回顾">回顾</h2>
<p>Now you know how Kafka storage internals work:</p>
<p>现在， 你应该了解了Kafka是如何存储日志(消息)的：</p>
<ul>
<li>分区时存储的基本单元</li>
<li>分区文件被分割成分段文件</li>
<li>分段文件包含两个文件：索引文件和日志</li>
<li>索引文件记录消息在日志文件中的位置，用来快速查询消息</li>
<li>索引文件中存在的是相对偏移值</li>
<li>压缩的批量消息保持不变存储</li>
<li>磁盘上的文件和收发的消息时一样的</li>
</ul>
<h2 id="实现Go语言的kafak">实现Go语言的kafak</h2>
<p>我正在用Go实现Kafka。 目前我已经实现了在单个broker上读写分段，正在实现分布式。欢迎贡献。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>翻译自 Kafka/Confluent 公司的工程师 Travis Jeffery 的文章: <a href="https://thehoard.blog/how-Kafkas-storage-internals-work-3a29b02e026" target="_blank" rel="external">How Kafka’s Storage Internals Work</a>。</p>
<p>通过本文我会帮助你理解Kafka是如何存储它的数据的。<br>对于调优Kafka的性能以及了解broker配置实际是干什么的， 了解Kafka的存储很有用。 我受Kafka的简单性的启发， 用我所学开始实现一个Go的Kafka: <a href="https://github.com/travisjeffery/jocko" target="_blank" rel="external">jocko</a>。</p>
<p>那么， Kafka存储内部是如何工作的呢？<br>]]>
    
    </summary>
    
      <category term="Kafka" scheme="http://colobu.com/tags/Kafka/"/>
    
      <category term="大数据" scheme="http://colobu.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GOMAXPROCS需要设置吗？]]></title>
    <link href="http://colobu.com/2017/10/11/interesting-things-about-GOMAXPROCS/"/>
    <id>http://colobu.com/2017/10/11/interesting-things-about-GOMAXPROCS/</id>
    <published>2017-10-11T06:27:38.000Z</published>
    <updated>2017-10-11T07:41:59.000Z</updated>
    <content type="html"><![CDATA[<p>自 Go 1.5开始， Go的<code>GOMAXPROCS</code>默认值已经设置为 CPU的核数， 这允许我们的Go程序充分使用机器的每一个CPU,最大程度的提高我们程序的并发性能， 而且，在大部分情况下， 我们并不会去设置这个参数。因为默认值已经足够好了， 以至于fasthttp的作者valyala<a href="https://github.com/golang/go/issues/20303" target="_blank" rel="external">提议</a>禁止<code>runtime.GOMAXPROCS</code>设置这个数值, 对于所有的case, <code>GOMAXPROCS</code>默认值是否是最好的值呢？</p>
<p><a href="https://github.com/dgraph-io/badger" target="_blank" rel="external">badger</a>的作者Manish Rai Jain就遇到了这样一个<a href="https://groups.google.com/forum/#!topic/golang-nuts/jPb_h3TvlKE/discussion" target="_blank" rel="external">问题</a>。</p>
<a id="more"></a>
<p>Manish Rai Jain 写了一段<a href="https://github.com/dgraph-io/badger-bench/blob/master/randread/main.go" target="_blank" rel="external">Go代码</a>, 用来测试Go的读写SSD的性能，看看是否能打到Linux的I/O测试工具<a href="https://linux.die.net/man/1/fio" target="_blank" rel="external">fio</a>的读写性能。 使用fio，可以在 AWS(Amazon i3.large instance with NVMe SSD)达到100K IOPS， 但是使用这个Go程序，怎么也无法接近这个IOPS。</p>
<p>他尝试了三个case:</p>
<ol>
<li>单个goroutine随机读</li>
<li>使用一定数量的goroutine随机读</li>
<li>类似#2,但是使用一个channel</li>
</ol>
<p>明显#1, #3比不上#2的性能，但是#2怎么也达不到fio的吞吐率。如果大家都使用小于CPU的核数, Go和Fio的吞吐率接近，但是如果把goroutine设置为大于CPU的核数，Fio性能提升明显，直到达到最大的IOPS，但是Go程序却没有显著变化。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ fio --name=randread --ioengine=psync --iodepth=<span class="number">32</span> --rw=randread --bs=<span class="number">4</span>k --direct=<span class="number">0</span> --size=<span class="number">2</span>G --numjobs=<span class="number">16</span> --runtime=<span class="number">120</span> --group_reporting</div><div class="line">Gives around <span class="number">62</span>K, tested via sar <span class="operator">-d</span> <span class="number">1</span> -p, <span class="keyword">while</span></div><div class="line"></div><div class="line">$ go build . && GOMAXPROCS=<span class="number">16</span> ./randread --dir ~/diskfio --jobs <span class="number">16</span> --num <span class="number">2000000</span> --mode <span class="number">1</span></div><div class="line">Gives around <span class="number">44</span>K, via sar. Number of cores on my machine are <span class="number">4</span>.</div></pre></td></tr></table></figure>

<p>通过将<code>GOMAXPROCS</code>设置更大的数(64/128, 数倍CPU核数), Go 程序可以取得几乎和Fio一样的吞吐率。</p>
<p>在今年的Gophercon上，Manish Rai Jain碰到了Russ Cox，问到了这个问题：</p>
<blockquote>
<p>If File::Read blocks goroutines, which then spawn new OS threads, in a long running job, there should be plenty of OS threads created already, so the random read throughput should increase over time and stabilize to the maximum possible value. But, that&#39;s not what I see in my benchmarks.</p>
</blockquote>
<p>大意是如果文件读取倍 block， Go会产生新的OS Thread,因为有很多的OS Thread,所以随机读的吞吐率应该也会上升才对，但是实际却不是。</p>
<p>Russ Cox解释说<code>GOMAXPROCS</code>就像一个多路复用器，所以<code>GOMAXPROCS</code>就会是一个瓶颈。</p>
<blockquote>
<p>The GOMAXPROCS in a way acts like a multiplexer. From docs, &quot;the GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously.&quot; Which basically means, all reads must first be run only via GOMAXPROCS number of goroutines, before switching over to some OS thread (not really a switch, but conceptually speaking). This introduces a bottleneck for throughput.</p>
</blockquote>
<p>最后Manish Rai Jain在他的高性能的K/V数据库调大了这个<a href="https://github.com/dgraph-io/dgraph/commit/30237a1429debab73eff38fea2f724914ca38b77" target="_blank" rel="external">参数</a>。</p>
<p>这是一个有趣的讨论，很明显默认的<code>GOMAXPROCS</code>在某些情况下也不是最好的值，特别是在Manish Rai Jain这种写block的情况下，设置<code>GOMAXPROCS</code>更大一些会提高I/O的吞吐率。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>自 Go 1.5开始， Go的<code>GOMAXPROCS</code>默认值已经设置为 CPU的核数， 这允许我们的Go程序充分使用机器的每一个CPU,最大程度的提高我们程序的并发性能， 而且，在大部分情况下， 我们并不会去设置这个参数。因为默认值已经足够好了， 以至于fasthttp的作者valyala<a href="https://github.com/golang/go/issues/20303" target="_blank" rel="external">提议</a>禁止<code>runtime.GOMAXPROCS</code>设置这个数值, 对于所有的case, <code>GOMAXPROCS</code>默认值是否是最好的值呢？</p>
<p><a href="https://github.com/dgraph-io/badger" target="_blank" rel="external">badger</a>的作者Manish Rai Jain就遇到了这样一个<a href="https://groups.google.com/forum/#!topic/golang-nuts/jPb_h3TvlKE/discussion" target="_blank" rel="external">问题</a>。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[badger 一个高性能的LSM K/V store]]></title>
    <link href="http://colobu.com/2017/10/11/badger-a-performant-k-v-store/"/>
    <id>http://colobu.com/2017/10/11/badger-a-performant-k-v-store/</id>
    <published>2017-10-11T01:21:54.000Z</published>
    <updated>2017-10-11T04:17:49.000Z</updated>
    <content type="html"><![CDATA[<p>大家好，给大家介绍一下， 新晋的高性能的 K/V数据库: <a href="https://github.com/dgraph-io/badger" target="_blank" rel="external">badger</a>。</p>
<p>这是 <a href="https://dgraph.io" target="_blank" rel="external">dgraph.io</a>开发的一款基于 log structured merge (LSM) tree 的 key-value 本地数据库， 使用 Go 开发。</p>
<p>事实上，市面上已经有一些知名的基于LSM tree的k/v数据库， 比如 <a href="https://github.com/google/leveldb" target="_blank" rel="external">leveldb</a>、<a href="https://github.com/syndtr/goleveldb" target="_blank" rel="external">goleveldb</a>、<a href="http://rocksdb.org" target="_blank" rel="external">rocksdb</a>、<a href="https://github.com/boltdb/bolt" target="_blank" rel="external">boltdb</a>, 可是为什么还要创造新的轮子呢。我们不妨从LSM说起。</p>
<a id="more"></a>
<h2 id="LSM_Tree">LSM Tree</h2>
<p><img src="LSM.png" alt=""></p>
<p><a href="https://en.wikipedia.org/wiki/Log-structured_merge-tree" target="_blank" rel="external">Log-structured merge-tree</a> (简称 LSM tree) 可以追溯到1996年 Patrick O&#39;Neil等人的<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.44.2782&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">论文</a>。最简单的LSM tree是两层树状结构C0,C1。 C0比较小，驻留在内存，当C0超过一定的大小， 一些连续的片段会从C0移动到磁盘中的C1中，这是一次merge的过程。在实际的应用中， 一般会分为更多的层级(level)， 而层级C0都会驻留在内存中。<br><img src="LSM_Tree.png" alt=""></p>
<p>2006年， Google发表了它的那篇著名的文章: <a href="https://www.google.com.sg/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjb2euMvufWAhVGNo8KHTd5CskQFggnMAA&amp;url=https%3A%2F%2Fresearch.google.com%2Farchive%2Fbigtable-osdi06.pdf&amp;usg=AOvVaw16gNeVUuapPgFX2eTD2tUI" target="_blank" rel="external">Bigtable: A Distributed Storage System for Structured Data</a>, 不但催生了 HBase这样的项目的诞生， 而且广泛地引起了大家对 LSM tree这种数据结构重视。</p>
<p><img src="bigtable.png" alt=""></p>
<p>之后， 2007 HBase, 2010年 Cassandra， 2011年 LevelDB, 2013年 RocksDB, 2015年 InfluxDB的 LSM tree引擎等众多的 基于LSM tree的k/v数据库(引擎)诞生。</p>
<p><a href="https://github.com/google/leveldb" target="_blank" rel="external">LevelDB</a> 也是由Google的牛人 Jeffrey Dean 和 Sanjay Ghemawat创建的，被多个NoSql数据库用作底层的存储引擎。 <a href="https://github.com/facebook/rocksdb" target="_blank" rel="external">RocksDB</a> fork自LevelDB，但为多核和SSD做了很多的优化， 增加了一些有用的特性，比如Bloom filters、事务、TTL等，被Facebook、Yahoo!和Linkedin等公司使用。</p>
<h2 id="badger">badger</h2>
<p>回到开始的问题， 既然已经有了一些优秀的开源的LSM tree的项目，为什么dgraph还要创建一个新的轮子呢？</p>
<p>答案是: <strong>更好的性能</strong>。</p>
<p>dgraph开发一个新的基于LSM tree的数据库引擎badger是基于这篇论文： <a href="https://www.usenix.org/system/files/conference/fast16/fast16-papers-lu.pdf" target="_blank" rel="external">WiscKey: Separating Keys from Values<br>in SSD-conscious Storage</a>, 这篇论文很新， 也就是去年(2016年)发表的，这篇论文提出了一种新的设计，专门为SSD所优化，将key和value分别存储以减少I/O放大。论文是由斯康辛大学麦迪逊分校的Lanyue Lu等人完成，Lanyue Lu毕业于中国科大，现在就职于Google。论文中提供了一个测试数据，加载数据库要比LevelDB快2.5–111倍，随机lookup要快1.6-14倍。</p>
<p>dgraph实现的这个产品叫做 <a href="https://github.com/dgraph-io/badger" target="_blank" rel="external">Badger</a>, 对于随机读，Badger至少要比RocksDB快3.5倍，对于值的大小从128B到16KB，数据加载Badger比LevelDB快0.86 - 14倍。</p>
<p>Badger分离的key和value,只有key存在LSM tree中， value存在WAL中，叫做value log。通常情况下，key比较小，所以LSM tree比较小，当获取value值的时候，再从SSD存储中读取。现在的SSD， 比如Samsung 960 Pro，对于4KB的数据块，可以提供44万的读操作/秒，这相当快了。</p>
<p>LSM tree最主要的性能消耗在于 compaction 过程。 在compaction的时候，多个文件需要读进内存，排序，然后再写回。每个文件都固定大小，如果文件中包含value, 文件大小会显著的增加，compaction会更频繁地发生。Badger不存储value，而是存储value的指针， 如果每个键是16， 每个value的指针是16 byte的话，一个64MB的文件就可以存储200万个键值对。</p>
<p>因为Badger不存储value，而是存储value的指针,compaction的时候只移动key和value指针，对于 1KB大小的value和16 byte的key， 写放大为<code>(10*16 + 1024)/(16 + 1024) ~ 1.14</code>。</p>
<p>因为Badger的LSM tree比较小，所以它的层级相对于普通的LSM tree要少，这也意味着查找会更少。例如1KB大小的value, 22byte的key, 7500万条数据的原始大小是 72GB,但是对于Badger的LSM tree来说，只需要1.7G,完全可以放在内存中，这也是Badger的随机读比RocksDB快3.5的原因。</p>
<h2 id="容错">容错</h2>
<p>LSM tree将所有的更新写入到内存中的memtable，一旦填满， memtable回替换为immutable memtable，最终回写入到磁盘中的level0中。</p>
<p>如果机器宕机，内存表中的数据就会丢失。k/v数据库一般使用write-ahead log (WAL)来处理这个问题，Badger也一样。Badger会记录memtable的最后一个值的指针，当恢复的时候，它可以replay和重建LSM tree。</p>
<h2 id="文件大小">文件大小</h2>
<p>Badger还使用技术对value值进行压缩，以便是log文件更小。</p>
<p>对于1KB的value,16 byte的key, 7500万条数据，RocksDB的 LSM tree 是 50GB， Badger的 value log文件是74GB(未压缩)， LSM tree 是 1.7GB。</p>
<p>和RocksDB的Benchmark比较：</p>
<p><img src="badger-benchmarks.png" alt=""></p>
<h2 id="使用">使用</h2>
<p>Badger使用起来超级简单， 配置参数页不多，而且提供了默认的配置参数。</p>
<p>下面的代码是读写查和便利的代码，所有的操作都是在事务中完成的， Badger的事物是基于MVCC实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/dgraph-io/badger"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	opts := badger.DefaultOptions</div><div class="line">	opts.Dir = <span class="string">"./data"</span></div><div class="line">	opts.ValueDir = <span class="string">"./data"</span></div><div class="line">	db, err := badger.Open(&opts)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatal(err)</div><div class="line">	}</div><div class="line">	<span class="keyword">defer</span> db.Close()</div><div class="line"></div><div class="line">	<span class="comment">// set</span></div><div class="line">	err = db.Update(<span class="keyword">func</span>(txn *badger.Txn) error {</div><div class="line">		err := txn.Set([]<span class="typename">byte</span>(<span class="string">"answer"</span>), []<span class="typename">byte</span>(<span class="string">"42"</span>),<span class="number"> 0</span>)</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	})</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// get</span></div><div class="line">	err = db.View(<span class="keyword">func</span>(txn *badger.Txn) error {</div><div class="line">		item, err := txn.Get([]<span class="typename">byte</span>(<span class="string">"answer"</span>))</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		}</div><div class="line">		val, err := item.Value()</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		}</div><div class="line">		fmt.Printf(<span class="string">"The answer is: %s\n"</span>, val)</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">	})</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// iterate</span></div><div class="line">	err = db.View(<span class="keyword">func</span>(txn *badger.Txn) error {</div><div class="line">		opts := badger.DefaultIteratorOptions</div><div class="line">		opts.PrefetchSize =<span class="number"> 10</span></div><div class="line">		it := txn.NewIterator(opts)</div><div class="line">		<span class="keyword">for</span> it.Rewind(); it.Valid(); it.Next() {</div><div class="line">			item := it.Item()</div><div class="line">			k := item.Key()</div><div class="line">			v, err := item.Value()</div><div class="line">			<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">				<span class="keyword">return</span> err</div><div class="line">			}</div><div class="line">			fmt.Printf(<span class="string">"key=%s, value=%s\n"</span>, k, v)</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">	})</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// Prefix scans</span></div><div class="line">	db.View(<span class="keyword">func</span>(txn *badger.Txn) error {</div><div class="line">		it := txn.NewIterator(badger.DefaultIteratorOptions)</div><div class="line">		prefix := []<span class="typename">byte</span>(<span class="string">"ans"</span>)</div><div class="line">		<span class="keyword">for</span> it.Seek(prefix); it.ValidForPrefix(prefix); it.Next() {</div><div class="line">			item := it.Item()</div><div class="line">			k := item.Key()</div><div class="line">			v, err := item.Value()</div><div class="line">			<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">				<span class="keyword">return</span> err</div><div class="line">			}</div><div class="line">			fmt.Printf(<span class="string">"key=%s, value=%s\n"</span>, k, v)</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">	})</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// iterate keys</span></div><div class="line">	err = db.View(<span class="keyword">func</span>(txn *badger.Txn) error {</div><div class="line">		opts := badger.DefaultIteratorOptions</div><div class="line">		opts.PrefetchValues = <span class="constant">false</span></div><div class="line">		it := txn.NewIterator(opts)</div><div class="line">		<span class="keyword">for</span> it.Rewind(); it.Valid(); it.Next() {</div><div class="line">			item := it.Item()</div><div class="line">			k := item.Key()</div><div class="line">			fmt.Printf(<span class="string">"key=%s\n"</span>, k)</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">	})</div><div class="line"></div><div class="line">	<span class="comment">// delete</span></div><div class="line">	err = db.Update(<span class="keyword">func</span>(txn *badger.Txn) error {</div><div class="line">		<span class="keyword">return</span> txn.Delete([]<span class="typename">byte</span>(<span class="string">"answer"</span>))</div><div class="line">	})</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="参考文档">参考文档</h2>
<ol>
<li><a href="https://blog.dgraph.io/post/badger/" target="_blank" rel="external">https://blog.dgraph.io/post/badger/</a></li>
<li><a href="https://www.slideshare.net/ssuser7e134a/log-structured-merge-tree" target="_blank" rel="external">https://www.slideshare.net/ssuser7e134a/log-structured-merge-tree</a></li>
<li><a href="https://blog.dgraph.io/post/badger/" target="_blank" rel="external">https://blog.dgraph.io/post/badger/</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>大家好，给大家介绍一下， 新晋的高性能的 K/V数据库: <a href="https://github.com/dgraph-io/badger" target="_blank" rel="external">badger</a>。</p>
<p>这是 <a href="https://dgraph.io" target="_blank" rel="external">dgraph.io</a>开发的一款基于 log structured merge (LSM) tree 的 key-value 本地数据库， 使用 Go 开发。</p>
<p>事实上，市面上已经有一些知名的基于LSM tree的k/v数据库， 比如 <a href="https://github.com/google/leveldb" target="_blank" rel="external">leveldb</a>、<a href="https://github.com/syndtr/goleveldb" target="_blank" rel="external">goleveldb</a>、<a href="http://rocksdb.org" target="_blank" rel="external">rocksdb</a>、<a href="https://github.com/boltdb/bolt" target="_blank" rel="external">boltdb</a>, 可是为什么还要创造新的轮子呢。我们不妨从LSM说起。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Convert Shadowsocks into an HTTP proxy]]></title>
    <link href="http://colobu.com/2017/10/10/Convert-Shadowsocks-into-an-HTTP-proxy/"/>
    <id>http://colobu.com/2017/10/10/Convert-Shadowsocks-into-an-HTTP-proxy/</id>
    <published>2017-10-10T07:30:27.000Z</published>
    <updated>2017-10-10T07:35:17.000Z</updated>
    <content type="html"><![CDATA[<p><strong>备用，不解释</strong></p>
<h2 id="socks5_to_http_proxy">socks5 to http proxy</h2>
<p>1、 首先安装 polipo, 设置parent proxy to Ss:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">apt-get install polipo</div><div class="line">service polipo stop</div><div class="line">polipo socksParentProxy=localhost:<span class="number">1080</span> &</div></pre></td></tr></table></figure>

<p>macosx运行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew install polipo</div><div class="line">polipo socksParentProxy=localhost:<span class="number">1080</span> &</div></pre></td></tr></table></figure>

<p>设置全局http proxy:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">http_proxy=<span class="keyword">http</span>://localhost:<span class="number">8123</span> apt-<span class="built_in">get</span> update</div><div class="line">http_proxy=<span class="keyword">http</span>://localhost:<span class="number">8123</span> curl www.google.com</div><div class="line">http_proxy=<span class="keyword">http</span>://localhost:<span class="number">8123</span> wget www.google.com</div></pre></td></tr></table></figure>

<p>对于git:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git config --<span class="keyword">global</span> http.proxy <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8123</span></div><div class="line">git <span class="keyword">clone</span> https:<span class="comment">//github.com/xxx/xxx.git</span></div><div class="line">git xxx</div><div class="line">git xxx</div><div class="line">git config --<span class="keyword">global</span> --<span class="keyword">unset</span>-all http.proxy</div></pre></td></tr></table></figure>

<h2 id="glide_mirror">glide mirror</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ rm -rf ~/.glide</div><div class="line">$ mkdir -p ~/.glide</div><div class="line">$ glide mirror <span class="built_in">set</span> <span class="keyword">https</span>://golang.org/x/mobile <span class="keyword">https</span>://github.com/golang/mobile <span class="comment">--vcs git</span></div><div class="line">$ glide mirror <span class="built_in">set</span> <span class="keyword">https</span>://golang.org/x/crypto <span class="keyword">https</span>://github.com/golang/crypto <span class="comment">--vcs git</span></div><div class="line">$ glide mirror <span class="built_in">set</span> <span class="keyword">https</span>://golang.org/x/net <span class="keyword">https</span>://github.com/golang/net <span class="comment">--vcs git</span></div><div class="line">$ glide mirror <span class="built_in">set</span> <span class="keyword">https</span>://golang.org/x/tools <span class="keyword">https</span>://github.com/golang/tools <span class="comment">--vcs git</span></div><div class="line">$ glide mirror <span class="built_in">set</span> <span class="keyword">https</span>://golang.org/x/<span class="keyword">text</span> <span class="keyword">https</span>://github.com/golang/<span class="keyword">text</span> <span class="comment">--vcs git</span></div><div class="line">$ glide mirror <span class="built_in">set</span> <span class="keyword">https</span>://golang.org/x/image <span class="keyword">https</span>://github.com/golang/image <span class="comment">--vcs git</span></div><div class="line">$ glide mirror <span class="built_in">set</span> <span class="keyword">https</span>://golang.org/x/sys <span class="keyword">https</span>://github.com/golang/sys <span class="comment">--vcs git</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p><strong>备用，不解释</strong></p>
<h2 id="socks5_to_http_proxy">socks5 to http proxy</h2>
<p>1、 首先安装 polipo, 设置parent proxy to Ss:</p>
<figure ]]>
    </summary>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]KV存储的对比]]></title>
    <link href="http://colobu.com/2017/10/10/comparision-of-kv-datastore/"/>
    <id>http://colobu.com/2017/10/10/comparision-of-kv-datastore/</id>
    <published>2017-10-10T03:12:28.000Z</published>
    <updated>2017-10-10T03:39:10.000Z</updated>
    <content type="html"><![CDATA[<p>本文转自饿了么的高级架构师陈东明(cadem)发布于云栖社区的文章: <a href="https://yq.aliyun.com/articles/85634?spm=5176.8091938.0.0.Bck5cC" target="_blank" rel="external">KV存储的对比</a>。作者还整理了另外一篇文章: <a href="https://yq.aliyun.com/articles/85619?spm=5176.8091938.0.0.Bck5cC" target="_blank" rel="external">存储系统的分类</a>,列举了常见的一些kv存储模型和实现。</p>
<p>最近对各种KV存储进行一个比较，从存储引擎到存储引擎的类型，到单机版的kvstore，再到分布式kvstore集群。</p>
<a id="more"></a>
<h2 id="存储引擎的类型">存储引擎的类型</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>全称</th>
</tr>
</thead>
<tbody>
<tr>
<td>btree</td>
<td></td>
</tr>
<tr>
<td>LSH</td>
<td>Log-Structured Hash Table</td>
</tr>
<tr>
<td>LSM</td>
<td>Log-Structured Merge Tree</td>
</tr>
<tr>
<td>FractalTree</td>
<td>分型树</td>
</tr>
</tbody>
</table>
<h2 id="存储引擎">存储引擎</h2>
<p><span id="thx">Welcome to Oschina Tools website</span>            <table><thead><tr><th>类型</th><th>名称</th><th>语言</th><th>备注</th><th>应用在___</th><th>dbengine排名</th><th>出品</th></tr></thead><tbody><tr><td>berkeleyDB</td><td>BTREE, HASH, QUEUE, RECNO</td><td>C,Java</td><td></td><td></td><td>No.9</td><td>oracle</td></tr><tr><td>Wiredtiger</td><td>btree, LSM</td><td>C</td><td></td><td>mongodb</td><td>No.24</td><td>WiredTiger/mongodb</td></tr><tr><td>Tokyo Cabinet /Kyoto Cabinet</td><td>b+tree,hash table</td><td></td><td></td><td>nmdb,Kyoto Tycoon</td><td>NO.27/No.36</td><td>FAL Labs</td></tr><tr><td>LMDB</td><td>btree</td><td>C</td><td></td><td>OpenLDAP</td><td></td><td>symas</td></tr><tr><td>BoltDB</td><td>btree</td><td>Go</td><td>LMDB的go版本</td><td></td><td></td><td></td></tr><tr><td>leveldb</td><td>LSM</td><td>c++</td><td></td><td></td><td>No.15</td><td>google</td></tr><tr><td>goleveldb</td><td>LSM</td><td>Go</td><td>leveldb的go版本</td><td></td><td></td><td>个人</td></tr><tr><td>levigo</td><td>LSM</td><td>Go</td><td>Go wrapper for LevelDB</td><td></td><td></td><td>个人</td></tr><tr><td>rocksdb</td><td>LSM</td><td>c++,java</td><td></td><td></td><td>No.18</td><td>facebook</td></tr><tr><td>gorocksdb</td><td>LSM</td><td>Go</td><td>Go wrapper for RocksDB</td><td></td><td></td><td>个人</td></tr><tr><td>mongo-rocks</td><td>LSM</td><td>C++</td><td></td><td>RocksDB Storage Engine Module for MongoDB</td><td></td><td>mongo partner</td></tr><tr><td>bitcast</td><td>LSH</td><td>C</td><td></td><td>beansdb,riak</td><td></td><td>basho</td></tr><tr><td>PerconaFT</td><td>FractalTree</td><td>C++</td><td>Mysql存储引擎之TokuDB</td><td>percona</td><td></td><td></td></tr></tbody></table></p>
<h2 id="单机kvstore">单机kvstore</h2>
<table><thead><tr><th>类型</th><th>名称</th><th>采用的存储引擎</th><th>语言</th><th>出品</th><th>主从复制</th><th>github star</th></tr></thead><tbody><tr><td>kv对</td><td>nmdb</td><td>qdbm, berkeley db, tokyo cabinet,tdb</td><td>C</td><td>个人Alberto Bertogli</td><td></td><td></td></tr><tr><td>kv对</td><td>memcachedb</td><td>Berkeley DB</td><td>C</td><td>新浪</td><td>yes</td><td></td></tr><tr><td>kv对</td><td>Kyoto Tycoon</td><td>Kyoto Cabinet</td><td>C/C++</td><td>FAL Labs</td><td></td><td></td></tr><tr><td>结构化kv(redis兼容）</td><td>ssdb</td><td>leveddb</td><td>C/C++</td><td>个人ideawu</td><td>yes</td><td>4k+</td></tr><tr><td>结构化kv(redis兼容）</td><td>ssdb-rocks</td><td>rocksdb</td><td>C/C++</td><td>个人ideawu</td><td></td><td>92</td></tr><tr><td>结构化kv(redis兼容）</td><td>ardb</td><td>LevelDB, RocksDB, LMDB, WiredTiger</td><td>C++</td><td>个人yinqiwen</td><td>yes</td><td>800+</td></tr><tr><td>结构化kv(redis兼容）</td><td>(reborndb)qdb</td><td>Rocksdb and LevelDB</td><td>Go</td><td>个人ngaut</td><td></td><td>200+</td></tr><tr><td>结构化kv(redis兼容）</td><td>Pika</td><td>Rocksdb</td><td>C</td><td>Qihoo360</td><td>yes</td><td>900+</td></tr><tr><td>结构化kv(redis兼容）</td><td>LedisDB</td><td>LevelDB, goleveldb, LMDB, RocksDB, BoltDB or Memory</td><td>Go</td><td>个人SiddonTang</td><td></td><td>2K+</td></tr></tbody></table>

<h2 id="单机kvstore的分布式代理">单机kvstore的分布式代理</h2>
<table><thead><tr><th>名称</th><th>语言</th><th>存储</th><th>出品</th><th>应用/githubstar</th><th>分片</th><th>弹性</th><th>备注</th></tr></thead><tbody><tr><td>Reborndb</td><td>Go</td><td>qdb</td><td>个人ngaut</td><td>200+</td><td>yes</td><td>yes</td><td></td></tr><tr><td>Netflix Dynomite</td><td>C</td><td>redis,memcached</td><td>Netflix</td><td>1.9K+</td><td></td><td></td><td>Dynamo</td></tr><tr><td>Codis</td><td>Go</td><td>codis-server(定制redis)</td><td>社区CodisLabs</td><td>5K+</td><td></td><td></td><td></td></tr><tr><td>Twenproxy</td><td>C</td><td>redis,memcached</td><td>twitter</td><td>6K+</td><td></td><td></td><td></td></tr></tbody></table>

<h2 id="分布式KVstore">分布式KVstore</h2>
<table><thead><tr><th>类型</th><th>名称</th><th>语言</th><th>出品</th><th>dbengine排名/githubstar</th><th>存储引擎</th><th>社区活跃</th><th>特性</th><th>备注</th></tr></thead><tbody><tr><td>kv型</td><td>riak</td><td>erlang</td><td>basho</td><td>No.3/2K+</td><td>bitcask</td><td></td><td></td><td>Dynamo</td></tr><tr><td>kv型</td><td>beansdb</td><td>C</td><td>douban</td><td>600+</td><td>bitcask模型</td><td>近2年没有更新，没有文档</td><td></td><td>Dynamo</td></tr><tr><td>kv型</td><td>project Voldmort</td><td>Java</td><td>LinkedIn</td><td>No.29/1.8K+</td><td>BDB-JE,MySQL,Read-Only</td><td></td><td></td><td></td></tr><tr><td>kv型</td><td>Scalris</td><td>erlang</td><td>Zuse Institute Berlin</td><td>No.35/88</td><td></td><td></td><td></td><td></td></tr><tr><td>kv型</td><td>aeospike</td><td></td><td>aespike</td><td>No.7</td><td></td><td></td><td></td><td></td></tr><tr><td>kv型</td><td>Tair</td><td>C/C++</td><td>alibaba</td><td>400+</td><td>自研的fdb</td><td>停止更新，没有文档</td><td></td><td></td></tr></tbody></table>

<h2 id="补充">补充</h2>
<p>原文中没有提到的，在这里添加上作为补充。</p>
<ul>
<li><a href="https://github.com/pingcap/tidb" target="_blank" rel="external">tidb</a>: 国产的分布式NewSQL产品，底层采用tikv, 支持MySQL协议， PingCap出品。</li>
<li><a href="https://github.com/dgraph-io/badger" target="_blank" rel="external">badger</a>: 性能优异，特别为SSD优化，仅仅key存储在LSM tree中。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文转自饿了么的高级架构师陈东明(cadem)发布于云栖社区的文章: <a href="https://yq.aliyun.com/articles/85634?spm=5176.8091938.0.0.Bck5cC" target="_blank" rel="external">KV存储的对比</a>。作者还整理了另外一篇文章: <a href="https://yq.aliyun.com/articles/85619?spm=5176.8091938.0.0.Bck5cC" target="_blank" rel="external">存储系统的分类</a>,列举了常见的一些kv存储模型和实现。</p>
<p>最近对各种KV存储进行一个比较，从存储引擎到存储引擎的类型，到单机版的kvstore，再到分布式kvstore集群。</p>
]]>
    
    </summary>
    
      <category term="数据库" scheme="http://colobu.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 Go 和 Let's Encrypt 快速配置HTTPS加密]]></title>
    <link href="http://colobu.com/2017/09/30/use-letsencrypt-in-go/"/>
    <id>http://colobu.com/2017/09/30/use-letsencrypt-in-go/</id>
    <published>2017-09-30T08:28:28.000Z</published>
    <updated>2017-09-30T09:30:50.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://www.google.com.sg/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjAguS9vszWAhXDo48KHZPNCMUQFggnMAA&amp;url=https%3A%2F%2Fletsencrypt.org%2F&amp;usg=AOvVaw3jJenSMDof06eZ9Vr2RLNL" target="_blank" rel="external">Let&#39;s Encrypt</a> 在2015年秋季推出了免费的数字证书认证计划，旨在消除当前手动创建和安装证书的复杂性，并推广加密的万维网服务，为安全网站提供<strong>免费</strong>的SSL/TLS证书。<br>Let&#39;s Encrypt 是由互联网安全研究小组（ISRG，一个公益组织）提供的服务。主要赞助商包括电子前哨基金会，Mozilla基金会，Akamai以及思科。2015年4月9日，ISRG与Linux基金会宣布合作。</p>
<p>用以实现这一新的数字证书认证机构的协议被称为自动证书管理环境（<a href="https://github.com/ietf-wg-acme/acme/" target="_blank" rel="external">ACME</a>）。提案的一个版本已作为一个Internet草案发布。</p>
<p>目前， 申请证书的域名只能是特定的域名， 不支持<a href="https://zh.wikipedia.org/wiki/通配符证书" target="_blank" rel="external">通配符证书</a>(*.example.com)，这对于一个拥有众多子域名的公司来说很不方便。但是今年已经说了，将于2018年1月<a href="https://letsencrypt.org/2017/07/06/wildcard-certificates-coming-jan-2018.html" target="_blank" rel="external">支持通配符证书</a>和ACME v2 API。</p>
<a id="more"></a>
<p>原先有一些支持Let&#39;s Encrypt的 Go 工具和库， 比如<a href="https://github.com/xenolf/lego" target="_blank" rel="external">lego</a>、<a href="https://github.com/hlandau/acme" target="_blank" rel="external">acme</a>、<a href="https://github.com/ericchiang/letsencrypt" target="_blank" rel="external">letsencrypt</a>、<a href="https://github.com/rsc/letsencrypt" target="_blank" rel="external">rsc/letsencrypt</a>, 但是我推荐使用官方的库：<a href="https://godoc.org/golang.org/x/crypto/acme/autocert" target="_blank" rel="external">x/crypto/acme/autocert</a>, 简单好用，并且官方维护。</p>
<p>稍微复杂一点的使用姿势如下(其实已经很简单了)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">m := autocert.Manager{</div><div class="line">    Cache:      autocert.DirCache(<span class="string">"secret-dir"</span>),</div><div class="line">    Prompt:     autocert.AcceptTOS,</div><div class="line">    HostPolicy: autocert.HostWhitelist(<span class="string">"example.org"</span>),</div><div class="line">}</div><div class="line">s := &http.Server{</div><div class="line">    Addr:      <span class="string">":https"</span>,</div><div class="line">    TLSConfig: &tls.Config{GetCertificate: m.GetCertificate},</div><div class="line">}</div><div class="line">s.ListenAndServeTLS(<span class="string">""</span>, <span class="string">""</span>)</div></pre></td></tr></table></figure>

<p><code>autocert.Manager</code>提供了<code>GetCertificate</code>方法， 可以用来配置<code>TLSConfig</code>。</p>
<p>更简单的方式是一行搞定：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mux := http.NewServeMux()</div><div class="line">mux.HandleFunc(<span class="string">"/"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">    fmt.Fprintf(w, <span class="string">"Hello, TLS user! Your config: %+v"</span>, r.TLS)</div><div class="line">})</div><div class="line">log.Fatal(http.Serve(autocert.NewListener(<span class="string">"example.com"</span>), mux))</div></pre></td></tr></table></figure>

<p><code>autocert.NewListener</code>提供了一个自动配置的listener，使用起来非常的方便。</p>
<p>所以，如果你想做一些额外的配置，如果证书要缓存的位置，就用上面的方式， 如果想傻瓜式的使用，就用一行代码的方式。</p>
<p>关于这个包的设计的一些讨论可以看: <a href="https://github.com/golang/go/issues/17053" target="_blank" rel="external">#17053</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://www.google.com.sg/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjAguS9vszWAhXDo48KHZPNCMUQFggnMAA&amp;url=https%3A%2F%2Fletsencrypt.org%2F&amp;usg=AOvVaw3jJenSMDof06eZ9Vr2RLNL" target="_blank" rel="external">Let&#39;s Encrypt</a> 在2015年秋季推出了免费的数字证书认证计划，旨在消除当前手动创建和安装证书的复杂性，并推广加密的万维网服务，为安全网站提供<strong>免费</strong>的SSL/TLS证书。<br>Let&#39;s Encrypt 是由互联网安全研究小组（ISRG，一个公益组织）提供的服务。主要赞助商包括电子前哨基金会，Mozilla基金会，Akamai以及思科。2015年4月9日，ISRG与Linux基金会宣布合作。</p>
<p>用以实现这一新的数字证书认证机构的协议被称为自动证书管理环境（<a href="https://github.com/ietf-wg-acme/acme/" target="_blank" rel="external">ACME</a>）。提案的一个版本已作为一个Internet草案发布。</p>
<p>目前， 申请证书的域名只能是特定的域名， 不支持<a href="https://zh.wikipedia.org/wiki/通配符证书" target="_blank" rel="external">通配符证书</a>(*.example.com)，这对于一个拥有众多子域名的公司来说很不方便。但是今年已经说了，将于2018年1月<a href="https://letsencrypt.org/2017/07/06/wildcard-certificates-coming-jan-2018.html" target="_blank" rel="external">支持通配符证书</a>和ACME v2 API。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转][译]面向分布式系统工程师的分布式系统理论]]></title>
    <link href="http://colobu.com/2017/09/27/distributed-systems-theory-for-the-distributed-systems-engineer/"/>
    <id>http://colobu.com/2017/09/27/distributed-systems-theory-for-the-distributed-systems-engineer/</id>
    <published>2017-09-27T08:06:40.000Z</published>
    <updated>2017-09-27T08:29:55.000Z</updated>
    <content type="html"><![CDATA[<p>原文：<a href="http://the-paper-trail.org/blog/distributed-systems-theory-for-the-distributed-systems-engineer/" target="_blank" rel="external">Distributed systems theory for the distributed systems engineer</a></p>
<p>译者：<a href="http://blog.xiayf.cn/2014/08/10/Distributed-systems-theory-for-the-distributed-systems-engineer/" target="_blank" rel="external">youngsterxyf</a></p>
<p>Gwen Shapira，大腕级的解决方案架构师（SA），如今Cloudera的全职工程师，在<a href="https://twitter.com/gwenshap/status/497203248332165121" target="_blank" rel="external">Twitter上提的一个问题</a>引起了我的思考。</p>
<p>如果是以前，我可能会回答“嗯，这里有篇FLP论文，这里有篇Paxos论文，这里还有篇拜占庭将军问题的论文...”，我会罗列一箩筐重要的材料，如果你一头扎进去，至少花费6个月的时间才能过一遍这些材料。然而我已逐渐明白推荐大量的理论性的论文通常恰恰是着手学习分布式系统理论的错误方式（除非你在做一个PhD项目）。论文通常比较深入难懂，需要认真地研习，通常还需要大量的时间投入(significant experience)来理清这些论文的重要贡献，以及在整个理论体系中的位置。要求工程师具备这样的专业水平又有多大的意义呢？</p>
<p>但是，很遗憾，对分布式系统理论方面的重大研究成果和思想进行概括、归纳、背景分析的‘导引’性质的优秀材料非常缺乏；特别是没有居高临下态度的材料。对这块空白区域的思考让我想到了另一个有趣的问题：</p>
<blockquote>
<p>一个分布式系统工程师应该知道些什么分布式系统理论？</p>
</blockquote>
<p>在这种情况下，一知半解(a little theory)并不会是一件多危险的事情。因此我尝试整理一个列表，罗列出作为一个分布式系统工程师的我认为能够直接应用于我日常工作的一些基本概念；或者让分布式系统工程师完全有能力设计一个新系统的“筹码”。如果你认为我漏掉了一些东西，请联系我。</p>
<a id="more"></a>
<h2 id="入门第一步">入门第一步</h2>
<p>以下4篇材料出色地解释了构建分布式系统会遇到的一些挑战，共同概述了一系列分布式系统工程师必须要解决的技术上的难题，为之后章节中更深入的研究做好准备。</p>
<ul>
<li><a href="http://book.mixu.net/distsys/" target="_blank" rel="external">好玩又实在的分布式系统理论</a>是一本简短的书籍，其内容覆盖了分布式系统领域的一些基本议题，包括时间的作用及不同的复制策略。 《Distributed Systems for Fun and Profit》</li>
<li><a href="http://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/" target="_blank" rel="external">为分布式系统领域新人整理的笔记</a> - 不是理论对理论地讲述，而是做一个非常好非常实用的平衡，让你对其余材料的阅读能够落地。《Notes on distributed systems for young bloods》</li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.7628" target="_blank" rel="external">分布式系统研究综述报告</a> - 一篇经典的论文，解释了为什么不能将所有远程交互都模拟成和本地对象一样。《A Note on Distributed Systems》</li>
<li><a href="http://en.wikipedia.org/wiki/Fallacies_of_Distributed_Computing" target="_blank" rel="external">关于分布式计算的若干谬论</a> - 分布式计算方面的8点谬论，提醒系统设计者可能会忘记的几类事情。《The fallacies of distributed computing》</li>
</ul>
<h2 id="失败和时间">失败和时间</h2>
<p>分布式系统工程师需要面对的许多困难最终都可以归咎于两个潜在的原因：</p>
<ul>
<li>进程可能会失败</li>
<li>不存在一种好的方式来周知目前为止进程已经做了些什么</li>
</ul>
<p>进程之间对于时间的认知能共享些什么？哪些失败的场景是能够检测到？什么算法和原语可能被正确地实现？这三个问题有着非常深层的联系。多数时候，我们会假设两个不同节点之间对于时间概念或时间以什么样的速度逝去没有任何可共享的认知。</p>
<p>你应该知道：</p>
<ul>
<li>失败模式的（部分）分层：<a href="http://www.cse.psu.edu/~gcao/teach/513-00/c7.pdf" target="_blank" rel="external">崩溃停止-&gt;排除(omission)</a>-&gt;<a href="http://en.wikipedia.org/wiki/Byzantine_fault_tolerance" target="_blank" rel="external">拜占庭容错</a>。你应该理解：在高层次上可能发生的问题在低层次上肯定可能发生，在低层次上不可能发生的问题在高层次上也肯定不可能发生。</li>
<li>在没有任何共享时钟的情况下如何判断在另一个事件之前是否产生了某事件。这意味着你需要理解<a href="http://web.stanford.edu/class/cs240/readings/lamport.pdf" target="_blank" rel="external">Lamport时钟</a>及其一般化的<a href="http://en.wikipedia.org/wiki/Vector_clock" target="_blank" rel="external">向量时钟</a>，也需要阅读一下这篇<a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" target="_blank" rel="external">Dynamo论文</a>。</li>
<li>单个失败发生的可能性对于我们实现正确的分布式系统到底会有多大的影响（请阅读下面关于FLP结果的笔记）？</li>
<li>不同的时间模型：同步、部分同步和异步（若我找到好的参考文献会添加链接）</li>
</ul>
<h2 id="容错的基本矛盾">容错的基本矛盾</h2>
<p>一个系统，若要不降级而容忍某些错误的发生，就必须能够好像那些错误没有发生一样地运作。这通常意味着系统的这些部分必须能够冗余地工作，但是非绝对必要地做更多的工作通常会在性能和资源耗用方面产生一些消耗。这是为系统添加容错带来的基本矛盾。</p>
<p>你应该知道：</p>
<ul>
<li>确保单拷贝可串行化(single-copy serialisability)的仲裁(quorum)技术。可阅读<a href="https://ecommons.library.cornell.edu/bitstream/1813/6323/1/82-483.pdf" target="_blank" rel="external">Skeen的原始论文</a>，但可能更建议阅读<a href="http://en.wikipedia.org/wiki/Quorum_(distributed_computing" target="_blank" rel="external">这个Wikipedia词条</a>)。</li>
<li>关于<a href="http://the-paper-trail.org/blog/consensus-protocols-two-phase-commit/" target="_blank" rel="external">两阶段提交</a>、<a href="http://the-paper-trail.org/blog/consensus-protocols-three-phase-commit/" target="_blank" rel="external">三阶段提交</a>和<a href="http://the-paper-trail.org/blog/consensus-protocols-paxos/" target="_blank" rel="external">Paxos算法</a>，以及为什么它们有不同的容错性质。</li>
<li>最终一致性，及其他技术是如何以弱化对系统行为的保证为代价来尝试避免这种矛盾的。这篇<a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" target="_blank" rel="external">Dynamo论文</a>是一个很好的起点，同时Pat Helland的经典之作<a href="http://www.ics.uci.edu/~cs223/papers/cidr07p15.pdf" target="_blank" rel="external">Life Beyond Transactions</a>也是必读的。</li>
</ul>
<h2 id="基本的原语">基本的原语</h2>
<p>分布式系统中很少有大家一致认同的基本构建块，但越来越多地在出现。你应该以下的问题是什么，以及在哪可以找到它们的解决方案：</p>
<ul>
<li>Leader选举(leader election)（例如<a href="http://en.wikipedia.org/wiki/Bully_algorithm" target="_blank" rel="external">Bully算法</a>）</li>
<li>一致的快照（例如Chandy和Lamport所写的<a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/chandy.pdf" target="_blank" rel="external">经典论文</a>）</li>
<li>共识（阅读上文提到的关于2PC和Paxos的博文）</li>
<li>分布式状态机复制（看看<a href="http://en.wikipedia.org/wiki/State_machine_replication" target="_blank" rel="external">Wikipedia</a>就可以，但<a href="http://research.microsoft.com/en-us/um/people/blampson/58-Consensus/Acrobat.pdf" target="_blank" rel="external">Lampson的论文</a>更权威，只是枯燥了点）。</li>
</ul>
<h2 id="基础结论">基础结论</h2>
<p>某些客观事实是需要内化于心的，以下是几个关键点（a flavour）（当然还有更多）：</p>
<ul>
<li>如果进程之间可能丢失某些消息，那么不可能在实现一致性存储的同时能响应所有的请求。这就是<a href="http://lpd.epfl.ch/sgilbert/pubs/BrewersConjecture-SigAct.pdf" target="_blank" rel="external">CAP定理</a>。</li>
<li>一致性不可能同时满足以下条件 a) 总是正确 b) 在异步系统中只要有一个机器发生故障，系统总是能终止运行——停止失败（FLP 结论）。在给出证明之前，首先是一个我在洛杉矶演讲的幻灯片：我们喜爱的论文，我希望它能合理的解释这个结论。<br>建议：确实没有必要理解其证明。</li>
<li>一般而言，消息交互少于两轮是不可能达成共识(Consensus)。</li>
</ul>
<h2 id="真实系统">真实系统</h2>
<p>最重要的练习是重复地阅读新兴的、真实系统的描述，并尝试评价它们的设计决策。一遍又一遍地这样去做。一些建议：</p>
<p><strong>Google</strong>:</p>
<p><a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/gfs-sosp2003.pdf" target="_blank" rel="external">GFS</a>、<a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/spanner-osdi2012.pdf" target="_blank" rel="external">Spanner</a>、<a href="http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/41344.pdf" target="_blank" rel="external">F1</a>、<a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/chubby-osdi06.pdf" target="_blank" rel="external">Chubby</a>、<a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/bigtable-osdi06.pdf" target="_blank" rel="external">BigTable</a>、<a href="http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/41378.pdf" target="_blank" rel="external">MillWheel</a>、<a href="http://eurosys2013.tudos.org/wp-content/uploads/2013/paper/Schwarzkopf.pdf" target="_blank" rel="external">Omega</a>、<a href="http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/36356.pdf" target="_blank" rel="external">Dapper</a>、<a href="http://www.cs.utexas.edu/users/lorenzo/corsi/cs380d/papers/paper2-1.pdf" target="_blank" rel="external">Paxos Made Live</a>、<a href="http://cacm.acm.org/magazines/2013/2/160173-the-tail-at-scale/abstract" target="_blank" rel="external">The Tail At Scale</a>。</p>
<p><strong>Not Google</strong>:</p>
<p><a href="http://research.microsoft.com/en-us/projects/dryad/eurosys07.pdf" target="_blank" rel="external">Dryad</a>, <a href="https://www.cs.cornell.edu/projects/ladis2009/papers/lakshman-ladis2009.pdf" target="_blank" rel="external">Cassandra</a>, <a href="http://ceph.com/papers/weil-ceph-osdi06.pdf" target="_blank" rel="external">Ceph</a>, <a href="https://ramcloud.stanford.edu/wiki/display/ramcloud/RAMCloud+Papers" target="_blank" rel="external">RAMCloud</a>, <a href="http://hyperdex.org/papers/" target="_blank" rel="external">HyperDex</a>, <a href="http://www.mpi-sws.org/~druschel/courses/ds/papers/cooper-pnuts.pdf" target="_blank" rel="external">PNUTS</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文：<a href="http://the-paper-trail.org/blog/distributed-systems-theory-for-the-distributed-systems-engineer/" target="_blank" rel="external">Distributed systems theory for the distributed systems engineer</a></p>
<p>译者：<a href="http://blog.xiayf.cn/2014/08/10/Distributed-systems-theory-for-the-distributed-systems-engineer/" target="_blank" rel="external">youngsterxyf</a></p>
<p>Gwen Shapira，大腕级的解决方案架构师（SA），如今Cloudera的全职工程师，在<a href="https://twitter.com/gwenshap/status/497203248332165121" target="_blank" rel="external">Twitter上提的一个问题</a>引起了我的思考。</p>
<p>如果是以前，我可能会回答“嗯，这里有篇FLP论文，这里有篇Paxos论文，这里还有篇拜占庭将军问题的论文...”，我会罗列一箩筐重要的材料，如果你一头扎进去，至少花费6个月的时间才能过一遍这些材料。然而我已逐渐明白推荐大量的理论性的论文通常恰恰是着手学习分布式系统理论的错误方式（除非你在做一个PhD项目）。论文通常比较深入难懂，需要认真地研习，通常还需要大量的时间投入(significant experience)来理清这些论文的重要贡献，以及在整个理论体系中的位置。要求工程师具备这样的专业水平又有多大的意义呢？</p>
<p>但是，很遗憾，对分布式系统理论方面的重大研究成果和思想进行概括、归纳、背景分析的‘导引’性质的优秀材料非常缺乏；特别是没有居高临下态度的材料。对这块空白区域的思考让我想到了另一个有趣的问题：</p>
<blockquote>
<p>一个分布式系统工程师应该知道些什么分布式系统理论？</p>
</blockquote>
<p>在这种情况下，一知半解(a little theory)并不会是一件多危险的事情。因此我尝试整理一个列表，罗列出作为一个分布式系统工程师的我认为能够直接应用于我日常工作的一些基本概念；或者让分布式系统工程师完全有能力设计一个新系统的“筹码”。如果你认为我漏掉了一些东西，请联系我。</p>
]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]使用 bcc/BPF 分析 go 程序]]></title>
    <link href="http://colobu.com/2017/09/22/golang-bcc-bpf-function-tracing/"/>
    <id>http://colobu.com/2017/09/22/golang-bcc-bpf-function-tracing/</id>
    <published>2017-09-22T06:03:54.000Z</published>
    <updated>2017-09-28T04:20:24.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>BCC 是基于 BPF 的 Linux IO 分析、监控、网络工具集合。BPF Compiler Collection (BCC) 是创建高效内核追踪和处理程序的工具包，包含几个有用的工具和用例。BCC 扩展了 BPF (Berkeley Packet Filters) 的用途，BPF 之前被称为 eBPF，是 Linux 3.15 新增的一个新特性。BCC 大部分的功能都要求 Linux 4.1+。</p>
</blockquote>
<p>本文翻译自性能分析大牛<a href="http://www.brendangregg.com/index.html" target="_blank" rel="external">Brendan Gregg</a>的 2017年中旬的一篇文章: <a href="http://www.brendangregg.com/blog/2017-01-31/golang-bcc-bpf-function-tracing.html" target="_blank" rel="external">Golang bcc/BPF Function Tracing</a>, 介绍如何使用最新的工具更加深入的分析Go程序。</p>
<a id="more"></a>
<p><img src="bcc_tracing_tools_2017.png" alt="Linux bbc/BPF tracing tools"></p>
<p>本文中我将逐步展示一个新的分析Go程序的方式： 使用Linux 4.x的 eBPF 技术进行动态分析。如果你搜索一下<code>go</code>和<code>BPF</code>关键字， 你会发现一些使用 BPF的Go程序库(比如 <a href="https://github.com/iovisor/gobpf" target="_blank" rel="external">gobpf</a>)。这并不是我想在本文中介绍的：我是要使用 BPF 来对Go程序进行性能分析和调试。 如果你还不了解 BPF, 我几周前在 linux.conf.au 有一些介绍 (<a href="https://www.youtube.com/watch?v=JRFNIKUROPE" target="_blank" rel="external">youtube</a>, <a href="http://www.slideshare.net/brendangregg/bpf-tracing-and-more" target="_blank" rel="external">slideshare</a>)。</p>
<p>现在已经有一些方式可以调试和跟踪(debug and trace)Go程序, 包括(但不限于下列方式):</p>
<ul>
<li>使用 <a href="https://golang.org/doc/gdb" target="_blank" rel="external">gdb</a>和 go runtime支持</li>
<li><a href="https://golang.org/pkg/runtime/trace/" target="_blank" rel="external">go execution tracer</a></li>
<li>GODEBUG, 使用 gctrace 和 schedtrace 参数</li>
</ul>
<p>BPF tracing技术可以做更多的工作，当然它也有自己的优缺点，下面我会用一个简单的<code>hello.go</code>程序来演示这些：</p>
<figure class="highlight go"><figcaption><span>hello.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">        fmt.Println(<span class="string">"Hello, BPF!"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我会用<code>gccgo</code>先编译，然后再用 go 自己的编译器来编译 (如果你不知道它们之间的区别，请看 VonC 做的这个 <a href="http://stackoverflow.com/a/25811505" target="_blank" rel="external">总结</a>。 一句话, gccgo可以产生更加优化的二进制文件，但适用于更老版本的go)。</p>
<h3 id="函数统计_(gccgo)">函数统计 (gccgo)</h3>
<p>编译:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ gccgo -o hello hello.<span class="keyword">go</span></div><div class="line">$ ./hello</div><div class="line">Hello, BPF!</div></pre></td></tr></table></figure>

<p>现在可以使用 <a href="https://github.com/iovisor/bcc" target="_blank" rel="external">bcc</a> tool <code>funccount</code> 动态跟踪和统计所有的以<code>fmt.</code>开头的Go库函数，我同时会在另外一个终端中运行这个hello程序：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># funccount 'go:fmt.*'</span></div><div class="line">Tracing <span class="number">160</span> functions <span class="keyword">for</span> <span class="string">"go:fmt.*"</span><span class="keyword">...</span> Hit Ctrl-C to end.</div><div class="line">^C</div><div class="line">FUNC                                    COUNT</div><div class="line">fmt..import                                 <span class="number">1</span></div><div class="line">fmt.padString.pN7_fmt.fmt                   <span class="number">1</span></div><div class="line">fmt.fmt_s.pN7_fmt.fmt                       <span class="number">1</span></div><div class="line">fmt.WriteString.pN10_fmt.buffer             <span class="number">1</span></div><div class="line">fmt.free.pN6_fmt.pp                         <span class="number">1</span></div><div class="line">fmt.fmtString.pN6_fmt.pp                    <span class="number">1</span></div><div class="line">fmt.doPrint.pN6_fmt.pp                      <span class="number">1</span></div><div class="line">fmt.init.pN7_fmt.fmt                        <span class="number">1</span></div><div class="line">fmt.printArg.pN6_fmt.pp                     <span class="number">1</span></div><div class="line">fmt.WriteByte.pN10_fmt.buffer               <span class="number">1</span></div><div class="line">fmt.Println                                 <span class="number">1</span></div><div class="line">fmt.truncate.pN7_fmt.fmt                    <span class="number">1</span></div><div class="line">fmt.Fprintln                                <span class="number">1</span></div><div class="line">fmt.$nested1                                <span class="number">1</span></div><div class="line">fmt.newPrinter                              <span class="number">1</span></div><div class="line">fmt.clearflags.pN7_fmt.fmt                  <span class="number">2</span></div><div class="line">Detaching...</div></pre></td></tr></table></figure>

<p>漂亮! 输出结果中包含了<code>fmt.Println()</code>, 还有一些其它的调用。</p>
<p>实际并不需要以特定的方式运行Go程序， 你可以跟踪一个已经运行的Go程序进程，并不需要重新启动它， 怎么做呢？</p>
<ul>
<li>使用 <a href="http://www.brendangregg.com/blog/2015-06-28/linux-ftrace-uprobe.html" target="_blank" rel="external">Linux uprobes: User-Level Dynamic Tracing</a>, Linux 3.5中增加的一个功能。 它使用一个软中断重写了kernel的指令，并且当跟踪程序结束的时候会恢复进程。</li>
<li>gccgo编译的程序有一个标准的符号表，可以用来查询函数。</li>
<li>本例中使用了 <code>libgo</code>, 它包含<code>fmt</code>包。</li>
<li>uprobes可以附加到已经运行的进程上， 或者像我上面做的那样， 捕获所有使用它的进程。</li>
<li>更有效地， 我经常统计内核上下文的函数调用次数， 只将调用次数发送到用户空间。</li>
</ul>
<p>对于操作系统来讲， 这个二进制文件的信息如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>file hello</div><div class="line"><span class="symbol">hello:</span> <span class="constant">ELF</span> <span class="number">64</span>-bit <span class="constant">LSB</span> executable, x86-<span class="number">64</span>, version <span class="number">1</span> (<span class="constant">SYSV</span>), dynamically linked, interpreter /lib64/ld-linux-x86-<span class="number">64</span>.so.<span class="number">2</span>, <span class="keyword">for</span> <span class="constant">GNU</span>/<span class="constant">Linux</span> <span class="number">2.6</span>.<span class="number">32</span>, <span class="constant">BuildID</span>[sha1]=<span class="number">4</span>dc45f1eb023f44ddb32c15bbe0fb4f933e61815, <span class="keyword">not</span> stripped</div><div class="line"><span class="variable">$ </span>ls -lh hello</div><div class="line">-rwxr-xr-x <span class="number">1</span> bgregg root <span class="number">29</span>K <span class="constant">Jan</span> <span class="number">12</span> <span class="number">21</span><span class="symbol">:</span><span class="number">18</span> hello</div><div class="line"><span class="variable">$ </span>ldd hello</div><div class="line">    linux-vdso.so.<span class="number">1</span> =&gt;  (<span class="number">0x00007ffc4cb1a000</span>)</div><div class="line">    libgo.so.<span class="number">9</span> =&gt; <span class="regexp">/usr/lib</span><span class="regexp">/x86_64-linux-gnu/libgo</span>.so.<span class="number">9</span> (<span class="number">0x00007f25f2407000</span>)</div><div class="line">    libgcc_s.so.<span class="number">1</span> =&gt; <span class="regexp">/lib/x</span>86_64-linux-gnu/libgcc_s.so.<span class="number">1</span> (<span class="number">0x00007f25f21f1000</span>)</div><div class="line">    libc.so.<span class="number">6</span> =&gt; <span class="regexp">/lib/x</span>86_64-linux-gnu/libc.so.<span class="number">6</span> (<span class="number">0x00007f25f1e27000</span>)</div><div class="line">    /lib64/ld-linux-x86-<span class="number">64</span>.so.<span class="number">2</span> (<span class="number">0x0000560b44960000</span>)</div><div class="line">    libpthread.so.<span class="number">0</span> =&gt; <span class="regexp">/lib/x</span>86_64-linux-gnu/libpthread.so.<span class="number">0</span> (<span class="number">0x00007f25f1c0a000</span>)</div><div class="line">    libm.so.<span class="number">6</span> =&gt; <span class="regexp">/lib/x</span>86_64-linux-gnu/libm.so.<span class="number">6</span> (<span class="number">0x00007f25f1901000</span>)</div><div class="line"><span class="variable">$ </span>objdump -tT /usr/lib/x86_64-linux-gnu/libgo.so.<span class="number">9</span> | grep fmt.<span class="constant">Println</span></div><div class="line"><span class="number">0000000001221070</span> g     <span class="constant">O</span> .data.rel.ro   <span class="number">000000000000000</span>8              fmt.<span class="constant">Println</span><span class="variable">$descriptor</span></div><div class="line"><span class="number">0000000000</span>97809<span class="number">0</span> g     <span class="constant">F</span> .text  <span class="number">0000000000000075</span>              fmt.<span class="constant">Println</span></div><div class="line"><span class="number">0000000001221070</span> g    <span class="constant">DO</span> .data.rel.ro   <span class="number">000000000000000</span>8  <span class="constant">Base</span>        fmt.<span class="constant">Println</span><span class="variable">$descriptor</span></div><div class="line"><span class="number">0000000000</span>97809<span class="number">0</span> g    <span class="constant">DF</span> .text  <span class="number">0000000000000075</span>  <span class="constant">Base</span>        fmt.<span class="constant">Println</span></div></pre></td></tr></table></figure>

<p>看起来像编译的 C 程序， 你可以使用很多已有的调试器和跟踪器， 包括 bcc/BPF。 而且比那么即时编译的运行时比如 Java 和 Node.js更容易操作。目前唯一一点不爽的就是函数名包含一些非标准的字符， 比如本例中的&quot;.&quot; 。</p>
<p><code>funccount</code> 支持一些参数， 比如<code>-p</code>指定某个进程ID, <code>-i</code>指定输出的时间间隔。它当前只能同时支持最多1000个跟踪对象(probe), 对于<code>fmt.*</code>来说，函数不多还OK, 但是如果跟踪所有的<code>libgo</code>中的函数就有问题了:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># funccount 'go:*'</span></div><div class="line">maximum <span class="keyword">of</span> <span class="number">1000</span> probes allowed, attempted <span class="number">21178</span></div></pre></td></tr></table></figure>

<p>嗯哼， 不工作了。 就像 bcc/BPF 中其它一些问题一样， 如果这个限制在应用中阻碍太多的话我们考虑寻找一个方式来解决它。</p>
<h3 id="函数统计_(Go_gc)">函数统计 (Go gc)</h3>
<p>使用 Go gc编译器来编译:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">go</span> build hello.<span class="keyword">go</span></div><div class="line">$ ./hello</div><div class="line">Hello, BPF!</div></pre></td></tr></table></figure>

<p>统计 <code>fmt</code> 的函数调用:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># funccount '/home/bgregg/hello:fmt.*'</span></div><div class="line">Tracing <span class="number">78</span> functions <span class="keyword">for</span> <span class="string">"/home/bgregg/hello:fmt.*"</span><span class="keyword">...</span> Hit Ctrl-C to end.</div><div class="line">^C</div><div class="line">FUNC                                    COUNT</div><div class="line">fmt.init.1                                  <span class="number">1</span></div><div class="line">fmt.(*fmt).padString                        <span class="number">1</span></div><div class="line">fmt.(*fmt).truncate                         <span class="number">1</span></div><div class="line">fmt.(*fmt).fmt_s                            <span class="number">1</span></div><div class="line">fmt.newPrinter                              <span class="number">1</span></div><div class="line">fmt.(*pp).free                              <span class="number">1</span></div><div class="line">fmt.Fprintln                                <span class="number">1</span></div><div class="line">fmt.Println                                 <span class="number">1</span></div><div class="line">fmt.(*pp).fmtString                         <span class="number">1</span></div><div class="line">fmt.(*pp).printArg                          <span class="number">1</span></div><div class="line">fmt.(*pp).doPrint                           <span class="number">1</span></div><div class="line">fmt.glob.func1                              <span class="number">1</span></div><div class="line">fmt.init                                    <span class="number">1</span></div><div class="line">Detaching...</div></pre></td></tr></table></figure>

<p>你仍然可以跟踪<code>fmt.Println()</code>, 但是现在是从二进制程序中找到它， 而不是在<code>libgo</code>中， 这是因为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>file hello</div><div class="line"><span class="symbol">hello:</span> <span class="constant">ELF</span> <span class="number">64</span>-bit <span class="constant">LSB</span> executable, x86-<span class="number">64</span>, version <span class="number">1</span> (<span class="constant">SYSV</span>), statically linked, <span class="keyword">not</span> stripped</div><div class="line"><span class="variable">$ </span>ls -lh hello</div><div class="line">-rwxr-xr-x <span class="number">1</span> bgregg root <span class="number">2.2</span>M <span class="constant">Jan</span> <span class="number">12</span> <span class="number">05</span><span class="symbol">:</span><span class="number">16</span> hello</div><div class="line"><span class="variable">$ </span>ldd hello</div><div class="line">    <span class="keyword">not</span> a dynamic executable</div><div class="line"><span class="variable">$ </span>objdump -t hello | grep fmt.<span class="constant">Println</span></div><div class="line"><span class="number">000000000045</span>a68<span class="number">0</span> g     <span class="constant">F</span> .text  <span class="number">00000000000000</span>e<span class="number">0</span> fmt.<span class="constant">Println</span></div></pre></td></tr></table></figure>

<p>它包含一个 2M的静态库， 这个库中包含<code>fmt</code>的函数。</p>
<p>另外一个不同就是函数名中包含不常见的符号: &quot;*&quot;, &quot;(&quot;等等。</p>
<h3 id="函数跟踪_(gccgo)">函数跟踪 (gccgo)</h3>
<p>这次我将尝试 Sasha Goldshtein 的跟踪工具， 也是 <a href="https://github.com/iovisor/bcc" target="_blank" rel="external">bcc</a>跟踪工具集中一个。我会使用它来观察函数的每次调用。<br>还是先使用<code>gccgo</code>来编译， 这次的简单小程序叫做 <code>functions.go</code>:</p>
<figure class="highlight go"><figcaption><span>functions.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> add(x <span class="typename">int</span>, y <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">    <span class="keyword">return</span> x + y</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    fmt.Println(add<span class="number">(42</span>,<span class="number"> 13</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>开始跟踪 <code>add()</code> 函数:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># trace <span class="string">'/home/bgregg/functions:main.add'</span></div><div class="line">PID    TID    COMM         FUNC             </div><div class="line"><span class="number">14424</span>  <span class="number">14424</span>  functions    main.<span class="built_in">add</span></div></pre></td></tr></table></figure>

<p>还可以查看它的传入的参数:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># trace <span class="string">'/home/bgregg/functions:main.add "%d %d" arg1, arg2'</span></div><div class="line">PID    TID    COMM         FUNC             -</div><div class="line"><span class="number">14390</span>  <span class="number">14390</span>  functions    main.<span class="built_in">add</span>         <span class="number">42</span> <span class="number">13</span></div></pre></td></tr></table></figure>

<p>酷，工作正常，参数显示正确。</p>
<p><code>trace</code> 还有其它的参数(使用 -h 查看), b比如时间戳、堆栈信息等。</p>
<h3 id="函数跟踪_(Go_gc)">函数跟踪 (Go gc)</h3>
<p>目前位置一切按照预想的执行。 同样的程序， 使用 <code>go gc</code>编译器来编译:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">go</span> build functions.<span class="keyword">go</span></div><div class="line"></div><div class="line"># trace <span class="string">'/home/bgregg/functions:main.add "%d %d" arg1, arg2'</span></div><div class="line">could not determine address of symbol main.<span class="built_in">add</span></div><div class="line"></div><div class="line">$ objdump -<span class="keyword">t</span> functions | <span class="keyword">grep</span> main.<span class="built_in">add</span></div><div class="line">$</div></pre></td></tr></table></figure>

<p>什么？没有<code>main.add()</code>函数？ 难道它被内联了？禁止内联：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">go</span> build -gcflags <span class="string">'-l'</span> functions.<span class="keyword">go</span></div><div class="line">$ objdump -<span class="keyword">t</span> functions | <span class="keyword">grep</span> main.<span class="built_in">add</span></div><div class="line"><span class="number">0000000000401000</span> <span class="keyword">g</span>     F .text  <span class="number">0000000000000020</span> main.<span class="built_in">add</span></div></pre></td></tr></table></figure>

<p>现在好了，虚惊一场。 跟踪这个程序和它的参数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># trace <span class="string">'/home/bgregg/functions:main.add "%d %d" arg1, arg2'</span></div><div class="line">PID    TID    COMM         FUNC             -</div><div class="line"><span class="number">16061</span>  <span class="number">16061</span>  functions    main.<span class="built_in">add</span>         <span class="number">536912504</span> <span class="number">16</span></div></pre></td></tr></table></figure>

<p>有点不对， 参数应该是 <code>42</code> 和 <code>13</code>,并不是<code>536912504</code> 和 <code>16</code>。</p>
<p>超期gdb调试:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">$ gdb ./functions</div><div class="line">[<span class="keyword">...</span>]</div><div class="line"><span class="keyword">warning</span>: File <span class="string">"/usr/share/go-1.6/src/runtime/runtime-gdb.py"</span> auto-loading has been declined</div><div class="line"> by your `auto-load safe-path' set to "$debugdir:$datadir/auto-load".</div><div class="line">[...]</div><div class="line">(gdb) b main.add</div><div class="line">Breakpoint 1 at 0x401000: file /home/bgregg/functions.go, line 6.</div><div class="line">(gdb) r</div><div class="line">Starting program: /home/bgregg/functions </div><div class="line">[New LWP 16082]</div><div class="line">[New LWP 16083]</div><div class="line">[New LWP 16084]</div><div class="line"></div><div class="line">Thread 1 "functions" hit Breakpoint 1, main.add (x=42, y=13, ~r2=4300314240) at</div><div class="line"> /home/bgregg/functions.go:6</div><div class="line">6           return x + y</div><div class="line">(gdb) i r</div><div class="line">rax            0xc820000180 859530330496</div><div class="line">rbx            0x584ea0 5787296</div><div class="line">rcx            0xc820000180 859530330496</div><div class="line">rdx            0xc82005a048 859530698824</div><div class="line">rsi            0x10 16</div><div class="line">rdi            0xc82000a2a0 859530371744</div><div class="line">rbp            0x0  0x0</div><div class="line">rsp            0xc82003fed0 0xc82003fed0</div><div class="line">r8             0x41 65</div><div class="line">r9             0x41 65</div><div class="line">r10            0x4d8ba0 5082016</div><div class="line">r11            0x0  0</div><div class="line">r12            0x10 16</div><div class="line">r13            0x52a3c4 5415876</div><div class="line">r14            0xa  10</div><div class="line">r15            0x8  8</div><div class="line">rip            0x401000 0x401000 </div><div class="line">eflags         0x206    [ PF IF ]</div><div class="line">cs             0xe033   57395</div><div class="line">ss             0xe02b   57387</div><div class="line">ds             0x0  0</div><div class="line">es             0x0  0</div><div class="line">fs             0x0  0</div><div class="line">gs             0x0  0</div></pre></td></tr></table></figure>

<p>我包含了<code>runtime-gdb.py</code>启动时的警告， 这个警告很有用：如果我想更深入到go的上下文， 我会解决这个问题。及时忽略这个问题, gdb也显示了参数的&quot;x=42, y=13&quot;.</p>
<p>我也检查了寄存器的值， bcc的trace程序也是从这些寄存器中得到的值。 从 <code>syscall(2)</code> man帮助中可以知道：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">       arch/ABI      arg1  arg2  arg3  arg4  arg5  arg6  arg7  Notes</div><div class="line">       ──────────────────────────────────────────────────────────────────</div><div class="line">[<span class="keyword">...</span>]</div><div class="line">       x86_64        rdi   rsi   rdx   r10   r8    r9    -</div></pre></td></tr></table></figure>

<p>但是 42 和 13 并没有在寄存器 rdi 或者 rsi 中， 原因在于Go gc编译器并不遵循标准的 AMD ABI 函数调用约定， 这导致这个调试器或者其它的调试器跟踪参数有问题(我以前也听过前同事抱怨过这个问题)。我猜Go需要使用一个不同的ABI来返回值， 因为它需要返回多个值。</p>
<p>我查看了 Go 汇编器的快速手册， 还有Plan 9 的汇编手册，看起来函数在栈上传递，  42 和 13在栈上:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(gdb) x/3dg $<span class="literal">rsp</span></div><div class="line"><span class="number">0xc82003fed0</span>:   <span class="number">4198477</span> <span class="number">42</span></div><div class="line"><span class="number">0xc82003fee0</span>:   <span class="number">13</span></div></pre></td></tr></table></figure>

<p>BPF也可以获取这些值， 作为验证， 我 hacked几个别名， 把这些参数叫做<code>go1</code>,<code>go2</code>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># trace <span class="string">'/home/bgregg/functions:main.add "%d %d" go1, go2'</span></div><div class="line">PID    TID    COMM         FUNC             -</div><div class="line"><span class="number">17555</span>  <span class="number">17555</span>  functions    main.<span class="built_in">add</span>         <span class="number">42</span> <span class="number">13</span></div></pre></td></tr></table></figure>

<p>完美。希望你读到这篇文章的时候， 我(或者其他人)已经解决了这个问题，并把它加入懂啊 bcc trace工具中。 可能叫&quot;goarg1&quot;, &quot;goarg2&quot;更好。</p>
<h3 id="Interface_参数">Interface 参数</h3>
<p>下面我会演示另一个<code>fmt.Println()</code>打印字符串的例子，但这一次参数是<code>interface</code>类型。从 go 的 <code>src/fmt/print.go</code>源代码中可以看到：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Println(a ...<span class="keyword">interface</span>{}) (n <span class="typename">int</span>, err error) {</div><div class="line">    <span class="keyword">return</span> Fprintln(os.Stdout, a...)</div></pre></td></tr></table></figure>

<p>使用gccgo编译， 然后使用 gdb 调试 你可以看到这个字符串：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$ gdb ./hello</div><div class="line">[<span class="keyword">...</span>]</div><div class="line">(gdb) b fmt.Println</div><div class="line">Breakpoint <span class="number">1</span> at <span class="number">0x401c50</span></div><div class="line">(gdb) r</div><div class="line">Starting program: /home/bgregg/hello </div><div class="line">[Thread debugging using libthread_db enabled]</div><div class="line">Using host libthread_db <span class="keyword">library</span> <span class="string">"/lib/x86_64-linux-gnu/libthread_db.so.1"</span>.</div><div class="line">[New Thread <span class="number">0x7ffff449c700</span> (LWP <span class="number">16836</span>)]</div><div class="line">[New Thread <span class="number">0x7ffff3098700</span> (LWP <span class="number">16837</span>)]</div><div class="line">[Switching to Thread <span class="number">0x7ffff3098700</span> (LWP <span class="number">16837</span>)]</div><div class="line"></div><div class="line">Thread <span class="number">3</span> <span class="string">"hello"</span> hit Breakpoint <span class="number">1</span>, fmt.Println (a=<span class="keyword">...</span>) at ../../../src/libgo/go/fmt/print.go:<span class="number">263</span></div><div class="line"><span class="number">263</span> ../../../src/libgo/go/fmt/print.go: No such file or directory.</div><div class="line">(gdb) p a</div><div class="line">$<span class="number">1</span> = {__values = <span class="number">0xc208000240</span>, __count = <span class="number">1</span>, __capacity = <span class="number">1</span>}</div><div class="line">(gdb) p a.__values</div><div class="line">$<span class="number">18</span> = (struct {<span class="keyword">...</span>} *) <span class="number">0xc208000240</span></div><div class="line">(gdb) p a.__values[<span class="number">0</span>]</div><div class="line">$<span class="number">20</span> = {__type_descriptor = <span class="number">0x4037c0</span> &lt;__go_tdn_string&gt;, __object = <span class="number">0xc208000210</span>}</div><div class="line">(gdb) x/s *<span class="number">0xc208000210</span></div><div class="line"><span class="number">0x403483</span>:   <span class="string">"Hello, BPF!"</span></div></pre></td></tr></table></figure>

<p>可以正常查到这个字符串（我不确定是否有更容易的方式检查）。你也可以写一个定制的 bcc/BPF 程序来检查， 我们可以增加更多的别名来命名这些接口参数。</p>
<h3 id="函数耗时">函数耗时</h3>
<p>下面是一个跟踪函数耗时的简单例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># funclatency 'go:fmt.Println'</span></div><div class="line"><span class="constant">Tracing </span><span class="number">1</span> functions <span class="keyword">for</span> <span class="string">"go:fmt.Println"</span>... <span class="constant">Hit Ctrl-C </span>to <span class="keyword">end</span>.</div><div class="line">^<span class="constant">C</span></div><div class="line"></div><div class="line"><span class="constant">Function </span>= fmt.<span class="constant">Println </span>[<span class="number">3041</span>]</div><div class="line">     nsecs               <span class="symbol">:</span> count     distribution</div><div class="line">         <span class="number">0</span> -&gt; <span class="number">1</span>          <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">         <span class="number">2</span> -&gt; <span class="number">3</span>          <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">         <span class="number">4</span> -&gt; <span class="number">7</span>          <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">         <span class="number">8</span> -&gt; <span class="number">15</span>         <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">        <span class="number">16</span> -&gt; <span class="number">31</span>         <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">        <span class="number">32</span> -&gt; <span class="number">63</span>         <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">        <span class="number">64</span> -&gt; <span class="number">127</span>        <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">       <span class="number">128</span> -&gt; <span class="number">255</span>        <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">       <span class="number">256</span> -&gt; <span class="number">511</span>        <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">       <span class="number">512</span> -&gt; <span class="number">1023</span>       <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">      <span class="number">1024</span> -&gt; <span class="number">2047</span>       <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">      <span class="number">2048</span> -&gt; <span class="number">4095</span>       <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">      <span class="number">4096</span> -&gt; <span class="number">8191</span>       <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">      <span class="number">8192</span> -&gt; <span class="number">16383</span>      <span class="symbol">:</span> <span class="number">27</span>       |****************************************|</div><div class="line">     <span class="number">16384</span> -&gt; <span class="number">32767</span>      <span class="symbol">:</span> <span class="number">3</span>        |****                                    |</div><div class="line"><span class="constant">Detaching.</span>..</div></pre></td></tr></table></figure>

<p>它显示了<code>fmt.Println()</code>函数耗时的直方图(单位纳秒), 我在一个循环中不停的调用这个函数。</p>
<p><strong>⚠️警告</strong>: 这里有些不幸的问题： 如果在方法调用的时候goroutine从一个操作系统线程切换到另外一个线程，<code>funclatency</code>程序并不会找匹配的返回。 我们需要一个新工具， <code>gofunclatency</code>, 使用 go的内部 <code>GOID</code> 来跟踪耗时， 而不是根据操作系统的<code>TID</code>。同时修改<code>uretprobes</code>修改Go进程可能导致Go进程崩溃， 我们需要调试和制定一个修复计划。可以查看 Suresh 的评论以了解其中的细节。</p>
<h3 id="下一步">下一步</h3>
<p>利用动态跟踪和Linux eBPF技术，使用bcc的<code>funccount</code>和<code>trace</code>工具，我们快速了解了一个新的调试Go程序的技术。有些功能非常成功，有些功能还有一些挑战。 函数调用统计工作很完美，但是跟踪gccgo编译的函数参数的时候美问题，但是跟踪Go gc编译的函数参数有些问题， 因为Go gc编译器没有遵循标准的ABI调用约定，所以这个工具需要加强。 作为概念性的验证，我修改了bcc trace工具来显示Go gc编译的函数参数，但是这个特性需要正确实现和集成。处理接口对象也是一个挑战，因为Go支持多返回值， 这些都是我们需要加强的工作，以便是这些调试和跟踪工作更容易， 就像在c中增加一些宏一样。</p>
<p>希望之后还有一个后续的文章来介绍这些bcc/BPF功能的提升(不一定是我，如果你感兴趣，请拿好接力棒)。</p>
<p>另一个重要的跟踪问题，可以在下一篇文章中介绍，就是堆栈(stack trace)。值得高兴的是， Go已经在 1.7中实现了基于 frame pointer的堆栈。</p>
<p>最后，另一个重要的可以单拉出一篇文章介绍的跟踪问题是和内核上下文一起跟踪Go函数。 BPF和bcc都可以跟踪内核函数， 和用户空间一样。可以想象我们可以创建一个新的工具来同时跟踪这两个。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>BCC 是基于 BPF 的 Linux IO 分析、监控、网络工具集合。BPF Compiler Collection (BCC) 是创建高效内核追踪和处理程序的工具包，包含几个有用的工具和用例。BCC 扩展了 BPF (Berkeley Packet Filters) 的用途，BPF 之前被称为 eBPF，是 Linux 3.15 新增的一个新特性。BCC 大部分的功能都要求 Linux 4.1+。</p>
</blockquote>
<p>本文翻译自性能分析大牛<a href="http://www.brendangregg.com/index.html" target="_blank" rel="external">Brendan Gregg</a>的 2017年中旬的一篇文章: <a href="http://www.brendangregg.com/blog/2017-01-31/golang-bcc-bpf-function-tracing.html" target="_blank" rel="external">Golang bcc/BPF Function Tracing</a>, 介绍如何使用最新的工具更加深入的分析Go程序。</p>
]]>
    
    </summary>
    
      <category term="bbc" scheme="http://colobu.com/tags/bbc/"/>
    
      <category term="trace" scheme="http://colobu.com/tags/trace/"/>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常用配置文件格式]]></title>
    <link href="http://colobu.com/2017/08/31/configuration-file-format/"/>
    <id>http://colobu.com/2017/08/31/configuration-file-format/</id>
    <published>2017-08-31T02:24:17.000Z</published>
    <updated>2017-08-31T04:02:36.000Z</updated>
    <content type="html"><![CDATA[<p>配置文件是工程中常用的初始化参数的配置方式，而配置文件的格式有很多种，不同的操作系统、编程语言都会有不同的配置文件的格式，本文罗列了一些常见的配置文件的格式。</p>
<p>不同的配置文件格式有不同的用户友好性， 对于功能的支持也有简单和复杂之分，很难简单说那种配置文件是最好的，有时候需要从多个方面去考虑， 比如Windows较早的开发喜欢使用<code>int</code>、java喜欢使用<code>properties</code>、通用的编程喜欢<code>yaml</code>、<code>json</code>等格式，本文也不会对这些格式进行排名，而是简单介绍一下这些格式，用户可以根据自己的实际情况进行选择。</p>
<a id="more"></a>
<h3 id="ini">ini</h3>
<p>ini文件是一个无固定标准格式的配置文件。它以简单的文字与简单的结构组成，常常使用在Windows操作系统。ini文件的命名来源，是取自英文“初始（Initial）”的首字缩写，正与它的用途——初始化程序相应。</p>
<p>文件格式比较简单， 分为 <code>节</code>、<code>参数</code>、<code>注释</code>。下面是一个简单的ini配置文件：</p>
<figure class="highlight ini"><figcaption><span>https://github.com/Microsoft/Windows-driver-samples/blob/master/print/v4PrintDriverSamples/v4PrintDriver-HostBasedSampleDriver/usb_host_based_sample-manifest.ini</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="title">[DriverConfig]</span></div><div class="line"><span class="setting">DriverCategory=<span class="value">PrintFax.Printer</span></span></div><div class="line"><span class="setting">DataFile=<span class="value">usb_host_based_sample.gpd</span></span></div><div class="line"></div><div class="line"><span class="comment">; Note: Please replace the GUID below when building a production driver.</span></div><div class="line"><span class="setting">PrinterDriverID=<span class="value">{<span class="number">00000000</span>-<span class="number">0000</span>-<span class="number">0000</span>-<span class="number">0000</span>-<span class="number">000000000000</span>}</span></span></div><div class="line"><span class="setting">Flags=<span class="value">HostBasedDevice</span></span></div><div class="line"><span class="setting">EventFile=<span class="value">usb_host_based_sample_events.xml</span></span></div><div class="line"><span class="setting">RequiredFiles=<span class="value">UNIRES.DLL,STDNAMES.GPD,MSXPSINC.GPD</span></span></div><div class="line"></div><div class="line"><span class="title">[BidiFiles]</span></div><div class="line"><span class="setting">BidiUSBFile=<span class="value">usb_host_based_sample_extension.xml</span></span></div><div class="line"><span class="setting">BidiUSBJSFile=<span class="value">usb_host_based_sample.js</span></span></div></pre></td></tr></table></figure>

<h3 id="properties">properties</h3>
<p>properties是一种主要在Java相关技术中用来存储应用程序的可配置参数的文件的文件扩展名。它们也可以存储用于国际化和本地化的字符串，这种文件被称为属性资源包（Property Resource Bundles）。<br>每个参数被存储为一对字符串：一个存储名称参数（被称为“键”），另一个存储值。</p>
<p>每个properties 文件中的行通常存储单个属性。对于每一行可能有这么几种格式，包括键=值，键 = 值，键:值，以及键 值。<br>.properties文件可以使用井号（#）或叹号（!）作为一行中第一个非空白字符来表示它后面的所有文本都是一个注释。反斜杠（\）用于转义字符。下面是一个properties文件：</p>
<figure class="highlight properties"><figcaption><span>https://github.com/netgloo/spring-boot-samples/blob/master/spring-boot-mysql-springdatajpa-hibernate/src/main/resources/application.properties</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># ===============================</div><div class="line"># = DATA SOURCE</div><div class="line"># ===============================</div><div class="line"></div><div class="line"># <span class="operator"><span class="keyword">Set</span> here configurations <span class="keyword">for</span> the <span class="keyword">database</span> <span class="keyword">connection</span></span></div><div class="line"></div><div class="line"># <span class="keyword">Connection</span> url <span class="keyword">for</span> the <span class="keyword">database</span> <span class="string">"netgloo_blog"</span></div><div class="line">spring.datasource.url = jdbc:mysql://localhost:<span class="number">3306</span>/netgloo_blog?useSSL=<span class="literal">false</span></div><div class="line"></div><div class="line"># Username <span class="keyword">and</span> <span class="keyword">password</span></div><div class="line">spring.datasource.username = root</div><div class="line">spring.datasource.<span class="keyword">password</span> = root</div><div class="line"></div><div class="line"># Keep the <span class="keyword">connection</span> alive <span class="keyword">if</span> idle <span class="keyword">for</span> a long <span class="keyword">time</span> (needed <span class="keyword">in</span> production)</div><div class="line">spring.datasource.testWhileIdle = <span class="literal">true</span></div><div class="line">spring.datasource.validationQuery = <span class="keyword">SELECT</span> <span class="number">1</span></div></pre></td></tr></table></figure>

<h3 id="json">json</h3>
<p>JSON（JavaScript Object Notation）是一种轻量级的数据交换语言，以文字为基础，且易于让人阅读。尽管JSON是Javascript的一个子集，但JSON是独立于语言的文本格式，并且采用了类似于C语言家族的一些习惯。<br>JSON 数据格式与语言无关，脱胎于 JavaScript，但目前很多编程语言都支持 JSON 格式数据的生成和解析, 所以也常常用作配置文件。</p>
<p>JSON用于描述数据结构，有以下形式存在。</p>
<ul>
<li>对象（object）：一个对象以<code>{</code>开始，并以<code>}</code>结束。一个对象包含一系列非排序的名称／值对，每个名称／值对之间使用<code>,</code>分区</li>
<li>名称／值（collection）：名称和值之间使用<code>：</code>隔开，一般的形式是：<code>{name:value}</code></li>
<li>值的有序列表（Array）：一个或者多个值用,分区后，使用<code>[，]</code>括起来就形成了这样的列表</li>
<li>字符串：以&quot;&quot;括起来的一串字符。</li>
<li>数值：一系列0-9的数字组合，可以为负数或者小数。还可以用e或者E表示为指数形式。</li>
<li>布尔值：表示为true或者false。</li>
</ul>
<p>JSON的格式描述可以参考RFC 4627。</p>
<p>下面是一个json配置文件的例子:</p>
<figure class="highlight json"><figcaption><span>https://github.com/hashicorp/vault/blob/master/command/server/test-fixtures/config.hcl.json</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">	"<span class="attribute">listener</span>": <span class="value">[{</span></div><div class="line">		"<span class="attribute">tcp</span>": <span class="value">{</span></div><div class="line">			"<span class="attribute">address</span>": <span class="value"><span class="string">"127.0.0.1:443"</span></span></div><div class="line">		}</div><div class="line">	}],</div><div class="line">	"<span class="attribute">cluster_cipher_suites</span>": <span class="value"><span class="string">"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"</span></span>,</div><div class="line">	"<span class="attribute">storage</span>": <span class="value">{</span></div><div class="line">		"<span class="attribute">consul</span>": <span class="value">{</span></div><div class="line">			"<span class="attribute">foo</span>": <span class="value"><span class="string">"bar"</span></span>,</div><div class="line">			"<span class="attribute">disable_clustering</span>": <span class="value"><span class="string">"true"</span></span></div><div class="line">		}</div><div class="line">	},</div><div class="line">	"<span class="attribute">telemetry</span>": <span class="value">{</span></div><div class="line">		"<span class="attribute">statsite_address</span>": <span class="value"><span class="string">"baz"</span></span></div><div class="line">	},</div><div class="line">	"<span class="attribute">max_lease_ttl</span>": <span class="value"><span class="string">"10h"</span></span>,</div><div class="line">	"<span class="attribute">default_lease_ttl</span>": <span class="value"><span class="string">"10h"</span></span>,</div><div class="line">	"<span class="attribute">cluster_name</span>":<span class="value"><span class="string">"testcluster"</span></span>,</div><div class="line">	"<span class="attribute">ui</span>":<span class="value"><span class="literal">true</span></span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="xml">xml</h3>
<p>xml是一种标记语言。标记指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种信息的文章等。<br>XML是从1995年开始有其雏形，并向W3C（万维网联盟）提案，而在1998年二月发布为W3C的标准（XML1.0）。</p>
<p>XML设计用来传送及携带数据信息，所以也经常用来做配置文件。</p>
<p>xml实例:</p>
<figure class="highlight xml"><figcaption><span>https://github.com/kpavlov/spring-cloud-config-sample/blob/master/src/main/resources/spring-config.xml</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span></div><div class="line">       <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="title">context:property-placeholder</span> <span class="attribute">location</span>=<span class="value">"</span></span></div><div class="line">    ${config.uri}/company.properties,</div><div class="line">    classpath:product.properties,</div><div class="line">    ${config.uri}/${product.name}/${product.version}/common.properties,</div><div class="line">    ${config.uri}/${product.name}/${product.version}/${config.stage}/stage.properties,</div><div class="line">    ${config.uri}/${product.name}/${product.version}/${config.stage}/${config.node}/node.properties"</div><div class="line">                                  <span class="attribute">system-properties-mode</span>=<span class="value">"FALLBACK"</span>/&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="title">context:annotation-config</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="title">context:component-scan</span> <span class="attribute">base-package</span>=<span class="value">"spring"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></div></pre></td></tr></table></figure>

<h3 id="yaml">yaml</h3>
<p>YAML（/ˈjæməl/，尾音类似camel骆驼）是一个可读性高，用来表达数据序列的格式。Clark Evans在2001年首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者。目前已经有数种编程语言或脚本语言支持（或者说解析）这种语言。</p>
<p>YAML是&quot;YAML Ain&#39;t a Markup Language&quot;（YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言，但为了强调这种语言以数据做为中心，而不是以标记语言为重点，而用反向缩略语重命名。</p>
<p>YAML的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色， 比较适合用来表达层次结构式的数据结构。</p>
<p>YAML 1.2 是 JSON 格式的<a href="http://www.yaml.org/spec/1.2/spec.html" target="_blank" rel="external">超集</a>。</p>
<figure class="highlight yaml"><figcaption><span>https://github.com/prometheus/prometheus/blob/master/config/testdata/conf.good.yml</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># my global config</div><div class="line">global:</div><div class="line">  scrape_interval:     15s</div><div class="line">  evaluation_interval: 30s</div><div class="line">  # scrape_timeout is set to the global default (10s).</div><div class="line"></div><div class="line">  external_labels:</div><div class="line">    monitor: codelab</div><div class="line">    foo:     bar</div><div class="line"></div><div class="line">rule_files:</div><div class="line">-<span class="ruby"> <span class="string">"first.rules"</span></span></div><div class="line">-<span class="ruby"> <span class="string">"my/*.rules"</span></span></div><div class="line"></div><div class="line">remote_write:</div><div class="line">  -<span class="ruby"> <span class="symbol">url:</span> <span class="symbol">http:</span>/<span class="regexp">/remote1/push</span></span></div><div class="line">    write_relabel_configs:</div><div class="line">    -<span class="ruby"> <span class="symbol">source_labels:</span> [__name_<span class="number">_</span>]</span></div><div class="line">      regex:         expensive.*</div><div class="line">      action:        drop</div><div class="line">  -<span class="ruby"> <span class="symbol">url:</span> <span class="symbol">http:</span>/<span class="regexp">/remote2/push</span></span></div></pre></td></tr></table></figure>

<h3 id="toml_https://zh-wikipedia-org/wiki/TOML">toml <a href="https://zh.wikipedia.org/wiki/TOML" target="_blank" rel="external">https://zh.wikipedia.org/wiki/TOML</a></h3>
<p>TOML是一种旨在成为一个小规模、易于使用的语义化的配置文件格式，它被设计为可以无二义性的转换为一个哈希表。<br>“TOML”这个名字是“Tom&#39;s Obvious, Minimal Language（汤姆的浅显的、极简的语言）”的首字母略写词。“Tom”指它的作者Tom Preston-Werner。<br>TOML已在一些软件工程中使用，并且可在很多程序语言中执行。</p>
<p>TOML的语法广泛地由<code>key = &quot;value&quot;</code>、<code>[节名]</code>与<code>#注释</code>构成。<br>它支持以下数据类型：字符串、整形、浮点型、布尔型、日期时间、数组和图表。</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># This is a TOML document.</span></div><div class="line"></div><div class="line"><span class="variable">title =</span> <span class="string">"TOML Example"</span></div><div class="line"></div><div class="line">[owner]</div><div class="line"><span class="variable">name =</span> <span class="string">"Tom Preston-Werner"</span></div><div class="line"><span class="variable">dob =</span> <span class="number">1979</span>-<span class="number">05</span>-<span class="number">27</span>T07:<span class="number">32</span>:<span class="number">00</span>-<span class="number">08</span>:<span class="number">00</span> <span class="comment"># First class dates</span></div><div class="line"></div><div class="line">[database]</div><div class="line"><span class="variable">server =</span> <span class="string">"192.168.1.1"</span></div><div class="line"><span class="variable">ports =</span> [ <span class="number">8001</span>, <span class="number">8001</span>, <span class="number">8002</span> ]</div><div class="line"><span class="variable">connection_max =</span> <span class="number">5000</span></div><div class="line"><span class="variable">enabled =</span> <span class="constant">true</span></div><div class="line"></div><div class="line">[servers]</div><div class="line"></div><div class="line">  <span class="comment"># Indentation (tabs and/or spaces) is allowed but not required</span></div><div class="line">  [servers.alpha]</div><div class="line">  <span class="variable">ip =</span> <span class="string">"10.0.0.1"</span></div><div class="line">  <span class="variable">dc =</span> <span class="string">"eqdc10"</span></div><div class="line"></div><div class="line">  [servers.beta]</div><div class="line">  <span class="variable">ip =</span> <span class="string">"10.0.0.2"</span></div><div class="line">  <span class="variable">dc =</span> <span class="string">"eqdc10"</span></div><div class="line"></div><div class="line">[clients]</div><div class="line"><span class="variable">data =</span> [ [<span class="string">"gamma"</span>, <span class="string">"delta"</span>], [<span class="number">1</span>, <span class="number">2</span>] ]</div><div class="line"></div><div class="line"><span class="comment"># Line breaks are OK when inside arrays</span></div><div class="line"><span class="variable">hosts =</span> [</div><div class="line">  <span class="string">"alpha"</span>,</div><div class="line">  <span class="string">"omega"</span></div><div class="line">]</div></pre></td></tr></table></figure>

<h3 id="HOCON">HOCON</h3>
<p>HOCON，全称Human-Optimized Config Object Notation（人性化配置对象表示法）是一种人类可读的数据格式，并是JSON和properties的一个超集。它由Lightbend(用Scala开发的人都知道)开发，主要与Play框架结合使用。它也在Puppet中作为配置格式使用。</p>
<p>基本上也算是Scala官方开发，所以在Scala的一些项目中得到使用。由于它是JSON和properties格式的超集，所以它的格式比较灵活。</p>
<p>格式定义可以参考官方文档： <a href="https://github.com/typesafehub/config/blob/master/HOCON.md" target="_blank" rel="external">HOCON</a>。</p>
<p>下面是它的一个实例：</p>
<figure class="highlight json"><figcaption><span>https://github.com/marcospereira/play-i18n-hocon/blob/master/samples/scala/conf/application.conf</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">play.http.secret.key = "changeme"</div><div class="line"></div><div class="line">play.modules {</div><div class="line">  # Disable built-in i18n module</div><div class="line">  disabled += play.api.i18n.I18nModule</div><div class="line"></div><div class="line">  # Enable Hocon module</div><div class="line">  enabled += com.marcospereira.play.i18n.HoconI18nModule</div><div class="line">}</div><div class="line"></div><div class="line">play.i18n {</div><div class="line">  langs = [ "en" ]</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="plist">plist</h3>
<p>在OS X的Cocoa，NeXTSTEP和GNUstep编程框架中，属性列表（Property List）文件是一种用来存储序列化后的对象的文件。属性列表文件的文件扩展名为.plist，因此通常被称为plist文件。<br>Plist文件通常用于储存用户设置，也可以用于存储捆绑的信息，该功能在旧式的Mac OS中是由资源分支提供的。</p>
<figure class="highlight plist"><figcaption><span>https://github.com/wahlmanj/com.plex.pms.plist/blob/master/com.plex.pms.plist</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></div><div class="line"><span class="doctype">&lt;!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" </span></div><div class="line">    "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</div><div class="line"><span class="tag">&lt;<span class="title">plist</span> <span class="attribute">version</span>=<span class="value">"1.0"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">dict</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="title">key</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">string</span>&gt;</span>com.plex.pms<span class="tag">&lt;/<span class="title">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>KeepAlive<span class="tag">&lt;/<span class="title">key</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">true</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>ProgramArguments<span class="tag">&lt;/<span class="title">key</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">array</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">string</span>&gt;</span>/Applications/Plex\ Media\ Server.app/Contents/MacOS/Plex\ Media\ Server<span class="tag">&lt;/<span class="title">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">array</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>RunAtLoad<span class="tag">&lt;/<span class="title">key</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">true</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>UserName<span class="tag">&lt;/<span class="title">key</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">string</span>&gt;</span>__USERNAME__<span class="tag">&lt;/<span class="title">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>WorkingDirectory<span class="tag">&lt;/<span class="title">key</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">string</span>&gt;</span>/Applications<span class="tag">&lt;/<span class="title">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>ServiceDescription<span class="tag">&lt;/<span class="title">key</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">string</span>&gt;</span>PMS<span class="tag">&lt;/<span class="title">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">dict</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">plist</span>&gt;</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>配置文件是工程中常用的初始化参数的配置方式，而配置文件的格式有很多种，不同的操作系统、编程语言都会有不同的配置文件的格式，本文罗列了一些常见的配置文件的格式。</p>
<p>不同的配置文件格式有不同的用户友好性， 对于功能的支持也有简单和复杂之分，很难简单说那种配置文件是最好的，有时候需要从多个方面去考虑， 比如Windows较早的开发喜欢使用<code>int</code>、java喜欢使用<code>properties</code>、通用的编程喜欢<code>yaml</code>、<code>json</code>等格式，本文也不会对这些格式进行排名，而是简单介绍一下这些格式，用户可以根据自己的实际情况进行选择。</p>
]]>
    
    </summary>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go Plugin的一个bug]]></title>
    <link href="http://colobu.com/2017/08/26/panic-on-go-plugin-Open-for-different-plugins/"/>
    <id>http://colobu.com/2017/08/26/panic-on-go-plugin-Open-for-different-plugins/</id>
    <published>2017-08-26T15:14:04.000Z</published>
    <updated>2017-08-29T12:03:57.000Z</updated>
    <content type="html"><![CDATA[<p>Go 1.8中增加了 <a href="https://golang.org/pkg/plugin/" target="_blank" rel="external">plugin</a> package,但是仅支持Linux操作系统，并且还有一些已知的bug。可以说，这个插件系统的实现还未达到&quot;产品级&quot;的水平。</p>
<blockquote>
<p>The plugin support is currently incomplete, only supports Linux, and has known bugs.</p>
</blockquote>
<p>一些已知的bug已经推到 Go1.10甚至以后的版本中修复了。</p>
<p>今天在测试Go 1.9中的功能的时候就遇到了plugin的一个bug。</p>
<a id="more"></a>
<p>按照官方的文档, 开发一个插件很简单：</p>
<figure class="highlight go"><figcaption><span>plugin1/main.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> V <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> F() { fmt.Printf(<span class="string">"Hello, number %d\n"</span>, V) }</div></pre></td></tr></table></figure>

<p>插件中定义了变量<code>V</code>和方法<code>F</code>，可以通过下面的命令生成一个<code>so</code>文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go build -buildmode=plugin -o ../p1.so main.go</div></pre></td></tr></table></figure>

<p>然后通过<code>plugin</code>包可以加载插件：</p>
<figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">p, err := plugin.Open(<span class="string">"p1.so"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="built_in">panic</span>(err)</div><div class="line">}</div><div class="line">v, err := p.Lookup(<span class="string">"V"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="built_in">panic</span>(err)</div><div class="line">}</div><div class="line">f, err := p.Lookup(<span class="string">"F"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="built_in">panic</span>(err)</div><div class="line">}</div><div class="line">*v.(*<span class="typename">int</span>) =<span class="number"> 7</span></div><div class="line">f.(<span class="keyword">func</span>())() <span class="comment">// prints "Hello, number 7"</span></div></pre></td></tr></table></figure>

<p>当然作为插件系统，我们希望可以加载新的插件，来替换已有的插件， 如果你复制<code>p1.so</code>为<code>p2.so</code>,然后上上面的测试代码中再加载<code>p2.so</code>会报错：</p>
<figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">p, err := plugin.Open(<span class="string">"p1.so"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="built_in">panic</span>(err)</div><div class="line">}</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line">p, err = plugin.Open(<span class="string">"p2.so"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="built_in">panic</span>(err)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>错误信息如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span></div><div class="line">Hello, number<span class="number"> 7</span></div><div class="line">plugin: plugin plugin/unnamed-f0c47a2a99a0d8e8fb40defabb50f238c78f5d58 already loaded</div><div class="line">fatal error: plugin: plugin already loaded</div><div class="line">......</div></pre></td></tr></table></figure>

<p>这一步我们还能理解，相同的plugin即使文件名更改了，加载进去还是一样的，所以会报<code>plugin already loaded</code>错误。</p>
<p>我们将<code>plugin1/main.go</code>中的代码<strong>稍微改一下</strong>：</p>
<figure class="highlight go"><figcaption><span>plugin1/main.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> V <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> F() { fmt.Printf(<span class="string">"Hello world,  %d\n"</span>, V) }</div></pre></td></tr></table></figure>

<p>然后生成插件<code>p2.so</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go build -buildmode=plugin -o ../p2.so main.go</div></pre></td></tr></table></figure>

<p>按说这次我们修改了代码，生成了一个新的插件，如果代码同时加载这两个插件，因为没什么问题，但是运行上面的加载两个插件的测试代码，发现还是出错：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">go <span class="command">run</span> main.go</div><div class="line">Hello, <span class="type">number</span> <span class="number">7</span></div><div class="line">plugin: plugin plugin/unnamed-f0c47a2a99a0d8e8fb40defabb50f238c78f5d58 already loaded</div><div class="line">fatal <span class="keyword">error</span>: plugin: plugin already loaded</div><div class="line">......</div></pre></td></tr></table></figure>

<p>怪异吧，两个不同代码的生成插件，居然被认为是同一个插件（plugin/unnamed-f0c47a2a99a0d8e8fb40defabb50f238c78f5d58）。</p>
<p>使用<code>nm</code>查看两个插件的符号表：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[root@colobu t]<span class="comment"># nm p1.so |grep unname</span></div><div class="line"><span class="number">00000000001</span>acfc0 R go.link.pkghashbytes.plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58</div><div class="line"><span class="number">00000000003</span>f9620 D go.link.pkghash.plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58</div><div class="line"><span class="number">0000000000199080</span> t local.plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.F</div><div class="line"><span class="number">0000000000199130</span> t local.plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.init</div><div class="line"><span class="number">0000000000199080</span> T plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.F</div><div class="line"><span class="number">0000000000199130</span> T plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.init</div><div class="line"><span class="number">000000000048</span>e027 B plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.initdone·</div><div class="line"><span class="number">000000000048</span>e088 B plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.V</div><div class="line">[root@colobu t]<span class="comment">#</span></div><div class="line">[root@colobu t]<span class="comment">#</span></div><div class="line">[root@colobu t]<span class="comment"># nm p2.so |grep unname</span></div><div class="line"><span class="number">00000000001</span>acfc0 R go.link.pkghashbytes.plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58</div><div class="line"><span class="number">00000000003</span>f9620 D go.link.pkghash.plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58</div><div class="line"><span class="number">0000000000199080</span> t local.plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.F</div><div class="line"><span class="number">0000000000199130</span> t local.plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.init</div><div class="line"><span class="number">0000000000199080</span> T plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.F</div><div class="line"><span class="number">0000000000199130</span> T plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.init</div><div class="line"><span class="number">000000000048</span>e027 B plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.initdone·</div><div class="line"><span class="number">000000000048</span>e088 B plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.V</div><div class="line">[root@colobu t]<span class="comment">#</span></div></pre></td></tr></table></figure>

<p>可以看到两个插件中生成的符号表符号表是相同的，所以被误认为了同一个插件。</p>
<p>这种情况是在特殊情况下产生的，如果两个插件的文件名不同，或者引用包不同，或者引用的cgo不同，则会生成不同的插件，同时加载不会有问题。但是如果文件名相同，相关的引用也相同，则可能生成相同的插件，尽管插件内包含的方法和变量不同，实现也不同。</p>
<p>这是Go plugin生成的时候一个bug: <a href="https://github.com/golang/go/issues/19358" target="_blank" rel="external">issue#19358</a>, 期望在Go 1.10中解决，目前的解决办法就是插件的go文件使用不同的名字，或者编译的时候指定<code>pluginpath</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">go build -ldflags <span class="string">"-pluginpath=p1"</span>-buildmode=plugin -o ../p1.so main.go</div><div class="line">go build -ldflags <span class="string">"-pluginpath=p2"</span>-buildmode=plugin -o ../p2.so main.go</div></pre></td></tr></table></figure>

<p>导致问题的原因正如  LionNatsu 在bug中指出的， Go 判断两个插件是否相同是通过比较<a href="https://github.com/golang/go/blob/0efc8b21881ab35fdb45547088b1935fc8ebf263/src/runtime/plugin.go#L23" target="_blank" rel="external">pluginpath</a>实现的，如果你在编译的时候指定了不同的<code>pluginpath</code>，则编译出来的插件是不同的，但是如果没有指定<code>pluginpath</code>，则由内部的算法生成, <a href="https://github.com/golang/go/blob/f8b0231639859de7b8f1bfe7df1be0132aec9ad6/src/cmd/go/internal/work/build.go#L2426" target="_blank" rel="external">生成</a>的格式为<code>plugin/unnamed-&quot; + root.Package.Internal.BuildID</code> 。</p>
<p><a href="https://github.com/golang/go/blob/be04da8f0c5cb57e2736cfac8c76971d7d8cfc6f/src/cmd/go/internal/load/pkg.go#L1621" target="_blank" rel="external">func computeBuildID(p *Package)</a> 生成一个SHA-1的哈希值作为BuildID。</p>
<figure class="highlight go"><figcaption><span>go/src/cmd/go/internal/load/pkg.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> computeBuildID(p *Package) {</div><div class="line">	h := sha1.New()</div><div class="line"></div><div class="line">	<span class="comment">// Include the list of files compiled as part of the package.</span></div><div class="line">	<span class="comment">// This lets us detect removed files. See issue 3895.</span></div><div class="line">	inputFiles := str.StringList(</div><div class="line">		p.GoFiles,</div><div class="line">		p.CgoFiles,</div><div class="line">		p.CFiles,</div><div class="line">		p.CXXFiles,</div><div class="line">		p.MFiles,</div><div class="line">		p.HFiles,</div><div class="line">		p.SFiles,</div><div class="line">		p.SysoFiles,</div><div class="line">		p.SwigFiles,</div><div class="line">		p.SwigCXXFiles,</div><div class="line">	)</div><div class="line">	<span class="keyword">for</span> _, file := <span class="keyword">range</span> inputFiles {</div><div class="line">		fmt.Fprintf(h, <span class="string">"file %s\n"</span>, file)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// Include the content of runtime/internal/sys/zversion.go in the hash</span></div><div class="line">	<span class="comment">// for package runtime. This will give package runtime a</span></div><div class="line">	<span class="comment">// different build ID in each Go release.</span></div><div class="line">	<span class="keyword">if</span> p.Standard && p.ImportPath == <span class="string">"runtime/internal/sys"</span> && cfg.BuildContext.Compiler != <span class="string">"gccgo"</span> {</div><div class="line">		data, err := ioutil.ReadFile(filepath.Join(p.Dir, <span class="string">"zversion.go"</span>))</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			base.Fatalf(<span class="string">"go: %s"</span>, err)</div><div class="line">		}</div><div class="line">		fmt.Fprintf(h, <span class="string">"zversion %q\n"</span>, <span class="typename">string</span>(data))</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// Include the build IDs of any dependencies in the hash.</span></div><div class="line">	<span class="comment">// This, combined with the runtime/zversion content,</span></div><div class="line">	<span class="comment">// will cause packages to have different build IDs when</span></div><div class="line">	<span class="comment">// compiled with different Go releases.</span></div><div class="line">	<span class="comment">// This helps the go command know to recompile when</span></div><div class="line">	<span class="comment">// people use the same GOPATH but switch between</span></div><div class="line">	<span class="comment">// different Go releases. See issue 10702.</span></div><div class="line">	<span class="comment">// This is also a better fix for issue 8290.</span></div><div class="line">	<span class="keyword">for</span> _, p1 := <span class="keyword">range</span> p.Internal.Deps {</div><div class="line">		fmt.Fprintf(h, <span class="string">"dep %s %s\n"</span>, p1.ImportPath, p1.Internal.BuildID)</div><div class="line">	}</div><div class="line"></div><div class="line">	p.Internal.BuildID = fmt.Sprintf(<span class="string">"%x"</span>, h.Sum(<span class="constant">nil</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>函数的后半部分为Go不同的版本生成不同的哈希，避免用户使用不同的Go版本生成相同的ID。重点看前半部分，可以发现计算哈希的时候只依赖文件名，并不关心文件的内容，这也是我们前面稍微修改一下插件的代码会生成相同的原因， 如果你在代码中<code>import _ &quot;fmt&quot;</code>也会产生不同的插件。</p>
<p>总之，在Go 1.10之前，为了避免插件冲突， 最好是在编译的时候指定<code>pluginpath</code>, 比如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go build -ldflags <span class="string">"-pluginpath=plugin/hot-<span class="variable">$(date +%s)</span>"</span> -buildmode=plugin -o hotload.so hotload.go</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>Go 1.8中增加了 <a href="https://golang.org/pkg/plugin/" target="_blank" rel="external">plugin</a> package,但是仅支持Linux操作系统，并且还有一些已知的bug。可以说，这个插件系统的实现还未达到&quot;产品级&quot;的水平。</p>
<blockquote>
<p>The plugin support is currently incomplete, only supports Linux, and has known bugs.</p>
</blockquote>
<p>一些已知的bug已经推到 Go1.10甚至以后的版本中修复了。</p>
<p>今天在测试Go 1.9中的功能的时候就遇到了plugin的一个bug。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]设计一个容错的微服务架构]]></title>
    <link href="http://colobu.com/2017/08/23/Designing-a-Microservices-Architecture-for-Failure/"/>
    <id>http://colobu.com/2017/08/23/Designing-a-Microservices-Architecture-for-Failure/</id>
    <published>2017-08-23T05:31:10.000Z</published>
    <updated>2017-08-23T05:52:09.000Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://blog.risingstack.com/designing-microservices-architecture-for-failure/" target="_blank" rel="external">Designing a Microservices Architecture for Failure</a><br>翻译: <a href="https://github.com/jasonGeng88/blog" target="_blank" rel="external">设计一个容错的微服务架构</a> by Jason Geng</p>
<p>微服务架构使得可以通过明确定义的服务边界来隔离故障。但是像在每个分布式系统中一样，发生网络、硬件、应用级别的错误都是很常见的。由于服务依赖关系，任何组件可能暂时无法提供服务。为了尽量减少部分中断的影响，我们需要构建容错服务，来优雅地处理这些中断的响应结果。</p>
<p>本文介绍了基于<a href="https://risingstack.com/" target="_blank" rel="external">RisingStack 的 Node.js 咨询和开发经验</a>构建和操作高可用性微服务系统的最常见技术和架构模式。</p>
<p>如果你不熟悉本文中的模式，那并不一定意味着你做错了。建立可靠的系统总是会带来额外的成本。</p>
<a id="more"></a>
<h2 id="微服务架构的风险">微服务架构的风险</h2>
<p>微服务架构将应用程序逻辑移动到服务，并使用网络层在它们之间进行通信。这种通过网络间通信代替单应用程序内调用的做法，会带来额外的延迟，以及需要协调多个物理和逻辑组件的系统复杂度。分布式系统的复杂性增加也将导致更高的网络故障率。</p>
<blockquote>
<p>microservices allow you to achieve graceful service degradation as components can be set up to fail separately.</p>
</blockquote>
<p>微服务体系结构的最大优势之一是，团队可以独立设计，开发和部署他们的服务。他们对服务的生命周期拥有完全的所有权。这也意味着团队无法控制他们依赖的服务，因为它更有可能由不同的团队管理。使用微服务架构，我们需要记住，提供者服务可能会临时不可用，由于其他人员发行的错误版本，配置以及其他更改等。</p>
<h2 id="优雅的服务降级">优雅的服务降级</h2>
<p>微服务架构的最大优点之一是您可以隔离故障，并在当组件单独故障时，进行优雅的服务降级。 例如，在中断期间，照片共享应用程序中的客户可能无法上传新图片，但仍可以浏览，编辑和共享其现有照片。</p>
<p><img src="microservices-fail-separately-in-theory.png" alt="微服务容错隔离"></p>
<p>在大多数情况下，由于分布式系统中的应用程序相互依赖，因此很难实现这种优雅的服务降级，您需要应用几种故障转移的逻辑（其中一些将在本文后面介绍），以为暂时的故障和中断做准备。</p>
<p><img src="Microservices-depend-on-each-other.png" alt="服务间彼此依赖，再没有故障转移逻辑下，服务全部失败。"></p>
<h2 id="变更管理">变更管理</h2>
<p>Google的网站可靠性小组发现，<strong>大约70％的中断是由现有系统的变化引起的</strong>。当您更改服务中的某些内容时，您将部署新版本的代码或更改某些配置 - 这总有可能会造成故障，或者引入新的bug。</p>
<p>在微服务架构中，服务依赖于彼此。这就是为什么你应该尽量减少故障并限制它的负面影响。要处理变更中的问题，您可以实施变更管理策略和<strong>自动回滚</strong>机制。</p>
<p>例如，当您部署新代码或更改某些配置时，您应该先小范围的进行部分的替换，以渐进式的方式替换服务的全部实例。在这期间，需要监视它们，如果您发现它们对您的关键指标有负面影响，应立即进行服务回滚，这称为“金丝雀部署”。</p>
<p><img src="microservices-change-management.png" alt="变更管理 - 回滚部署"></p>
<p>另一个解决方案可能是您运行两个生产环境。您始终只能部署其中一个，并且在验证新版本是否符合预期之后才，将负载均衡器指向新的。这称为蓝绿或红黑部署。</p>
<p><strong>回滚代码不是坏事</strong>。你不应该在生产中遗留错误的代码，然后考虑出了什么问题。如果必要，越早回滚你的代码越好。</p>
<h2 id="健康检查与负载均衡">健康检查与负载均衡</h2>
<p>实例由于出现故障、部署或自动缩放的情况，会进行持续启动、重新启动或停止操作。它可能导致它们暂时或永久不可用。为避免问题，您的负载均衡器应该从路由中<strong>跳过不健康的实例</strong>，因为它们当前无法为客户或子系统提供服务。</p>
<p>应用实例健康状况可以通过外部观察来确定。您可以通过重复调用<strong>GET /health</strong>端点或通过自我报告来实现。现在主流的<strong>服务发现</strong>解决方案，会持续从实例中收集健康信息，并配置负载均衡器，将流量仅路由到健康的组件上。</p>
<h2 id="自我修复">自我修复</h2>
<p>自我修复可以帮助应用程序从错误中恢复过来。当应用程序可以<strong>采取必要步骤</strong>从故障状态恢复时，我们就可以说它是可以实现自我修复的。在大多数情况下，它由外部系统实现，该系统会监视实例运行状况，并在较长时间内处于故障状态时重新启动它们。自我修复在大多数情况下是非常有用的。但是在某些情况下，持续地重启应用程序可能会<strong>导致麻烦</strong>。 当您的应用程序由于超负荷或其数据库连接超时而无法给出健康的运行状况时，这种情况下的频繁的重启就可能就不太合适了。</p>
<p>对于这种特殊的场景（如丢失的数据库连接），要实现满足它的高级自我修复的解决方案可能很棘手。在这种情况下，您需要为应用程序添加额外的逻辑来处理边缘情况，并让外部系统知道实例不需要立即重新启动。</p>
<h2 id="故障转移缓存">故障转移缓存</h2>
<p>由于网络问题和我们系统的变化，服务经常会失败。然而，由于自我修复和负载均衡的保障，它们中的大多数中断是临时的，我们应该找到一个解决方案，使我们的服务在这些故障时服务仍就可以工作。这就是<strong>故障转移缓存</strong> (failover caching)的作用，它可以帮助并为我们的应用程序在服务故障时提供必要的数据。</p>
<p>故障转移缓存通常使用<strong>两个不同的过期日期</strong>; 较短的时间告诉您在正常情况下缓存可以使用的过期时间，而较长的时间可以在服务故障时缓存依旧可用的过期时间。</p>
<p><img src="microservices-failover-caching.png" alt="故障转移缓存"></p>
<p>请务必提及，只有当服务使用过时的数据比没有数据更好时，才能使用故障转移缓存。</p>
<p>要设置缓存和故障转移缓存，可以在 HTTP 中使用标准响应头。</p>
<p>例如，使用 <code>max-age</code> 属性可以指定资源被视为有效的最大时间。使用 <code>stale-if-error</code> 属性，您可以明确在出现故障的情况下，依旧可以从缓存中获取资源的最大时间。</p>
<p>现代的 CDN 和负载均衡器都提供各种缓存和故障转移行为，但您也可以为拥有标准可靠性解决方案的公司创建一个共享库。</p>
<h2 id="重试逻辑">重试逻辑</h2>
<p>在某些情况下，我们无法缓存数据，或者我们想对其进行更改，但是我们的操作最终都失败了。对于此，我们可以重试我们的操作，因为我们可以预期资源将在一段时间后恢复，或者我们的负载均衡器将请求发送到了健康的实例上。</p>
<p>您应该小心地为您的应用程序和客户端添加重试逻辑，因为大量的<strong>重试可能会使事情更糟</strong>，甚至阻止应用程序恢复，如当服务超载时，大量的重试只能使状况更糟。</p>
<p>在分布式系统中，微服务系统重试可以触发多个其他请求或重试，并启动<strong>级联效应</strong>。为了最小化重试的影响，您应该限制它们的数量，并使用指数退避算法来持续增加重试之间的延迟，直到达到最大限制。</p>
<p>当客户端（浏览器，其他微服务等）发起重试，并且客户端不知道在处理请求之前或之后操作失败时，您应该为你的应用程序做好<strong>幂等处理</strong>的准备。例如，当您重试购买操作时，您不应该再次向客户收取费用。为每个交易使用唯一的<strong>幂等值键</strong>可以帮助处理重试。</p>
<h2 id="限流器和负载降级">限流器和负载降级</h2>
<p>流量限制是在一段时间内定义特定客户或应用程序可以接收或处理多少个请求的技术。例如，通过流量限制，您可以过滤掉造成流量峰值的客户和服务，或者您可以确保您的应用程序在自动缩放无法满足时，依然不会超载。</p>
<p>您还可以阻止较低优先级的流量，为关键事务提供足够的资源。</p>
<p><img src="microservices-rate-limiter.png" alt="限流器可以阻止流量峰值产生"></p>
<p>有一个不同类型的限流器，叫做并发请求限制器。当您有重要的端点，您不应该被调用超过指定的次数，而您仍然想要能提供服务时，这将是有用的。</p>
<p>负载降级的一系列使用，可以确保总是有足够的资源来提供关键交易。它为高优先级请求保留一些资源，不允许低优先级的事务使用它们。负载降级开关是根据系统的整体状态做出决定，而不是基于单个用户的请求量大小。负载降级有助于您的系统恢复，因为当你有一个偶发事件时（可能是一个热点事件），您仍能保持核心功能的正常工作。</p>
<p>要了解有关限流器和负载降级的更多信息，我建议查看这篇<a href="https://stripe.com/blog/rate-limiters" target="_blank" rel="external">Stripe的文章</a>。</p>
<h2 id="快速失败原则与独立性">快速失败原则与独立性</h2>
<p>在微服务架构中，我们想要做到让我们的服务具备快速失败与相互独立的能力。为了在服务级别上进行故障隔离，我们可以使用舱壁模式。你可以在本文的后面阅读更多有关舱壁的内容。</p>
<p>我们也希望我们的组件能够快速失败，因为我们不希望对于有故障的服务，在请求超时后才断开。没有什么比挂起的请求和无响应的 UI 更令人失望。这不仅浪费资源，而且还会影响用户体验。我们的服务在调用链中是相互调用的，所以在这些延迟累加之前，我们应该特别注意防止挂起操作。</p>
<p>你想到的第一个想法是对每个服务调用都设置明确的超时等级。这种方法的问题是，您不能知道真正合理的超时值是多少，因为网络故障和其他问题发生的某些情况只会影响一两次操作。在这种情况下，如果只有其中一些超时，您可能不想拒绝这些请求。</p>
<p>我们可以说，在微服务种通过使用超时来达到快速失败的效果是一种反模式的，你应该避免使用它。取而代之，您可以应用断路器模式，依据操作的成功与失败统计数据决定。</p>
<h2 id="舱壁模式">舱壁模式</h2>
<p>工业中使用舱壁将船舶划分为几个部分，以便在船体破坏的情况下，可以将船舶各个部件密封起来。</p>
<p>舱壁的概念在软件开发中可以被应用在隔离资源上。</p>
<p>通过应用舱壁模式，我们可以保护有限的资源不被耗尽。例如，对于一个有连接数限制的数据库实例来说，如果我们有两种连接它的操作，我们采用可以采用两个连接池的方式进行连接，来代替仅采用一个共享连接池的方式。由于这种客户端与资源进行了隔离，超时或过度使用池的操作页不会使其他操作失败。</p>
<p>泰坦尼克号沉没的主要原因之一是其舱壁设计失败，水可以通过上面的甲板倒在舱壁的顶部，导致整个船体淹没。</p>
<p><img src="titanic-bulkhead-microservices.png" alt="泰坦尼克号舱壁设计（无效的设计）"></p>
<h2 id="断路器">断路器</h2>
<p>为了限制操作的持续时间，我们可以使用超时。超时可以防止挂起操作并保持系统响应。然而，在微服务中使用静态、精细的超时是一种反模式，因为我们处于高度动态的环境中，几乎不可能提出在每种情况下都能正常工作的正确的时间限制。</p>
<p>替代这种静态超时的手段是，我们可以使用断路器来处理错误。断路器以现实世界的电子元件命名，因为它们的作用是相同的。您可以保护资源，并帮助他们使用断路器进行恢复。它们在分布式系统中非常有用，因为在分布式系统中，重复故障可能导致雪球效应并使整个系统瘫痪。</p>
<p>当特定类型的错误在短时间内多次发生时，断路器会被断开。开路的断路器可以防止进一步的请求 - 就像我们平时所说的电路跳闸一样。断路器通常在一定时间后关闭，在这期间可以为底层服务提供足够的空间来恢复。</p>
<p>请记住，并不是所有的错误都应该触发断路器。例如，您可能希望跳过客户端问题，例如具有4xx响应代码的请求，但不包括5xx服务器端故障。一些断路器也具有半开状态。在这种状态下，服务发送第一个请求以检查系统可用性，同时让其他请求失败。如果这个第一个请求成功，它将使断路器恢复到关闭状态并使流量流动。否则，它保持打开。</p>
<p><img src="microservices-circuit-breakers.png" alt="断路器"></p>
<h2 id="测试故障">测试故障</h2>
<p>您应该不断测试您系统的常见问题，以确保您的服务可以抵抗各种故障。您应经常测试故障，让您的团队具备故障处理的能力。</p>
<p>对于测试，您可以使用外部服务来标识实例组，并随机终止此组中的一个实例。这样，您可以准备单个实例故障，但您甚至可以关闭整个区域来模拟云提供商的故障。</p>
<p>最流行的测试解决方案之一是 Netflix 的 <a href="https://github.com/Netflix/chaosmonkey" target="_blank" rel="external">ChaosMonkey 弹性工具</a>。</p>
<h2 id="结尾">结尾</h2>
<p>实施和运行可靠的服务并不容易。 您需要付出很多努力，同时公司也要有相应的财力投入。</p>
<p>可靠性有很多层次和方面，因此找到最适合您团队的解决方案很重要。您应该使可靠性成为您的业务决策流程中的一个因素，并为其分配足够的预算和时间。</p>
<h2 id="关键点">关键点</h2>
<ul>
<li>动态环境和分布式系统（如微服务）会导致更高的故障机率；</li>
<li>服务应该做到故障隔离，到达优雅降级，来提升用户体验；</li>
<li>70％的中断是由变化引起的，代码回滚不是一件坏事；</li>
<li>做到服务快速失败与独立性。团队是无法控制他们所依赖的服务情况；</li>
<li>缓存、舱壁、断路器和限流器等架构模式与技术有助于构建可靠的微服务架构。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://blog.risingstack.com/designing-microservices-architecture-for-failure/" target="_blank" rel="external">Designing a Microservices Architecture for Failure</a><br>翻译: <a href="https://github.com/jasonGeng88/blog" target="_blank" rel="external">设计一个容错的微服务架构</a> by Jason Geng</p>
<p>微服务架构使得可以通过明确定义的服务边界来隔离故障。但是像在每个分布式系统中一样，发生网络、硬件、应用级别的错误都是很常见的。由于服务依赖关系，任何组件可能暂时无法提供服务。为了尽量减少部分中断的影响，我们需要构建容错服务，来优雅地处理这些中断的响应结果。</p>
<p>本文介绍了基于<a href="https://risingstack.com/" target="_blank" rel="external">RisingStack 的 Node.js 咨询和开发经验</a>构建和操作高可用性微服务系统的最常见技术和架构模式。</p>
<p>如果你不熟悉本文中的模式，那并不一定意味着你做错了。建立可靠的系统总是会带来额外的成本。</p>
]]>
    
    </summary>
    
      <category term="架构" scheme="http://colobu.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再谈谈获取 goroutine id 的方法]]></title>
    <link href="http://colobu.com/2017/08/04/talk-about-getting-goroutine-id-again/"/>
    <id>http://colobu.com/2017/08/04/talk-about-getting-goroutine-id-again/</id>
    <published>2017-08-04T03:38:05.000Z</published>
    <updated>2017-09-05T00:58:54.000Z</updated>
    <content type="html"><![CDATA[<p>去年年初的时候曾经写过一篇关于如何获取goroutine id的方法： <a href="http://colobu.com/2016/04/01/how-to-get-goroutine-id/" target="_blank" rel="external">如何得到goroutine 的 id?</a>, 当时调研了一些一些获取goid的方法。基本的方法有三种：</p>
<ol>
<li>通过Stack信息解析出ID</li>
<li>通过汇编获取<code>runtime·getg</code>方法的调用结果</li>
<li>直接修改运行时的代码，export一个可以外部调用的GoID()方法</li>
</ol>
<p>每个方式都有些问题， #1比较慢， #2因为是hack的方式(Go team并不想暴露go id的信息), 针对不同的Go版本中需要特殊的hack手段， #3需要定制Go运行时，不通用。当时的<a href="https://github.com/petermattis/goid" target="_blank" rel="external">petermattis/goid</a>提供了 #2 的方法， 但是只能在 go 1.3中才起作用，所以只能选择#1的方式获取go id。</p>
<p>最近一年来， petermattis更新了他的代码，逐步增加了对 Go 1.4、1.5、1.6、1.7、1.8、1.9的支持，同时也提供了#1的方法，在#2方法不起作用的时候作为备选，所以我们可以在当前的所有的版本中可以使用stable的获取go id的方法了。</p>
<a id="more"></a>
<p>你或许会遇到一些需要使用Go ID的场景， 比如在多goroutine长时间运行任务的时候，我们通过日志来跟踪任务的执行情况，可以通过go id来大致地跟踪程序并发执行的时候的状况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/petermattis/goid"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="keyword">for</span> j :=<span class="number"> 0</span>; j &lt;<span class="number"> 1000000</span>; j++ {</div><div class="line">				log.Printf(<span class="string">"[#%d] %d"</span>, goid.Get(), j)</div><div class="line">				time.Sleep<span class="number">(10e9</span>)</div><div class="line">			}</div><div class="line">		}()</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">select</span> {}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>依照Go代码中的文档<a href="https://golang.org/src/runtime/HACKING.md" target="_blank" rel="external">HACKING</a>, go运行时中实现了一个<code>getg()</code>方法，可以获取当前的goroutine：</p>
<blockquote>
<p><code>getg()</code> alone returns the current <code>g</code></p>
</blockquote>
<p>当然这个方法是内部方法，不是exported,不能被外部的调用，而且返回的数据结构也是未exported的。如果有办法暴露出这个方法，问题就解决了。</p>
<p><a href="https://github.com/petermattis/goid" target="_blank" rel="external">petermattis/goid</a> 模仿<code>runtime.getg</code>暴露出一个<code>getg</code>的方法</p>
<figure class="highlight asm"><figcaption><span>https://github.com/petermattis/goid/blob/master/goid_go1.5plus.s</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// +build amd64 amd64p32</div><div class="line">// +build go1<span class="string">.5</span></div><div class="line"></div><div class="line">#include <span class="string">"textflag.h"</span></div><div class="line"></div><div class="line">// func getg() uintptr</div><div class="line">TEXT ·getg(SB),<span class="preprocessor">NOSPLIT</span>,<span class="number">$0</span>-<span class="number">8</span></div><div class="line">	<span class="keyword">MOVQ</span> (TLS), <span class="number">BX</span></div><div class="line">	<span class="keyword">MOVQ</span> <span class="number">BX</span>, <span class="keyword">ret</span>+<span class="number">0</span>(FP)</div><div class="line">	<span class="keyword">RET</span></div></pre></td></tr></table></figure>

<p>上面的代码实际是将当前的goroutine的结构体的指针(TLS)返回。</p>
<blockquote>
<p>参考： <a href="https://blog.altoros.com/golang-internals-part-3-the-linker-and-object-files.html" target="_blank" rel="external">Golang Internals</a> 以及中文翻译 <a href="http://blog.jobbole.com/92371/" target="_blank" rel="external">Go语言内幕</a><br>TLS 其实是线程本地存储 （Thread Local Storage ）的缩写。这个技术在很多编程语言中都有用到（请参考这里）。简单地说，它为每个线程提供了一个这样的变量，不同变量用于指向不同的内存区域。</p>
<p>在 Go 语言中，TLS 存储了一个 G 结构体的指针。这个指针所指向的结构体包括 Go 例程的内部细节（后面会详细谈到这些内容）。因此，当在不同的例程中访问该变量时，实际访问的是该例程相应的变量所指向的结构体。链接器知道这个变量所在的位置，前面的指令中移动到 CX 寄存器的就是这个变量。对于 AMD64，TLS 是用 FS 寄存器来实现的， 所在我们前面看到的命令实际上可以翻译为 MOVQ FS, CX。</p>
</blockquote>
<p>不同的Go版本获取的数据结构可能是不同的，所以<code>petermattis/goid</code>针对1.5、1.6、1.9有变动的版本定制了不同的数据结构，因为我们只需要得到goroutine的ID,所以只需实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Get() <span class="typename">int64</span> {</div><div class="line">	gg := (*g)(unsafe.Pointer(getg()))</div><div class="line">	<span class="keyword">return</span> gg.goid</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我比较了一下#1和#2这两种实现方式的性能，差距还是非常大的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pkg</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"runtime"</span></div><div class="line">	<span class="string">"testing"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/petermattis/goid"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkASM(b *testing.B) {</div><div class="line">	b.ReportAllocs()</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		goid.Get()</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkSlow(b *testing.B) {</div><div class="line">	b.ReportAllocs()</div><div class="line">	<span class="keyword">var</span> buf <span class="number">[64</span>]<span class="typename">byte</span></div><div class="line">	b.ResetTimer()</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		goid.ExtractGID(buf[:runtime.Stack(buf[:], <span class="constant">false</span>)])</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>性能比较结果:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BenchmarkASM-4    	300000000	         3.70 ns/op	       0 B/op	       0 allocs/op</div><div class="line">BenchmarkSlow-4   	  300000	      4071 ns/op	       1 B/op	       1 allocs/op</div></pre></td></tr></table></figure>

<p>一千多倍的差距。</p>
<p><code>petermattis/goid</code>这种hack的方式可以暴露更多的运行时的细节，比如我们可以扩展一下，得到当前哪个<code>m</code>正在运行，甚至可以得到当前的线程的信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> {</div><div class="line">	g0        *g</div><div class="line">	morebuf   gobuf</div><div class="line">	divmod    <span class="typename">uint32</span></div><div class="line">	procid    <span class="typename">uint64</span></div><div class="line">	gsignal   *g</div><div class="line">	sigmask   sigset</div><div class="line">	tls       <span class="number">[6</span>]<span class="typename">uintptr</span></div><div class="line">	mstartfn  <span class="keyword">func</span>()</div><div class="line">	curg      *g</div><div class="line">	caughtsig <span class="typename">uintptr</span></div><div class="line">	p         <span class="typename">uintptr</span></div><div class="line">	nextp     <span class="typename">uintptr</span></div><div class="line">	id        <span class="typename">int32</span></div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">func</span> GetM() <span class="typename">int32</span> {</div><div class="line">	gg := (*g)(unsafe.Pointer(getg()))</div><div class="line">	m := (*m)(unsafe.Pointer(gg.m))</div><div class="line">	<span class="keyword">return</span> m.id</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>sigset</code>在不同的平台的大小是不一样的，可以参考<a href="https://github.com/golang/go/tree/master/src/runtime" target="_blank" rel="external">os_*.go</a>中各平台的定义。上面是得到<code>m</code>的ID, 更全的<code>m</code>的结构定义海包括<code>thread</code>等信息。</p>
<p><strong>2017-09-05 更新</strong></p>
<p>petermattis 最近做了更新， 利用go本身的<code>g_goid</code>宏，直接利用汇编就可以获取goroutine id,比上面的方式更简单，性能还好:</p>
<figure class="highlight asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#include <span class="string">"go_asm.h"</span></div><div class="line">#include <span class="string">"textflag.h"</span></div><div class="line"></div><div class="line">// func Get() int64</div><div class="line">TEXT ·Get(SB),<span class="preprocessor">NOSPLIT</span>,<span class="number">$0</span>-<span class="number">8</span></div><div class="line">	<span class="keyword">MOVQ</span> (TLS), <span class="literal">R14</span></div><div class="line">	<span class="keyword">MOVQ</span> g_goid(<span class="literal">R14</span>), <span class="literal">R13</span></div><div class="line">	<span class="keyword">MOVQ</span> <span class="literal">R13</span>, <span class="keyword">ret</span>+<span class="number">0</span>(FP)</div><div class="line">	<span class="keyword">RET</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>去年年初的时候曾经写过一篇关于如何获取goroutine id的方法： <a href="http://colobu.com/2016/04/01/how-to-get-goroutine-id/" target="_blank" rel="external">如何得到goroutine 的 id?</a>, 当时调研了一些一些获取goid的方法。基本的方法有三种：</p>
<ol>
<li>通过Stack信息解析出ID</li>
<li>通过汇编获取<code>runtime·getg</code>方法的调用结果</li>
<li>直接修改运行时的代码，export一个可以外部调用的GoID()方法</li>
</ol>
<p>每个方式都有些问题， #1比较慢， #2因为是hack的方式(Go team并不想暴露go id的信息), 针对不同的Go版本中需要特殊的hack手段， #3需要定制Go运行时，不通用。当时的<a href="https://github.com/petermattis/goid" target="_blank" rel="external">petermattis/goid</a>提供了 #2 的方法， 但是只能在 go 1.3中才起作用，所以只能选择#1的方式获取go id。</p>
<p>最近一年来， petermattis更新了他的代码，逐步增加了对 Go 1.4、1.5、1.6、1.7、1.8、1.9的支持，同时也提供了#1的方法，在#2方法不起作用的时候作为备选，所以我们可以在当前的所有的版本中可以使用stable的获取go id的方法了。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/tags/Go/"/>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go 1.9 sync.Map揭秘]]></title>
    <link href="http://colobu.com/2017/07/11/dive-into-sync-Map/"/>
    <id>http://colobu.com/2017/07/11/dive-into-sync-Map/</id>
    <published>2017-07-11T10:09:48.000Z</published>
    <updated>2017-07-19T09:59:06.000Z</updated>
    <content type="html"><![CDATA[<p>在Go 1.6之前， 内置的map类型是部分goroutine安全的，并发的读没有问题，并发的写可能有问题。自go 1.6之后， 并发地读写map会报错，这在一些知名的开源库中都存在这个问题，所以go 1.9之前的解决方案是额外绑定一个锁，封装成一个新的struct或者单独使用锁都可以。</p>
<p>本文带你深入到<code>sync.Map</code>的具体实现中，看看为了增加一个功能，代码是如何变的复杂的,以及作者在实现<code>sync.Map</code>的一些思想。</p>
<a id="more"></a>
<h3 id="有并发问题的map">有并发问题的map</h3>
<p>官方的<a href="https://golang.org/doc/faq#atomic_maps" target="_blank" rel="external">faq</a>已经提到内建的<code>map</code>不是线程(goroutine)安全的。</p>
<p>首先，让我们看一段并发读写的代码,下列程序中一个goroutine一直读，一个goroutine一只写同一个键值，即即使读写的键不相同，而且map也没有&quot;扩容&quot;等操作，代码还是会报错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span>)</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			_ = m<span class="number">[1</span>]</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			m<span class="number">[2</span>] =<span class="number"> 2</span></div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">select</span> {}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>错误信息是: <code>fatal error: concurrent map read and map write</code>。</p>
<p>如果你查看Go的源代码: <a href="https://github.com/golang/go/blob/master/src/runtime/hashmap_fast.go#L118" target="_blank" rel="external">hashmap_fast.go#L118</a>,会看到读的时候会检查<code>hashWriting</code>标志， 如果有这个标志，就会报并发错误。</p>
<p>写的时候会设置这个标志: <a href="https://github.com/golang/go/blob/master/src/runtime/hashmap.go#L542" target="_blank" rel="external">hashmap.go#L542</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">h.flags |= hashWriting</div></pre></td></tr></table></figure>

<p><a href="https://github.com/golang/go/blob/master/src/runtime/hashmap.go#L628" target="_blank" rel="external">hashmap.go#L628</a>设置完之后会取消这个标记。</p>
<p>当然，代码中还有好几处并发读写的检查， 比如写的时候也会检查是不是有并发的写，删除键的时候类似写，遍历的时候并发读写问题等。</p>
<p>有时候，map的并发问题不是那么容易被发现, 你可以利用<code>-race</code>参数来检查。</p>
<h3 id="Go_1-9之前的解决方案">Go 1.9之前的解决方案</h3>
<p>但是，很多时候，我们会并发地使用map对象，尤其是在一定规模的项目中，map总会保存goroutine共享的数据。在Go官方blog的<a href="https://blog.golang.org/go-maps-in-action" target="_blank" rel="external">Go maps in action</a>一文中，提供了一种简便的解决方案。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> counter = <span class="keyword">struct</span>{</div><div class="line">    sync.RWMutex</div><div class="line">    m <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span></div><div class="line">}{m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>)}</div></pre></td></tr></table></figure>

<p>它使用嵌入struct为map增加一个读写锁。</p>
<p>读数据的时候很方便的加锁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">counter.RLock()</div><div class="line">n := counter.m[<span class="string">"some_key"</span>]</div><div class="line">counter.RUnlock()</div><div class="line">fmt.Println(<span class="string">"some_key:"</span>, n)</div></pre></td></tr></table></figure>

<p>写数据的时候:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">counter.Lock()</div><div class="line">counter.m[<span class="string">"some_key"</span>]++</div><div class="line">counter.Unlock()</div></pre></td></tr></table></figure>

<h3 id="sync-Map">sync.Map</h3>
<p>可以说，上面的解决方案相当简洁，并且利用读写锁而不是Mutex可以进一步减少读写的时候因为锁带来的性能。</p>
<p>但是，它在一些场景下也有问题，如果熟悉Java的同学，可以对比一下java的<code>ConcurrentHashMap</code>的实现，在map的数据非常大的情况下，一把锁会导致大并发的客户端共争一把锁，Java的解决方案是<code>shard</code>, 内部使用多个锁，每个区间共享一把锁，这样减少了数据共享一把锁带来的性能影响，<a href="https://github.com/orcaman" target="_blank" rel="external">orcaman</a>提供了这个思路的一个实现： <a href="https://github.com/orcaman/concurrent-map" target="_blank" rel="external">concurrent-map</a>，他也询问了Go相关的开发人员是否在Go中也实现这种<a href="https://github.com/golang/go/issues/20360" target="_blank" rel="external">方案</a>，由于实现的复杂性，答案是<code>Yes, we considered it.</code>,但是除非有特别的性能提升和应用场景，否则没有进一步的开发消息。</p>
<p>那么，在Go 1.9中<code>sync.Map</code>是怎么实现的呢？它是如何解决并发提升性能的呢？</p>
<p><code>sync.Map</code>的实现有几个优化点，这里先列出来，我们后面慢慢分析。</p>
<ol>
<li>空间换时间。 通过冗余的两个数据结构(read、dirty),实现加锁对性能的影响。</li>
<li>使用只读数据(read)，避免读写冲突。</li>
<li>动态调整，miss次数多了之后，将dirty数据提升为read。</li>
<li>double-checking。</li>
<li>延迟删除。 删除一个键值只是打标记，只有在提升dirty的时候才清理删除的数据。</li>
<li>优先从read读取、更新、删除，因为对read的读取不需要锁。</li>
</ol>
<p>下面我们介绍<code>sync.Map</code>的重点代码，以便理解它的实现思想。</p>
<p>首先，我们看一下<code>sync.Map</code>的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> {</div><div class="line">	<span class="comment">// 当涉及到dirty数据的操作的时候，需要使用这个锁</span></div><div class="line">	mu Mutex</div><div class="line"></div><div class="line">	<span class="comment">// 一个只读的数据结构，因为只读，所以不会有读写冲突。</span></div><div class="line">	<span class="comment">// 所以从这个数据中读取总是安全的。</span></div><div class="line">	<span class="comment">// 实际上，实际也会更新这个数据的entries,如果entry是未删除的(unexpunged), 并不需要加锁。如果entry已经被删除了，需要加锁，以便更新dirty数据。</span></div><div class="line">	read atomic.Value <span class="comment">// readOnly</span></div><div class="line"></div><div class="line">	<span class="comment">// dirty数据包含当前的map包含的entries,它包含最新的entries(包括read中未删除的数据,虽有冗余，但是提升dirty字段为read的时候非常快，不用一个一个的复制，而是直接将这个数据结构作为read字段的一部分),有些数据还可能没有移动到read字段中。</span></div><div class="line">	<span class="comment">// 对于dirty的操作需要加锁，因为对它的操作可能会有读写竞争。</span></div><div class="line">	<span class="comment">// 当dirty为空的时候， 比如初始化或者刚提升完，下一次的写操作会复制read字段中未删除的数据到这个数据中。</span></div><div class="line">	dirty <span class="keyword">map</span>[<span class="keyword">interface</span>{}]*entry</div><div class="line"></div><div class="line">	<span class="comment">// 当从Map中读取entry的时候，如果read中不包含这个entry,会尝试从dirty中读取，这个时候会将misses加一，</span></div><div class="line">	<span class="comment">// 当misses累积到 dirty的长度的时候， 就会将dirty提升为read,避免从dirty中miss太多次。因为操作dirty需要加锁。</span></div><div class="line">	misses <span class="typename">int</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>它的数据结构很简单，值包含四个字段：<code>read</code>、<code>mu</code>、<code>dirty</code>、<code>misses</code>。</p>
<p>它使用了冗余的数据结构<code>read</code>、<code>dirty</code>。<code>dirty</code>中会包含<code>read</code>中为删除的entries，新增加的entries会加入到<code>dirty</code>中。</p>
<p><code>read</code>的数据结构是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> {</div><div class="line">	m       <span class="keyword">map</span>[<span class="keyword">interface</span>{}]*entry</div><div class="line">	amended <span class="typename">bool</span> <span class="comment">// 如果Map.dirty有些数据不在中的时候，这个值为true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>amended</code>指明<code>Map.dirty</code>中有<code>readOnly.m</code>未包含的数据，所以如果从<code>Map.read</code>找不到数据的话，还要进一步到<code>Map.dirty</code>中查找。</p>
<p>对Map.read的修改是通过原子操作进行的。</p>
<p>虽然<code>read</code>和<code>dirty</code>有冗余数据，但这些数据是通过指针指向同一个数据，所以尽管Map的value会很大，但是冗余的空间占用还是有限的。</p>
<p><code>readOnly.m</code>和<code>Map.dirty</code>存储的值类型是<code>*entry</code>,它包含一个指针p, 指向用户存储的value值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> {</div><div class="line">	p unsafe.Pointer <span class="comment">// *interface{}</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>p有三种值：</p>
<ul>
<li>nil: entry已被删除了，并且m.dirty为nil</li>
<li>expunged: entry已被删除了，并且m.dirty不为nil，而且这个entry不存在于m.dirty中</li>
<li>其它： entry是一个正常的值</li>
</ul>
<p>以上是<code>sync.Map</code>的数据结构，下面我们重点看看<code>Load</code>、<code>Store</code>、<code>Delete</code>、<code>Range</code>这四个方法，其它辅助方法可以参考这四个方法来理解。</p>
<h4 id="Load">Load</h4>
<p>加载方法，也就是提供一个键<code>key</code>,查找对应的值<code>value</code>,如果不存在，通过<code>ok</code>反映：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Map) Load(key <span class="keyword">interface</span>{}) (value <span class="keyword">interface</span>{}, ok <span class="typename">bool</span>) {</div><div class="line">	<span class="comment">// 1.首先从m.read中得到只读readOnly,从它的map中查找，不需要加锁</span></div><div class="line">	read, _ := m.read.Load().(readOnly)</div><div class="line">	e, ok := read.m[key]</div><div class="line"></div><div class="line">	<span class="comment">// 2. 如果没找到，并且m.dirty中有新数据，需要从m.dirty查找，这个时候需要加锁</span></div><div class="line">	<span class="keyword">if</span> !ok && read.amended {</div><div class="line">		m.mu.Lock()</div><div class="line">		<span class="comment">// 双检查，避免加锁的时候m.dirty提升为m.read,这个时候m.read可能被替换了。</span></div><div class="line">		read, _ = m.read.Load().(readOnly)</div><div class="line">		e, ok = read.m[key]</div><div class="line"></div><div class="line">		<span class="comment">// 如果m.read中还是不存在，并且m.dirty中有新数据</span></div><div class="line">		<span class="keyword">if</span> !ok && read.amended {</div><div class="line">			<span class="comment">// 从m.dirty查找</span></div><div class="line">			e, ok = m.dirty[key]</div><div class="line">			<span class="comment">// 不管m.dirty中存不存在，都将misses计数加一</span></div><div class="line">			<span class="comment">// missLocked()中满足条件后就会提升m.dirty</span></div><div class="line">			m.missLocked()</div><div class="line">		}</div><div class="line">		m.mu.Unlock()</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> !ok {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, <span class="constant">false</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> e.load()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里有两个值的关注的地方。一个是首先从<code>m.read</code>中加载，不存在的情况下，并且<code>m.dirty</code>中有新数据，加锁，然后从<code>m.dirty</code>中加载。</p>
<p>二是这里使用了双检查的处理，因为在下面的两个语句中，这两行语句并不是一个原子操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> !ok && read.amended {</div><div class="line">		m.mu.Lock()</div></pre></td></tr></table></figure>

<p>虽然第一句执行的时候条件满足，但是在加锁之前，<code>m.dirty</code>可能被提升为<code>m.read</code>,所以加锁后还得再检查<code>m.read</code>，后续的方法中都使用了这个方法。</p>
<p>双检查的技术Java程序员非常熟悉了，单例模式的实现之一就是利用双检查的技术。</p>
<p>可以看到，如果我们查询的键值正好存在于<code>m.read</code>中，无须加锁，直接返回，理论上性能优异。即使不存在于<code>m.read</code>中，经过<code>miss</code>几次之后，<code>m.dirty</code>会被提升为<code>m.read</code>，又会从<code>m.read</code>中查找。所以对于更新／增加较少，加载存在的key很多的case,性能基本和无锁的map类似。</p>
<p>下面看看<code>m.dirty</code>是如何被提升的。 <code>missLocked</code>方法中可能会将<code>m.dirty</code>提升。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Map) missLocked() {</div><div class="line">	m.misses++</div><div class="line">	<span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) {</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	m.read.Store(readOnly{m: m.dirty})</div><div class="line">	m.dirty = <span class="constant">nil</span></div><div class="line">	m.misses =<span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的最后三行代码就是提升<code>m.dirty</code>的，很简单的将<code>m.dirty</code>作为<code>readOnly</code>的<code>m</code>字段，原子更新<code>m.read</code>。提升后<code>m.dirty</code>、<code>m.misses</code>重置， 并且<code>m.read.amended</code>为false。</p>
<h4 id="Store">Store</h4>
<p>这个方法是更新或者新增一个entry。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Map) Store(key, value <span class="keyword">interface</span>{}) {</div><div class="line">	<span class="comment">// 如果m.read存在这个键，并且这个entry没有被标记删除，尝试直接存储。</span></div><div class="line">	<span class="comment">// 因为m.dirty也指向这个entry,所以m.dirty也保持最新的entry。</span></div><div class="line">	read, _ := m.read.Load().(readOnly)</div><div class="line">	<span class="keyword">if</span> e, ok := read.m[key]; ok && e.tryStore(&value) {</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 如果`m.read`不存在或者已经被标记删除</span></div><div class="line">	m.mu.Lock()</div><div class="line">	read, _ = m.read.Load().(readOnly)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> e, ok := read.m[key]; ok {</div><div class="line">		<span class="keyword">if</span> e.unexpungeLocked() { <span class="comment">//标记成未被删除</span></div><div class="line">			m.dirty[key] = e <span class="comment">//m.dirty中不存在这个键，所以加入m.dirty</span></div><div class="line">		}</div><div class="line">		e.storeLocked(&value) <span class="comment">//更新</span></div><div class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok { <span class="comment">// m.dirty存在这个键，更新</span></div><div class="line">		e.storeLocked(&value)</div><div class="line">	} <span class="keyword">else</span> { <span class="comment">//新键值</span></div><div class="line">		<span class="keyword">if</span> !read.amended { <span class="comment">//m.dirty中没有新的数据，往m.dirty中增加第一个新键</span></div><div class="line">			m.dirtyLocked() <span class="comment">//从m.read中复制未删除的数据</span></div><div class="line">			m.read.Store(readOnly{m: read.m, amended: <span class="constant">true</span>})</div><div class="line">		}</div><div class="line">		m.dirty[key] = newEntry(value) <span class="comment">//将这个entry加入到m.dirty中</span></div><div class="line">	}</div><div class="line">	m.mu.Unlock()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Map) dirtyLocked() {</div><div class="line">	<span class="keyword">if</span> m.dirty != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	read, _ := m.read.Load().(readOnly)</div><div class="line">	m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>{}]*entry, <span class="built_in">len</span>(read.m))</div><div class="line">	<span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m {</div><div class="line">		<span class="keyword">if</span> !e.tryExpungeLocked() {</div><div class="line">			m.dirty[k] = e</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"><span class="keyword">func</span> (e *entry) tryExpungeLocked() (isExpunged <span class="typename">bool</span>) {</div><div class="line">	p := atomic.LoadPointer(&e.p)</div><div class="line">	<span class="keyword">for</span> p == <span class="constant">nil</span> {</div><div class="line">		<span class="comment">// 将已经删除标记为nil的数据标记为expunged</span></div><div class="line">		<span class="keyword">if</span> atomic.CompareAndSwapPointer(&e.p, <span class="constant">nil</span>, expunged) {</div><div class="line">			<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">		}</div><div class="line">		p = atomic.LoadPointer(&e.p)</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> p == expunged</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你可以看到，以上操作都是先从操作<code>m.read</code>开始的，不满足条件再加锁，然后操作<code>m.dirty</code>。</p>
<p><code>Store</code>可能会在某种情况下(初始化或者m.dirty刚被提升后)从<code>m.read</code>中复制数据，如果这个时候<code>m.read</code>中数据量非常大，可能会影响性能。</p>
<h4 id="Delete">Delete</h4>
<p>删除一个键值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Map) Delete(key <span class="keyword">interface</span>{}) {</div><div class="line">	read, _ := m.read.Load().(readOnly)</div><div class="line">	e, ok := read.m[key]</div><div class="line">	<span class="keyword">if</span> !ok && read.amended {</div><div class="line">		m.mu.Lock()</div><div class="line">		read, _ = m.read.Load().(readOnly)</div><div class="line">		e, ok = read.m[key]</div><div class="line">		<span class="keyword">if</span> !ok && read.amended {</div><div class="line">			<span class="built_in">delete</span>(m.dirty, key)</div><div class="line">		}</div><div class="line">		m.mu.Unlock()</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> ok {</div><div class="line">		e.<span class="built_in">delete</span>()</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>同样，删除操作还是从<code>m.read</code>中开始， 如果这个entry不存在于<code>m.read</code>中，并且<code>m.dirty</code>中有新数据，则加锁尝试从<code>m.dirty</code>中删除。</p>
<p>注意，还是要双检查的。 从<code>m.dirty</code>中直接删除即可，就当它没存在过，但是如果是从<code>m.read</code>中删除，并不会直接删除，而是打标记：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (e *entry) <span class="built_in">delete</span>() (hadValue <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		p := atomic.LoadPointer(&e.p)</div><div class="line">		<span class="comment">// 已标记为删除</span></div><div class="line">		<span class="keyword">if</span> p == <span class="constant">nil</span> || p == expunged {</div><div class="line">			<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">		}</div><div class="line">		<span class="comment">// 原子操作，e.p标记为nil</span></div><div class="line">		<span class="keyword">if</span> atomic.CompareAndSwapPointer(&e.p, p, <span class="constant">nil</span>) {</div><div class="line">			<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="Range">Range</h4>
<p>因为<code>for ... range map</code>是内建的语言特性，所以没有办法使用<code>for range</code>遍历<code>sync.Map</code>, 但是可以使用它的<code>Range</code>方法，通过回调的方式遍历。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Map) Range(f <span class="keyword">func</span>(key, value <span class="keyword">interface</span>{}) <span class="typename">bool</span>) {</div><div class="line">	read, _ := m.read.Load().(readOnly)</div><div class="line"></div><div class="line">	<span class="comment">// 如果m.dirty中有新数据，则提升m.dirty,然后在遍历</span></div><div class="line">	<span class="keyword">if</span> read.amended {</div><div class="line">		<span class="comment">//提升m.dirty</span></div><div class="line">		m.mu.Lock()</div><div class="line">		read, _ = m.read.Load().(readOnly) <span class="comment">//双检查</span></div><div class="line">		<span class="keyword">if</span> read.amended {</div><div class="line">			read = readOnly{m: m.dirty}</div><div class="line">			m.read.Store(read)</div><div class="line">			m.dirty = <span class="constant">nil</span></div><div class="line">			m.misses =<span class="number"> 0</span></div><div class="line">		}</div><div class="line">		m.mu.Unlock()</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 遍历, for range是安全的</span></div><div class="line">	<span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m {</div><div class="line">		v, ok := e.load()</div><div class="line">		<span class="keyword">if</span> !ok {</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> !f(k, v) {</div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Range方法调用前可能会做一个<code>m.dirty</code>的提升，不过提升<code>m.dirty</code>不是一个耗时的操作。</p>
<h3 id="sync-Map的性能">sync.Map的性能</h3>
<p>Go 1.9源代码中提供了性能的测试： <a href="https://github.com/golang/go/blob/master/src/sync/map_bench_test.go" target="_blank" rel="external">map_bench_test.go</a>、<a href="https://github.com/golang/go/blob/master/src/sync/map_reference_test.go" target="_blank" rel="external">map_reference_test.go</a></p>
<p>我也基于这些代码修改了一下，得到下面的测试数据，相比较以前的解决方案，性能多少回有些提升，如果你特别关注性能，可以考虑<code>sync.Map</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">BenchmarkHitAll/*<span class="keyword">sync</span>.RWMutexMap-<span class="number">4</span>   	<span class="number">20000000</span>	        <span class="number">83.8</span> ns/op</div><div class="line">BenchmarkHitAll/*<span class="keyword">sync</span>.Map-<span class="number">4</span>          	<span class="number">30000000</span>	        <span class="number">59.9</span> ns/op</div><div class="line">BenchmarkHitAll_WithoutPrompting/*<span class="keyword">sync</span>.RWMutexMap-<span class="number">4</span>         	<span class="number">20000000</span>	        <span class="number">96.9</span> ns/op</div><div class="line">BenchmarkHitAll_WithoutPrompting/*<span class="keyword">sync</span>.Map-<span class="number">4</span>                	<span class="number">20000000</span>	        <span class="number">64.1</span> ns/op</div><div class="line">BenchmarkHitNone/*<span class="keyword">sync</span>.RWMutexMap-<span class="number">4</span>                         	<span class="number">20000000</span>	        <span class="number">79.1</span> ns/op</div><div class="line">BenchmarkHitNone/*<span class="keyword">sync</span>.Map-<span class="number">4</span>                                	<span class="number">30000000</span>	        <span class="number">43.3</span> ns/op</div><div class="line">BenchmarkHit_WithoutPrompting/*<span class="keyword">sync</span>.RWMutexMap-<span class="number">4</span>            	<span class="number">20000000</span>	        <span class="number">81.5</span> ns/op</div><div class="line">BenchmarkHit_WithoutPrompting/*<span class="keyword">sync</span>.Map-<span class="number">4</span>                   	<span class="number">30000000</span>	        <span class="number">44.0</span> ns/op</div><div class="line">BenchmarkUpdate/*<span class="keyword">sync</span>.RWMutexMap-<span class="number">4</span>                          	 <span class="number">5000000</span>	       <span class="number">328</span> ns/op</div><div class="line">BenchmarkUpdate/*<span class="keyword">sync</span>.Map-<span class="number">4</span>                                 	<span class="number">10000000</span>	       <span class="number">146</span> ns/op</div><div class="line">BenchmarkUpdate_WithoutPrompting/*<span class="keyword">sync</span>.RWMutexMap-<span class="number">4</span>         	 <span class="number">5000000</span>	       <span class="number">336</span> ns/op</div><div class="line">BenchmarkUpdate_WithoutPrompting/*<span class="keyword">sync</span>.Map-<span class="number">4</span>                	 <span class="number">5000000</span>	       <span class="number">324</span> ns/op</div><div class="line">BenchmarkDelete/*<span class="keyword">sync</span>.RWMutexMap-<span class="number">4</span>                          	<span class="number">10000000</span>	       <span class="number">155</span> ns/op</div><div class="line">BenchmarkDelete/*<span class="keyword">sync</span>.Map-<span class="number">4</span>                                 	<span class="number">30000000</span>	        <span class="number">55.0</span> ns/op</div><div class="line">BenchmarkDelete_WithoutPrompting/*<span class="keyword">sync</span>.RWMutexMap-<span class="number">4</span>         	<span class="number">10000000</span>	       <span class="number">173</span> ns/op</div><div class="line">BenchmarkDelete_WithoutPrompting/*<span class="keyword">sync</span>.Map-<span class="number">4</span>                	<span class="number">10000000</span>	       <span class="number">147</span> ns/op</div></pre></td></tr></table></figure>

<h3 id="其它">其它</h3>
<p><code>sync.Map</code>没有<code>Len</code>方法，并且目前没有迹象要加上 (<a href="https://github.com/golang/go/issues/20680" target="_blank" rel="external">issue#20680</a>),所以如果想得到当前Map中有效的entries的数量，需要使用<code>Range</code>方法遍历一次， 比较X疼。</p>
<p><code>LoadOrStore</code>方法如果提供的key存在，则返回已存在的值(Load)，否则保存提供的键值(Store)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Go 1.6之前， 内置的map类型是部分goroutine安全的，并发的读没有问题，并发的写可能有问题。自go 1.6之后， 并发地读写map会报错，这在一些知名的开源库中都存在这个问题，所以go 1.9之前的解决方案是额外绑定一个锁，封装成一个新的struct或者单独使用锁都可以。</p>
<p>本文带你深入到<code>sync.Map</code>的具体实现中，看看为了增加一个功能，代码是如何变的复杂的,以及作者在实现<code>sync.Map</code>的一些思想。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac OS X显示连接]]></title>
    <link href="http://colobu.com/2017/07/11/show-connections-in-MACOS/"/>
    <id>http://colobu.com/2017/07/11/show-connections-in-MACOS/</id>
    <published>2017-07-11T07:23:34.000Z</published>
    <updated>2017-07-11T07:34:31.000Z</updated>
    <content type="html"><![CDATA[<p>Mac OSX中虽然带了 <code>netstat</code>工具，可是用起来不像Linux下那么爽， 一个是慢 (<code>netstat -p tcp | grep $PORT</code>)，二是不能pid，所以<a href="https://stackoverflow.com/questions/4421633/who-is-listening-on-a-given-tcp-port-on-mac-os-x" target="_blank" rel="external">stackoverflow</a>上建议使用<code>lsof</code>工具。</p>
<p>所以你可以使用下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lsof -n -i4TCP:<span class="variable">$PORT</span> | grep LISTEN <span class="comment"># Verified on macOS Sierra</span></div><div class="line">lsof -n -iTCP:<span class="variable">$PORT</span> | grep LISTEN</div><div class="line">lsof -n -i:<span class="variable">$PORT</span> | grep LISTEN</div></pre></td></tr></table></figure>

<p>为了不显示端口的俗称，你可以加<code>P</code>参数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lsof -nP -i4TCP:<span class="variable">$PORT</span> | <span class="keyword">grep</span> LISTEN <span class="comment"># Verified on macOS Sierra</span></div><div class="line">lsof -nP -iTCP:<span class="variable">$PORT</span> | <span class="keyword">grep</span> LISTEN</div><div class="line">lsof -nP -i:<span class="variable">$PORT</span> | <span class="keyword">grep</span> LISTEN</div></pre></td></tr></table></figure>

<p>如果不想<code>grep Listen</code>,可以加<code>-sTCP:LISTEN</code>。</p>
<p>没有更多要说的了，谨记一下备用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Mac OSX中虽然带了 <code>netstat</code>工具，可是用起来不像Linux下那么爽， 一个是慢 (<code>netstat -p tcp | grep $PORT</code>)，二是不能pid，所以<a href="https://stackove]]>
    </summary>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go语言中 select 和 switch 的比较]]></title>
    <link href="http://colobu.com/2017/07/07/select-vs-switch-in-golang/"/>
    <id>http://colobu.com/2017/07/07/select-vs-switch-in-golang/</id>
    <published>2017-07-07T11:31:10.000Z</published>
    <updated>2017-07-07T11:48:08.000Z</updated>
    <content type="html"><![CDATA[<p><code>select</code> 和 <code>switch</code> 是 Go语言中进行分支操作的两个方式，各有各的应用场景。</p>
<a id="more"></a>
<h3 id="select">select</h3>
<p><code>select</code>只能应用于channel的操作，既可以用于channel的数据接收，也可以用于channel的数据发送。</p>
<p>如果<code>select</code>的多个分支都满足条件，则会随机的选取其中一个满足条件的分支， 如语言规范中所说：</p>
<blockquote>
<p>If multiple cases can proceed, a uniform pseudo-random choice is made to decide which single communication will execute.</p>
</blockquote>
<p>｀case｀语句的表达式可以为一个变量或者两个变量赋值。</p>
<p>有<code>default</code>语句。</p>
<p>下面的代码是 <a href="https://gobyexample.com/select" target="_blank" rel="external">go by example 上的例子</a>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"time"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line"></div><div class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">string</span>)</div><div class="line">    c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">string</span>)</div><div class="line"></div><div class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">        time.Sleep(time.Second *<span class="number"> 1</span>)</div><div class="line">        c1 &lt;- <span class="string">"one"</span></div><div class="line">    }()</div><div class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">        time.Sleep(time.Second *<span class="number"> 2</span>)</div><div class="line">        c2 &lt;- <span class="string">"two"</span></div><div class="line">    }()</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 2</span>; i++ {</div><div class="line">        <span class="keyword">select</span> {</div><div class="line">        <span class="keyword">case</span> msg1 := &lt;-c1:</div><div class="line">            fmt.Println(<span class="string">"received"</span>, msg1)</div><div class="line">        <span class="keyword">case</span> msg2 := &lt;-c2:</div><div class="line">            fmt.Println(<span class="string">"received"</span>, msg2)</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="switch">switch</h3>
<p><code>switch</code>可以为各种类型进行分支操作， 设置可以为接口类型进行分支判断(通过i.(type))。</p>
<p><code>switch</code> 分支是顺序执行的，这和<code>select</code>不同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"time"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line"></div><div class="line">    i :=<span class="number"> 2</span></div><div class="line">    fmt.Print(<span class="string">"Write "</span>, i, <span class="string">" as "</span>)</div><div class="line">    <span class="keyword">switch</span> i {</div><div class="line">    <span class="keyword">case</span><span class="number"> 1</span>:</div><div class="line">        fmt.Println(<span class="string">"one"</span>)</div><div class="line">    <span class="keyword">case</span><span class="number"> 2</span>:</div><div class="line">        fmt.Println(<span class="string">"two"</span>)</div><div class="line">    <span class="keyword">case</span><span class="number"> 3</span>:</div><div class="line">        fmt.Println(<span class="string">"three"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> time.Now().Weekday() {</div><div class="line">    <span class="keyword">case</span> time.Saturday, time.Sunday:</div><div class="line">        fmt.Println(<span class="string">"It's the weekend"</span>)</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        fmt.Println(<span class="string">"It's a weekday"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    t := time.Now()</div><div class="line">    <span class="keyword">switch</span> {</div><div class="line">    <span class="keyword">case</span> t.Hour() &lt;<span class="number"> 12</span>:</div><div class="line">        fmt.Println(<span class="string">"It's before noon"</span>)</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        fmt.Println(<span class="string">"It's after noon"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    whatAmI := <span class="keyword">func</span>(i <span class="keyword">interface</span>{}) {</div><div class="line">        <span class="keyword">switch</span> t := i.(<span class="keyword">type</span>) {</div><div class="line">        <span class="keyword">case</span> <span class="typename">bool</span>:</div><div class="line">            fmt.Println(<span class="string">"I'm a bool"</span>)</div><div class="line">        <span class="keyword">case</span> <span class="typename">int</span>:</div><div class="line">            fmt.Println(<span class="string">"I'm an int"</span>)</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            fmt.Printf(<span class="string">"Don't know type %T\n"</span>, t)</div><div class="line">        }</div><div class="line">    }</div><div class="line">    whatAmI(<span class="constant">true</span>)</div><div class="line">    whatAmI<span class="number">(1</span>)</div><div class="line">    whatAmI(<span class="string">"hey"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p><code>select</code> 和 <code>switch</code> 是 Go语言中进行分支操作的两个方式，各有各的应用场景。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]golang concurrency tricks]]></title>
    <link href="http://colobu.com/2017/07/07/golang-concurrency-tricks/"/>
    <id>http://colobu.com/2017/07/07/golang-concurrency-tricks/</id>
    <published>2017-07-07T10:58:21.000Z</published>
    <updated>2017-07-07T11:27:40.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址: <a href="https://udhos.github.io/golang-concurrency-tricks/" target="_blank" rel="external">Golang Concurrency Tricks</a></p>
<p>Golang concurrency model based on goroutines and channels is not free from sharp edges.</p>
<p>This page intends both (1) to collect helpful guidelines for writing concurrent code in Go and (2) to bring up well known potential issues to attention.</p>
<a id="more"></a>
<h2 id="Channel_Hints">Channel Hints</h2>
<ul>
<li><p>C1. Some channel operations cause runtime panic:</p>
<ul>
<li>P1. Closing the nil channel.</li>
<li>P2. Closing a closed channel.</li>
<li>P3. Sending on a closed channel.</li>
</ul>
</li>
<li><p>C2. Do not close a channel from a receiver goroutine. Closing the channel from a receiver could make future sender goroutines to panic.</p>
</li>
<li><p>C3. If a channel has multiple senders, do not close the channel from a sender goroutine. Closing the channel from a sender could make future sender goroutine to panic.</p>
</li>
</ul>
<p>Alternatively, coordinate senders so that only the last sender to leave closes the channel (for instance by using either atomic int or sync.WaitGroup)</p>
<p>Last one sender to leave, turns off the lights, which can be controlled by a atomic int.<br><a href="https://groups.google.com/d/msg/golang-nuts/LM648yrPpck/oZFSD-oMAwAJ" target="_blank" rel="external">https://groups.google.com/d/msg/golang-nuts/LM648yrPpck/oZFSD-oMAwAJ</a></p>
<ul>
<li>C4. It is not required to close an unused channel. If no goroutine is left referencing the channel, it will be garbage collected.</li>
</ul>
<p>Note that it is only necessary to close a channel if the receiver is looking for a close. Closing the channel is a control signal on the channel indicating that no more data follows.<br><a href="https://groups.google.com/forum/#!msg/golang-nuts/pZwdYRGxCIk/qpbHxRRPJdUJ" target="_blank" rel="external">https://groups.google.com/forum/#!msg/golang-nuts/pZwdYRGxCIk/qpbHxRRPJdUJ</a></p>
<ul>
<li>C5. Channels work well when enclosed in a &#39;select&#39;.</li>
</ul>
<p>If you are ever using a channel outside of a select in production code, you are probably doing it wrong.<br><a href="https://groups.google.com/d/msg/golang-nuts/LM648yrPpck/j5eHsPc2AwAJ" target="_blank" rel="external">https://groups.google.com/d/msg/golang-nuts/LM648yrPpck/j5eHsPc2AwAJ</a></p>
<ul>
<li><p>C6. If you need bidirectional communication between two goroutines, consider using two unidirectional channels. Thus both channel sides will be able to use the close idiom to signal termination.</p>
</li>
<li><p>C7. Beware: one sender goroutine risks blocking indefinitely when writing on a channel if there is no goroutine left receiving from it.</p>
</li>
<li><p>C8. When designing a goroutine which provides service through channels, and at some point a running goroutine is no longer needed, consider exactly how it will finish. Otherwise, unused goroutines may leak idly servicing an unattended channel.</p>
</li>
<li><p>C9. Keep Dave Cheney&#39;s Four Channel Axioms in mind:</p>
<ul>
<li>A1. A send to a nil channel blocks forever.</li>
<li>A2. A receive from a nil channel blocks forever. (Why? Here is why. Example.)</li>
<li>A3. A send to a closed channel panics.</li>
<li>A4. A receive from a closed channel returns the zero value immediately.</li>
</ul>
</li>
<li><p>C10. &#39;select&#39; never selects a blocking case.</p>
</li>
</ul>
<h2 id="Goroutine_Hints">Goroutine Hints</h2>
<ul>
<li>G1. Only one goroutine accessing a piece of data is good practice.</li>
</ul>
<p>In particular, consider structuring your program so that only one goroutine at a time is ever responsible for a particular piece of data.<br><a href="https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes" target="_blank" rel="external">https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes</a></p>
<ul>
<li>G2. runtime.Goexit() terminates the goroutine that calls it.</li>
</ul>
<h2 id="See_also:">See also:</h2>
<p><a href="http://www.slideshare.net/cloudflare/a-channel-compendium" target="_blank" rel="external">http://www.slideshare.net/cloudflare/a-channel-compendium</a><br><a href="https://github.com/golang/go/wiki/LearnConcurrency" target="_blank" rel="external">https://github.com/golang/go/wiki/LearnConcurrency</a><br><a href="http://dave.cheney.net/2014/03/19/channel-axioms" target="_blank" rel="external">http://dave.cheney.net/2014/03/19/channel-axioms</a></p>
<hr>
<p>Repository: git clone <a href="https://github.com/udhos/golang-concurrency-tricks.git" target="_blank" rel="external">https://github.com/udhos/golang-concurrency-tricks.git</a><br>Web URL: <a href="http://udhos.github.io/golang-concurrency-tricks" target="_blank" rel="external">http://udhos.github.io/golang-concurrency-tricks</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文地址: <a href="https://udhos.github.io/golang-concurrency-tricks/" target="_blank" rel="external">Golang Concurrency Tricks</a></p>
<p>Golang concurrency model based on goroutines and channels is not free from sharp edges.</p>
<p>This page intends both (1) to collect helpful guidelines for writing concurrent code in Go and (2) to bring up well known potential issues to attention.</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]参考资料: 地道的GO代码]]></title>
    <link href="http://colobu.com/2017/06/30/idiomatic-go-references/"/>
    <id>http://colobu.com/2017/06/30/idiomatic-go-references/</id>
    <published>2017-06-30T02:41:52.000Z</published>
    <updated>2017-07-06T11:13:09.000Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://pocketgophers.com/idiomatic-go/" target="_blank" rel="external">Idiomatic Go</a></p>
<p>什么样的代码才算最地道的Go代码？ 这个问题经常被人问起，但是确不太好回答。部分原因在于我们还在摸索之中，抑或Go还是一个年轻的语言。随着语言和社区的逐渐成熟，老司机们才会对地道的Go代码达成共识。</p>
<p>请注意，地道的代码不是限制你的规则，而是代码指导。工作正常的代码比地道的代码更重要。因为所谓的地道,只是大家达成的一种共识，所以&quot;不地道&quot;的的代码不一定代表着错误。</p>
<p>既然没有确定的答案，我在本文中收集了相关的参考资料, 以飨读者。</p>
<a id="more"></a>
<h3 id="Accept_interfaces,_return_concrete_types"><a href="http://idiomaticgo.com/post/best-practice/accept-interfaces-return-structs/" target="_blank" rel="external">Accept interfaces, return concrete types</a></h3>
<p><strong>Craig Brookes 2016-11-02</strong></p>
<p>解释什么是地道的代码， 为什么你要遵循它。</p>
<h3 id="Code_Review_Comments"><a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="external">Code Review Comments</a></h3>
<p>在Code review的时候一套通用的指导， 简短几句话介绍编写代码的地道的方式。 Go官方出品。</p>
<h3 id="Effective_Go"><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="external">Effective Go</a></h3>
<p>Go开发组提供了编写清晰、地道的Go代码的小窍门。这是Go程序员必读的参考文档， 不止有地道的代码指导，而且还有Go各种特性的背后的考量。</p>
<h3 id="Go_Patterns"><a href="http://tmrts.com/go-patterns/" target="_blank" rel="external">Go Patterns</a></h3>
<p><strong>Tamer Tas</strong></p>
<p>关于Go语言的设计模式和应用程序模式的集合。</p>
<h3 id="Go_Proverbs"><a href="https://go-proverbs.github.io/" target="_blank" rel="external">Go Proverbs</a></h3>
<p>Rob Pike收集的简单、富有诗意的精辟语录， 解释Go语言深层次的哲学、以更容易理解方式。真正理解并应用它们会让你成为Go大牛。</p>
<h3 id="Go_and_the_Zen_of_Python"><a href="https://talks.golang.org/2012/zen.slide" target="_blank" rel="external">Go and the Zen of Python</a></h3>
<p><strong>Andrew Gerrand</strong></p>
<p>比较 Python 和 Go 之禅意。</p>
<h3 id="Go_by_Example"><a href="https://gobyexample.com/" target="_blank" rel="external">Go by Example</a></h3>
<p>使用带注解的例子教授Go， 会讨论什么样的代码才是地道的代码。</p>
<h3 id="Idiomatic_Doc_Comments:_Document_Your_Function,_Not_Your_Function_Signature"><a href="http://whipperstacker.com/2015/10/14/idiomatic-doc-comments-document-your-function-not-your-function-signature/" target="_blank" rel="external">Idiomatic Doc Comments: Document Your Function, Not Your Function Signature</a></h3>
<p><strong>Katrina Owen 2015-10-14</strong></p>
<p>通过示例解释如何为Go函数编写有帮助的注释。</p>
<h3 id="Idiomatic_Go"><a href="https://dmitri.shuralyov.com/idiomatic-go" target="_blank" rel="external">Idiomatic Go</a></h3>
<p><strong>Dmitri Shuralyov</strong></p>
<p>对<a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="external">Code Review Comments</a>的补充，通过令人信服理由和参考文献， 列举了地道的Go代码指导。</p>
<h3 id="Idiomatic_Go_Readability"><a href="https://medium.com/@haya14busa/idiomatic-go-readability-f0b42ef381dc" target="_blank" rel="external">Idiomatic Go Readability</a></h3>
<p>haya14busa</p>
<p>地道的可读性的Go代码的实践经验和窍门， 包括自动和手动方式。</p>
<h3 id="Idiomatic_Go_Tests"><a href="http://idiomaticgo.com/post/testing/idiomatic-go-tests/" target="_blank" rel="external">Idiomatic Go Tests</a></h3>
<p><strong>Craig Brookes</strong></p>
<p>作者通过例子解释地道的Go测试应该怎么做。</p>
<h3 id="Idiomatic_Go_Trickshttps://medium-com/@matryer/idiomatic-go-tricks-62abea5c50fb"><a href="">Idiomatic Go Tricks</a><a href="https://medium.com/@matryer/idiomatic-go-tricks-62abea5c50fb" target="_blank" rel="external">https://medium.com/@matryer/idiomatic-go-tricks-62abea5c50fb</a></h3>
<p><strong>Mat Ryer video slides 2016-08-18</strong></p>
<p>一些技巧和窍门让你像个老司机一样谈论Go。</p>
<h3 id="Itty_Bitty_Go_Idiom:_If_Without_Else"><a href="http://whipperstacker.com/2015/10/16/itty-bitty-go-idiom-if-without-else/" target="_blank" rel="external">Itty Bitty Go Idiom: If Without Else</a></h3>
<p><strong>Katrina Owen 2015-10-16</strong></p>
<p>为什么你通常看到的Go代码中<code>if</code>语句没有<code>else</code>分支， 这篇文章解释了这个问题。</p>
<h3 id="Things_I_learned_teaching_Go"><a href="https://youtu.be/B-r3Wf_I2Lk" target="_blank" rel="external">Things I learned teaching Go</a></h3>
<p><strong>Francesc Campoy Flores 2014-10-10</strong></p>
<blockquote>
<p>It&#39;s better because it&#39;s what other people in the community expect.</p>
</blockquote>
<p>通过教学总结的经验。</p>
<h3 id="What_is_idiomatic_Go?"><a href="https://www.reddit.com/r/golang/comments/5b2j38/what_is_idiomatic_go/" target="_blank" rel="external">What is idiomatic Go?</a></h3>
<p>这是reddit是的一篇讨论，对一个代码库的中的非地道Go代码的抨击。评论显示这些地道代码指导对社区的帮助和伤害。</p>
<h3 id="When_in_Go,_do_as_Gophers_do"><a href="https://talks.golang.org/2014/readability.slide" target="_blank" rel="external">When in Go, do as Gophers do</a></h3>
<p><strong>Fumitoshi Ukai 2014-11-30</strong></p>
<p>通过Review对Go项目代码的提交学到的一些地道的编写Go代码的方式。作者作为 Go Readability Approver,一年中review大约200左右的 CL， 在本文中总结了他所学到的。</p>
<p>一旦我发现了更多的参考资料，我会更新这篇文章， 所以记得收藏本文。</p>
<p><em>当然作为译者，我也会补充更多的参考资料，如果你发现了一些关于这方面的参考资料，记得在评论中贴出来哦。</em></p>
<h3 id="50_Shades_of_Go:_Traps,_Gotchas,_and_Common_Mistakes_for_New_Golang_Devs"><a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/" target="_blank" rel="external">50 Shades of Go: Traps, Gotchas, and Common Mistakes for New Golang Devs</a></h3>
<p><strong>Kyle Quest</strong></p>
<p><a href="http://colobu.com/2015/09/07/gotchas-and-common-mistakes-in-go-golang/" target="_blank" rel="external">Go的50度灰：Golang新开发者要注意的陷阱和常见错误</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://pocketgophers.com/idiomatic-go/" target="_blank" rel="external">Idiomatic Go</a></p>
<p>什么样的代码才算最地道的Go代码？ 这个问题经常被人问起，但是确不太好回答。部分原因在于我们还在摸索之中，抑或Go还是一个年轻的语言。随着语言和社区的逐渐成熟，老司机们才会对地道的Go代码达成共识。</p>
<p>请注意，地道的代码不是限制你的规则，而是代码指导。工作正常的代码比地道的代码更重要。因为所谓的地道,只是大家达成的一种共识，所以&quot;不地道&quot;的的代码不一定代表着错误。</p>
<p>既然没有确定的答案，我在本文中收集了相关的参考资料, 以飨读者。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Nginx内部自动处理3XX跳转]]></title>
    <link href="http://colobu.com/2017/06/29/How-to-follow-HTTP-redirects-inside-nginx/"/>
    <id>http://colobu.com/2017/06/29/How-to-follow-HTTP-redirects-inside-nginx/</id>
    <published>2017-06-29T05:57:51.000Z</published>
    <updated>2017-06-30T07:31:38.000Z</updated>
    <content type="html"><![CDATA[<p>利用Nginx很容易的配置反向代理和负载均衡的服务, 比如下面的配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">upstream backends {</div><div class="line">      server <span class="number">10.0</span>.<span class="number">0.10</span>:<span class="number">8080</span>;</div><div class="line">      server <span class="number">10.0</span>.<span class="number">0.11</span>:<span class="number">8080</span>;</div><div class="line">      server <span class="number">10.0</span>.<span class="number">0.12</span>:<span class="number">8080</span>;</div><div class="line">}</div><div class="line"></div><div class="line">server{ </div><div class="line">    listen <span class="number">8080</span>; </div><div class="line">    location / { </div><div class="line">        proxy_pass         http://backends; </div><div class="line">        proxy_<span class="keyword">set</span>_header   Host             <span class="variable">$host</span>; </div><div class="line">        proxy_<span class="keyword">set</span>_header   X-Real-IP        <span class="variable">$remote_addr</span>; </div><div class="line">        proxy_<span class="keyword">set</span>_header   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>; </div><div class="line">    } </div><div class="line">}</div></pre></td></tr></table></figure>

<p>它将客户端的请求转发给后台的三个服务器。 负载均衡的算法又多种， 比如轮询、least_conn、ip_hash、weight等算法，本文重点不介绍这方面的内容，而是下面的需求。</p>
<p>后端服务器可能返回 3XX的redirect的response, Nginx会把这个请求直接返回给客户端。现在我们的需求是让Nginx自己处理这个跳转，而客户端无感知。</p>
<a id="more"></a>
<p>经过查找，找到一种解决方案， 如 <a href="https://serverfault.com/questions/423265/how-to-follow-http-redirects-inside-nginx" target="_blank" rel="external">serverfault</a>提到的，我们可以利用<code>error_page</code>指令将3xx转发给另外的location, 利用<code>$upstream_http_location</code>获得转发的地址：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">upstream backends {</div><div class="line">      server <span class="number">10.0</span>.<span class="number">0.10</span>:<span class="number">8080</span>;</div><div class="line">      server <span class="number">10.0</span>.<span class="number">0.11</span>:<span class="number">8080</span>;</div><div class="line">      server <span class="number">10.0</span>.<span class="number">0.12</span>:<span class="number">8080</span>;</div><div class="line">}</div><div class="line"></div><div class="line">server{ </div><div class="line">    listen <span class="number">8080</span>; </div><div class="line">    location / { </div><div class="line">        proxy_pass         http://backends; </div><div class="line">        proxy_<span class="keyword">set</span>_header   Host             <span class="variable">$host</span>; </div><div class="line">        proxy_<span class="keyword">set</span>_header   X-Real-IP        <span class="variable">$remote_addr</span>; </div><div class="line">        proxy_<span class="keyword">set</span>_header   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>; </div><div class="line"></div><div class="line">        proxy_intercept_errors on;</div><div class="line">        error_page <span class="number">301</span> <span class="number">302</span> <span class="number">307</span> = @handle_redirect;</div><div class="line">    } </div><div class="line"></div><div class="line">    location @handle_redirect {</div><div class="line">            <span class="keyword">set</span> <span class="variable">$saved_redirect_location</span> <span class="string">'$upstream_http_location'</span>;</div><div class="line">            proxy_pass <span class="variable">$saved_redirect_location</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>挺巧妙的一个解决方案。</p>
<p>另一个解决方案是 <a href="https://stackoverflow.com/questions/20254456/intercepting-backend-301-302-redirects-proxy-pass-and-rewriting-to-another-loc" target="_blank" rel="external">stackoverflow</a>提到的, 返回给客户端的时候， 利用<code>proxy_redirect</code>指令修改Location的头，让client端重定向到Nginx特定的地址，Nginx再将请求转发给后端服务器。， 不过这个方案要求客户端支持重定向的能力。</p>
<h5 id="参考文档">参考文档</h5>
<ol>
<li><a href="https://serverfault.com/questions/423265/how-to-follow-http-redirects-inside-nginx" target="_blank" rel="external">https://serverfault.com/questions/423265/how-to-follow-http-redirects-inside-nginx</a></li>
<li><a href="https://stackoverflow.com/questions/20254456/intercepting-backend-301-302-redirects-proxy-pass-and-rewriting-to-another-loc" target="_blank" rel="external">https://stackoverflow.com/questions/20254456/intercepting-backend-301-302-redirects-proxy-pass-and-rewriting-to-another-loc</a></li>
<li><a href="https://stackoverflow.com/questions/42134258/follow-redirect-301-and-proxy-pass-last-location-found-with-nginx" target="_blank" rel="external">https://stackoverflow.com/questions/42134258/follow-redirect-301-and-proxy-pass-last-location-found-with-nginx</a></li>
<li><a href="https://gist.github.com/sirsquidness/710bc76d7bbc734c7a3ff69c6b8ff591" target="_blank" rel="external">https://gist.github.com/sirsquidness/710bc76d7bbc734c7a3ff69c6b8ff591</a></li>
<li><a href="http://www.jianshu.com/p/ac8956f79206" target="_blank" rel="external">http://www.jianshu.com/p/ac8956f79206</a></li>
<li><a href="https://github.com/moonbingbing/openresty-best-practices/blob/master/ngx/reverse_proxy.md" target="_blank" rel="external">https://github.com/moonbingbing/openresty-best-practices/blob/master/ngx/reverse_proxy.md</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>利用Nginx很容易的配置反向代理和负载均衡的服务, 比如下面的配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">upstream backends {</div><div class="line">      server <span class="number">10.0</span>.<span class="number">0.10</span>:<span class="number">8080</span>;</div><div class="line">      server <span class="number">10.0</span>.<span class="number">0.11</span>:<span class="number">8080</span>;</div><div class="line">      server <span class="number">10.0</span>.<span class="number">0.12</span>:<span class="number">8080</span>;</div><div class="line">}</div><div class="line"></div><div class="line">server{ </div><div class="line">    listen <span class="number">8080</span>; </div><div class="line">    location / { </div><div class="line">        proxy_pass         http://backends; </div><div class="line">        proxy_<span class="keyword">set</span>_header   Host             <span class="variable">$host</span>; </div><div class="line">        proxy_<span class="keyword">set</span>_header   X-Real-IP        <span class="variable">$remote_addr</span>; </div><div class="line">        proxy_<span class="keyword">set</span>_header   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>; </div><div class="line">    } </div><div class="line">}</div></pre></td></tr></table></figure>

<p>它将客户端的请求转发给后台的三个服务器。 负载均衡的算法又多种， 比如轮询、least_conn、ip_hash、weight等算法，本文重点不介绍这方面的内容，而是下面的需求。</p>
<p>后端服务器可能返回 3XX的redirect的response, Nginx会把这个请求直接返回给客户端。现在我们的需求是让Nginx自己处理这个跳转，而客户端无感知。</p>
]]>
    
    </summary>
    
      <category term="Nginx" scheme="http://colobu.com/tags/Nginx/"/>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]像牛人一样改进你的Go代码]]></title>
    <link href="http://colobu.com/2017/06/27/Lint-your-golang-code-like-a-mad-man/"/>
    <id>http://colobu.com/2017/06/27/Lint-your-golang-code-like-a-mad-man/</id>
    <published>2017-06-27T11:04:33.000Z</published>
    <updated>2017-06-27T11:41:58.000Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://medium.com/@arshamshirvani/lint-your-golang-code-like-a-pro-668dc6637b39" target="_blank" rel="external">Lint your #golang code like a mad man!</a>, 作者: <a href="https://medium.com/@arshamshirvani?source=post_header_lockup" target="_blank" rel="external">Arsham Shirvani</a></p>
<p>我使用下面的工具来改进我的代码，除了<code>vendor</code>文件夹。我的操作系统是<code>GNU/Linux</code>,但是稍微修改一下脚本应该也能运行在你的操作系统上。我使用<a href="https://github.com/Masterminds/glide" target="_blank" rel="external">glide</a>来处理依赖(vendor),但你也可以使用你的包依赖管理工具来替换<code>glide nv</code>， 这个命令列出了所有的文件夹，除了vender (译者按： Go 1.9中可以直接使用<code>./...</code>，它会排除vendor文件夹)。有些情况下<code>glide nv</code>不适合，所以我使用了它的老式风格。</p>
<p>注意我使用<code>$</code>作为shell的提示符。</p>
<a id="more"></a>
<h3 id="gofmt">gofmt</h3>
<p>Go安装程序中自带了<code>gofmt</code>工具，可以使用它来格式化代码，保持一致的代码风格：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ find . -name <span class="string">"*.go"</span> -not -path <span class="string">"./vendor/*"</span> -not -path <span class="string">".git/*"</span> | xargs gofmt <span class="operator">-s</span> <span class="operator">-d</span></div></pre></td></tr></table></figure>

<h3 id="gocyclo">gocyclo</h3>
<p>gocyclo 用来检查函数的复杂度。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get -u github.com/fzipp/gocyclo</div></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gocyclo -over <span class="number">12</span> $(ls <span class="operator">-d</span> */ | grep -v vendor)</div></pre></td></tr></table></figure>

<p>上面的命令列出了所有复杂度大于12的函数。你还可以提出最复杂的几个：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gocyclo -top <span class="number">10</span> $(ls <span class="operator">-d</span> */ | grep -v vendor)</div></pre></td></tr></table></figure>

<h3 id="interfacer">interfacer</h3>
<p>interfacer 是一个有趣的工具，依照作者所说：</p>
<blockquote>
<p>这个工具提供接口类型的建议，换句话说，它会对可以本没有必要定义成具体的类型的代码提出警告</p>
</blockquote>
<p>安装:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get -u github.com/mvdan/interfacer/cmd/interfacer</div></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ interfacer $(glide nv)</div></pre></td></tr></table></figure>

<p>译者按：看官方的例子就明白这个工具的作用了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> ProcessInput(f *os.File) error {</div><div class="line">        b, err := ioutil.ReadAll(f)</div><div class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">                <span class="keyword">return</span> err</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> processBytes(b)</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ interfacer $(go list ./... | grep -v /vendor/)</div><div class="line">foo.go:<span class="number">10</span>:<span class="number">19</span>: f can be io.Reader</div></pre></td></tr></table></figure>

<h3 id="deadcode">deadcode</h3>
<p>deadcode会告诉你哪些代码片段根本没用。</p>
<p>安装:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get -u github.com/tsenart/deadcode</div></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">find</span> . -<span class="built_in">type</span> <span class="keyword">d</span> -not -path <span class="string">"./vendor/*"</span> | xargs deadcode</div></pre></td></tr></table></figure>

<h3 id="gotype">gotype</h3>
<p>gotype会对go文件和包进行语义(semantic)和句法(syntactic)的分析,这是google提供的一个工具。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get -u golang.org/x/tools/cmd/gotype</div></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ find . -name <span class="string">"*.go"</span> -not -path <span class="string">"./vendor/*"</span> -not -path <span class="string">".git/*"</span> -print0 | xargs -<span class="number">0</span> gotype <span class="operator">-a</span></div></pre></td></tr></table></figure>

<h3 id="misspell">misspell</h3>
<p>misspell用来拼写检查，对国内英语不太熟练的同学很有帮助。</p>
<p>安装:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get -u github.com/client9/misspell</div></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ find . -type f -not -path <span class="string">"./vendor/*"</span> -print0 | xargs -<span class="number">0</span> misspell</div></pre></td></tr></table></figure>

<h3 id="staticcheck">staticcheck</h3>
<p>staticcheck是一个超牛的工具，提供了巨多的静态检查，就像 C#生态圈的 ReSharper 一样。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get -u honnef.co/go/staticcheck/cmd/staticcheck</div></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ staticcheck $(glide nv)</div></pre></td></tr></table></figure>

<h3 id="gosimple">gosimple</h3>
<p>gosimple 提供信息，帮助你了解哪些代码可以简化。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get -u honnef.co/go/simple/cmd/gosimple</div></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gosimple $(glide nv)</div></pre></td></tr></table></figure>

<p>译者按： 事实上这个工具和上面的staticcheck工具已经合并为同一个项目了：<a href="https://github.com/dominikh/go-tools" target="_blank" rel="external">go-tools</a>，这个项目提供了非常好的工具， 还包括 <code>structlayout-optimize</code>、<code>unused</code>、<code>rdeps</code>、<code>keyify</code>等，值的你去探索。</p>
<h3 id="goconst">goconst</h3>
<p>goconst 会查找重复的字符串，这些字符串可以抽取成常量。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get -u github.com/jgautheron/goconst/cmd/goconst</div></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ goconst ./… | grep -v vendor</div></pre></td></tr></table></figure>

<p>以上是作者列出的一些工具， 和我以前的一篇文章中列出的工具有很多重合的： <a href="http://colobu.com/2017/02/07/write-idiomatic-golang-codes/#使用工具检查你的代码" target="_blank" rel="external">使用工具检查你的代码</a>， 事实上我在项目中已经使用了文中很多的代码，非常非常的有帮助，希望你在阅读后能有所收获，快将这些工具加入到你的Makefile文件中吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://medium.com/@arshamshirvani/lint-your-golang-code-like-a-pro-668dc6637b39" target="_blank" rel="external">Lint your #golang code like a mad man!</a>, 作者: <a href="https://medium.com/@arshamshirvani?source=post_header_lockup" target="_blank" rel="external">Arsham Shirvani</a></p>
<p>我使用下面的工具来改进我的代码，除了<code>vendor</code>文件夹。我的操作系统是<code>GNU/Linux</code>,但是稍微修改一下脚本应该也能运行在你的操作系统上。我使用<a href="https://github.com/Masterminds/glide" target="_blank" rel="external">glide</a>来处理依赖(vendor),但你也可以使用你的包依赖管理工具来替换<code>glide nv</code>， 这个命令列出了所有的文件夹，除了vender (译者按： Go 1.9中可以直接使用<code>./...</code>，它会排除vendor文件夹)。有些情况下<code>glide nv</code>不适合，所以我使用了它的老式风格。</p>
<p>注意我使用<code>$</code>作为shell的提示符。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
</feed>
