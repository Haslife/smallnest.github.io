<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://colobu.com/"/>
  <updated>2017-04-26T09:51:53.567Z</updated>
  <id>http://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[转]Spring 5 新功能：函数式 Web 框架]]></title>
    <link href="http://colobu.com/2017/04/26/new-in-spring-5-functional-web-framework/"/>
    <id>http://colobu.com/2017/04/26/new-in-spring-5-functional-web-framework/</id>
    <published>2017-04-26T09:30:03.000Z</published>
    <updated>2017-04-26T09:51:33.000Z</updated>
    <content type="html"><![CDATA[<p>英文原文：<a href="https://spring.io/blog/2016/09/22/new-in-spring-5-functional-web-framework" target="_blank" rel="external">New in Spring 5: Functional Web Framework</a> by<br>中文翻译: <a href="https://www.oschina.net/translate/new-in-spring-5-functional-web-framework" target="_blank" rel="external">Spring 5 新功能：函数式 Web 框架</a> by 开源中国</p>
<p>就像在昨天Juergen发布的<a href="https://spring.io/blog/2016/09/21/spring-framework-5-0-m2-released" target="_blank" rel="external">博客</a>的一样，Spring 5.0框架第二个里程碑版本中介绍了一个新的函数式web框架。在这篇文章中，我将更详细的介绍这个框架。</p>
<p>紧记该函数式web框架是在Spring5.0第一个里程碑版本基础上构建的。并且我们依旧提供基于注解的请求处理（例如@Controller,@RequestMapping)，关于基于注解的请求处理部分的相关信息请查阅关于Spring5.0<a href="https://spring.io/blog/2016/07/28/reactive-programming-with-spring-5-0-m1" target="_blank" rel="external">第一个里程碑版本</a>的博客。</p>
<a id="more"></a>
<h3 id="示例">示例</h3>
<p>我们选用示例程序作为开始。下面是一个响应资源库用于暴露Person对象。这个响应资源库与传统的无响应资源库类似，除了Flux<person>对应传统的 List<person>，Mono<person>对应传统的 Person对象。Mono<void>作为完成标识：用于指示保存工作完成.更多Reactor 类型信息请查阅 <a href="https://spring.io/blog/2016/06/13/notes-on-reactive-programming-part-ii-writing-some-code" target="_blank" rel="external">Dave发布的博客</a></void></person></person></person></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> </span>{</div><div class="line">  Mono&lt;Person&gt; getPerson(<span class="keyword">int</span> id);</div><div class="line">  Flux&lt;Person&gt; allPeople();</div><div class="line">  Mono&lt;Void&gt; savePerson(Mono&lt;Person&gt; person);}</div></pre></td></tr></table></figure>

<p>这里我们介绍如何使用新的函数式web框架暴露资源库：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">RouterFunction&lt;?&gt; route = route(GET(<span class="string">"/person/{id}"</span>),</div><div class="line">  request -&gt; {</div><div class="line">    Mono&lt;Person&gt; person = Mono.justOrEmpty(request.pathVariable(<span class="string">"id"</span>))</div><div class="line">      .map(Integer::valueOf)</div><div class="line">      .then(repository::getPerson);</div><div class="line">    <span class="keyword">return</span> Response.ok().body(fromPublisher(person, Person.class));</div><div class="line">  })</div><div class="line">  .and(route(GET(<span class="string">"/person"</span>),</div><div class="line">    request -&gt; {</div><div class="line">      Flux&lt;Person&gt; people = repository.allPeople();</div><div class="line">      <span class="keyword">return</span> Response.ok().body(fromPublisher(people, Person.class));</div><div class="line">    }))</div><div class="line">  .and(route(POST(<span class="string">"/person"</span>),</div><div class="line">    request -&gt; {</div><div class="line">      Mono&lt;Person&gt; person = request.body(toMono(Person.class));</div><div class="line">      <span class="keyword">return</span> Response.ok().build(repository.savePerson(person));</div><div class="line">    }));</div></pre></td></tr></table></figure>

<p>这里我们介绍如何运行它，下面是Reactor Netty的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HttpHandler httpHandler = RouterFunctions.toHttpHandler(route);</div><div class="line">ReactorHttpHandlerAdapter adapter =</div><div class="line">  <span class="keyword">new</span> ReactorHttpHandlerAdapter(httpHandler);</div><div class="line">HttpServer server = HttpServer.create(<span class="string">"localhost"</span>, <span class="number">8080</span>);</div><div class="line">server.startAndAwait(adapter);</div></pre></td></tr></table></figure>

<p>最后要做的是，进行一次尝试请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ curl <span class="string">'http://localhost:8080/person/1'</span></div><div class="line">{<span class="string">"name"</span>:<span class="string">"John Doe"</span>,<span class="string">"age"</span>:<span class="number">42</span>}</div></pre></td></tr></table></figure>

<p>上面的介绍覆盖了很多内容，下面让我们深入挖掘下！</p>
<h3 id="核心组件">核心组件</h3>
<p>我将通过依次介绍<code>HandlerFunction</code>,<code>RouterFunction</code>以及<code>FilterFunction</code> 等核心组件来介绍整个框架。这三个接口以及本文中其他类型都可以在<a href="http://docs.spring.io/spring/docs/5.0.0.M2/javadoc-api/org/springframework/web/reactive/function/package-summary.html" target="_blank" rel="external">org.springframework.web.reactive.function</a>包中找到。</p>
<h4 id="HandlerFunction">HandlerFunction</h4>
<p>新框架的起点是HandlerFunction<t>，其实质是Function<request, response<t="">&gt;，其中的Request 和 Response都是新定义的不可变接口，提供了基础的对JDK8优化的HTTP消息描述DSL。有一个便捷的构造Response实例的构造器，与ResponseEntity中的十分相似。注解方式中与HandlerFunction相对应的是@RequestMapping所注解的方法。</request,></t></p>
<p>如下是“Hello World”的处理方法，它返回了状态为200，body为字符串的消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HandlerFunction&lt;String&gt; helloWorld =</div><div class="line">  request -&gt; Response.ok().body(fromObject(<span class="string">"Hello World"</span>));</div></pre></td></tr></table></figure>

<p>如上，构建于Reactor之上的处理方法是完全的响应式的（reactive），它们可以接受Flux、Mono或者其他相应流（<a href="http://www.reactive-streams.org/" target="_blank" rel="external">Reactive Streams</a>）的发布者作为返回类型的参数。</p>
<p>需要注意的是处理方法本身是没有副作用的，因为它将response作为返回值，而不是作为参数（对比Servlet.service(ServletRequest,ServletResponse)，其实质是BiConsumer<servletrequest,servletresponse>）。无副作用的方法有很多好处：更有利于<a href="http://programmers.stackexchange.com/questions/15269/why-are-side-effects-considered-evil-in-functional-programming" target="_blank" rel="external">测试、构建和优化</a>。</servletrequest,servletresponse></p>
<h4 id="RouterFunction">RouterFunction</h4>
<p>入站请求是由RouterFunction<t>，(即Function<request, optional<handlerfunction<t="">&gt;)路由到HandlerFunction中去的。当满足条件匹配时，路由方法会执行处理方法，否则会返回一个空结果。路由方法与@RequestMapping注解的作用相似。但是，还有一个显著的区别：用注解时路由会被限制到注解的value所能表达的范围，处理这些方法的覆盖是困难的；当用路由方法的时候，代码就在那里，可以轻松的覆盖或替换。</request,></t></p>
<p>如下是一个路由方法的例子，包含了一个行内的处理方法。这里看起来有一点冗余，不必担心，因为后面我们将会将它变得精简。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">RouterFunction&lt;String&gt; helloWorldRoute = </div><div class="line">  request -&gt; {</div><div class="line">    <span class="keyword">if</span> (request.path().equals(<span class="string">"/hello-world"</span>)) {</div><div class="line">      <span class="keyword">return</span> Optional.of(r -&gt; Response.ok().body(fromObject(<span class="string">"Hello World"</span>)));</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">      <span class="keyword">return</span> Optional.empty();</div><div class="line">    }</div><div class="line">  };</div></pre></td></tr></table></figure>

<p>一般不用写完整的路由方法，而是静态引入RouterFunctions.route()，这样就可以用请求判断式（RequestPredicate） (即 Predicate<request>)和处理方法（HandlerFunction）创建路由方法了。如果判断式判断成功则返回处理方法，否则返回空结果。如下是用route方法方式重写上面的例子：</request></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RouterFunction&lt;String&gt; helloWorldRoute =</div><div class="line">  RouterFunctions.route(request -&gt; request.path().equals(<span class="string">"/hello-world"</span>),</div><div class="line">    request -&gt; Response.ok().body(fromObject(<span class="string">"Hello World"</span>)));</div></pre></td></tr></table></figure>

<p>静态引入RequestPredicates.*后就可以使用那些常用的判断式了，如匹配路径、HTTP方法、content-type等。这样上面的例子将会变得更精简：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RouterFunction&lt;String&gt; helloWorldRoute =</div><div class="line">  RouterFunctions.route(RequestPredicates.path(<span class="string">"/hello-world"</span>),</div><div class="line">    request -&gt; Response.ok().body(fromObject(<span class="string">"Hello World"</span>)));</div></pre></td></tr></table></figure>

<h4 id="组合函数">组合函数</h4>
<p>两个路由方法可以被组合成一个新的路由方法，可以路由任意处理方法：如果第一个路由不匹配则执行第二个。可以通过调用RouterFunction.and()方法实现，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RouterFunction&lt;?&gt; route =</div><div class="line">  route(path(<span class="string">"/hello-world"</span>),</div><div class="line">    request -&gt; Response.ok().body(fromObject(<span class="string">"Hello World"</span>)))</div><div class="line">  .and(route(path(<span class="string">"/the-answer"</span>),</div><div class="line">    request -&gt; Response.ok().body(fromObject(<span class="string">"42"</span>))));</div></pre></td></tr></table></figure>

<p>上面的例子如果路径匹配/hello-world会返回“Hello World”，如果匹配/the-answer则返回“42”。如果都不匹配则返回一个空的Optional对象。注意，组合的路由是按顺序执行的，所以应该将更通用的方法放到更明确的方法的前面。</p>
<p>请求判断式也是可以组合的，通过调研and或者or方法。正如预期的一样：and表示给定的两个判断式同时满足则组合判断式满足，or则表示任意判断式满足。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RouterFunction&lt;?&gt; route =</div><div class="line">  route(method(HttpMethod.GET).and(path(<span class="string">"/hello-world"</span>)), </div><div class="line">    request -&gt; Response.ok().body(fromObject(<span class="string">"Hello World"</span>)))</div><div class="line">  .and(route(method(HttpMethod.GET).and(path(<span class="string">"/the-answer"</span>)), </div><div class="line">    request -&gt; Response.ok().body(fromObject(<span class="string">"42"</span>))));</div></pre></td></tr></table></figure>

<p>实际上，RequestPredicates中的大部分判断式都是组合的！比如RequestPredicates.GET(String)是RequestPredicates.method(HttpMethod)和RequestPredicates.path(String)的组合。所以上面的例子可以重写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RouterFunction&lt;?&gt; route =</div><div class="line">  route(GET(<span class="string">"/hello-world"</span>),</div><div class="line">    request -&gt; Response.ok().body(fromObject(<span class="string">"Hello World"</span>)))</div><div class="line">  .and(route(GET(<span class="string">"/the-answer"</span>),</div><div class="line">    request -&gt; Response.ok().body(fromObject(<span class="number">42</span>))));</div></pre></td></tr></table></figure>

<h4 id="方法引用">方法引用</h4>
<p>此外，目前为止我们的处理方法都是行内的lambda表达式。尽管这样很适合于实例和简短的例子，但是当结合请求路由和请求处理两个关注点时，可能就有变“混乱”的趋势了。所以我们将尝试将他们简化。首先，创建一个包含处理逻辑的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class DemoHandler {</div><div class="line">  <span class="keyword">public</span> Response&lt;String&gt; <span class="title">helloWorld</span>(Request request) {</div><div class="line">    <span class="keyword">return</span> Response.ok().body(fromObject(<span class="string">"Hello World"</span>));</div><div class="line">  }</div><div class="line">  <span class="keyword">public</span> Response&lt;String&gt; <span class="title">theAnswer</span>(Request request) {</div><div class="line">    <span class="keyword">return</span> Response.ok().body(fromObject(<span class="string">"42"</span>));</div><div class="line">  }}</div></pre></td></tr></table></figure>

<p>注意，这两个方法的签名都是和处理方法兼容的。这样就可以方法引用了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DemoHandler handler = <span class="keyword">new</span> DemoHandler(); <span class="comment">// or obtain via DI</span></div><div class="line">RouterFunction&lt;?&gt; route =</div><div class="line">  route(GET(<span class="string">"/hello-world"</span>), handler::helloWorld)</div><div class="line">  .and(route(GET(<span class="string">"/the-answer"</span>), handler::theAnswer));</div></pre></td></tr></table></figure>

<h4 id="FilterFunction">FilterFunction</h4>
<p>由路由器函数进行映射的路由可以通过调用 RouterFunction.filter(FilterFunction<t, r="">) 来进行过滤, 这里的 FilterFunction<t,r> 其实就是一个 BiFunction<request, handlerfunction<t="">, Response<r>&gt;。函数的处理器（handler）参数代表的就是整个链条中的下一项: 这是一个典型的 HandlerFunction, 但如果附加了多个过滤器的话，它也能够是另外的一个 FilterFunction。让我们向路由添加一个日志过滤器：</r></request,></t,r></t,></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">RouterFunction&lt;?&gt; route =</div><div class="line">  route(GET(<span class="string">"/hello-world"</span>), handler::helloWorld)</div><div class="line">  .and(route(GET(<span class="string">"/the-answer"</span>), handler::theAnswer))</div><div class="line">  .filter((request, next) -&gt; {</div><div class="line">    System.out.println(<span class="string">"Before handler invocation: "</span> + request.path());</div><div class="line">    Response&lt;?&gt; response = next.handle(request);</div><div class="line">    Object body = response.body();</div><div class="line">    System.out.println(<span class="string">"After handler invocation: "</span> + body);</div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">  });</div></pre></td></tr></table></figure>

<p>注意这里对下一个处理器的调用时可选的。这个在安全或者缓存的场景中是很有用的 (例如只在用户拥有足够的权限时才调用 next)。</p>
<p>因为 route 是一个没有被绑定的路由器函数，我们就得知道接下来的处理会返回什么类型的响应消息。这就是为什么我们在过滤器中要以一个 Response&lt;?&gt; 结束, 那样它就会可能有一个 String 类型的响应消息体。我们可以通过使用 RouterFunction.andSame() 而不是 and() 来完成这件事情。这个组合方法要求路由器函数参数是同一个类型。例如，我们可以让所有的响应消息变成小写的文本形式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">RouterFunction&lt;String&gt; route =</div><div class="line">  route(GET(<span class="string">"/hello-world"</span>), handler::helloWorld)</div><div class="line">  .andSame(route(GET(<span class="string">"/the-answer"</span>), handler::theAnswer))</div><div class="line">  .filter((request, next) -&gt; {</div><div class="line">    Response&lt;String&gt; response = next.handle(request);</div><div class="line">    String newBody = response.body().toUpperCase();</div><div class="line">    <span class="keyword">return</span> Response.from(response).body(fromObject(newBody));</div><div class="line">  });</div></pre></td></tr></table></figure>

<p>使用注解的话，类似的功能可以使用 @ControllerAdvice 或者是一个 ServletFilter 来实现。</p>
<h4 id="运行服务器">运行服务器</h4>
<p>所有这些都很不错，不过仍然有一块欠缺：我们如何实际地将这些函数在一个 HTTP 服务器中跑起来呢? 答案毋庸置疑，那就是通过调用另外的一个函数。 你可以通过使用 RouterFunctions.toHttpHandler() 来将一个路由器函数转换成 HttpHandler。HttpHandler 是 Spring 5.0 M1 中引入的一个响应式抽象: 它能让你运行许多的响应式运行时: Reactor Netty, RxNetty, Servlet 3.1+, 以及 Undertow。在本示例中，我们已经展示了在 Reactor Netty 中运行一个路由会是什么样子的。对于 Tomcat 来说则是像下面这个样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HttpHandler httpHandler = RouterFunctions.toHttpHandler(route);</div><div class="line">HttpServlet servlet = <span class="keyword">new</span> ServletHttpHandlerAdapter(httpHandler);</div><div class="line">Tomcat server = <span class="keyword">new</span> Tomcat();</div><div class="line">Context rootContext = server.addContext(<span class="string">""</span>,</div><div class="line">  System.getProperty(<span class="string">"java.io.tmpdir"</span>));</div><div class="line">Tomcat.addServlet(rootContext, <span class="string">"servlet"</span>, servlet);  </div><div class="line">rootContext.addServletMapping(<span class="string">"/"</span>, <span class="string">"servlet"</span>);</div><div class="line">tomcatServer.start();</div></pre></td></tr></table></figure>

<p>需要注意的意见事情就是上面的东西并不依赖于一个 Spring 应用程序上下文。就跟 JdbcTemplate 以及其它 Spring 的工具类那样, 要不要使用应用程序上下文是可以选的: 你可以将你的处理器和路由器函数在一个上下文中进行绑定，但并不是必须的。<br>还要注意的就是你也可以将一个路由器函数转换到一个 HandlerMapping中去，那样就它可以在一个 DispatcherHandler (可能是跟响应式的 @Controllers 并行)中运行了。</p>
<h3 id="总结">总结</h3>
<p>至此便结束了对 Spring 新函数式 web 框架的介绍。让我简单小结一下：</p>
<ul>
<li>handler function 处理request, 返回response，</li>
<li>router function 把请求路由到handler function，并可与其他router function组合，</li>
<li>router function可以被 filter function过滤处理，</li>
<li>router function 可以运行在一个响应式web运行时框架中。</li>
</ul>
<p>为了给你一个更全面的理解，我创建了一个简单的function web framework例子，你可以在github上找到<a href="https://github.com/poutsma/web-function-sample" target="_blank" rel="external">它</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>英文原文：<a href="https://spring.io/blog/2016/09/22/new-in-spring-5-functional-web-framework" target="_blank" rel="external">New in Spring 5: Functional Web Framework</a> by<br>中文翻译: <a href="https://www.oschina.net/translate/new-in-spring-5-functional-web-framework" target="_blank" rel="external">Spring 5 新功能：函数式 Web 框架</a> by 开源中国</p>
<p>就像在昨天Juergen发布的<a href="https://spring.io/blog/2016/09/21/spring-framework-5-0-m2-released" target="_blank" rel="external">博客</a>的一样，Spring 5.0框架第二个里程碑版本中介绍了一个新的函数式web框架。在这篇文章中，我将更详细的介绍这个框架。</p>
<p>紧记该函数式web框架是在Spring5.0第一个里程碑版本基础上构建的。并且我们依旧提供基于注解的请求处理（例如@Controller,@RequestMapping)，关于基于注解的请求处理部分的相关信息请查阅关于Spring5.0<a href="https://spring.io/blog/2016/07/28/reactive-programming-with-spring-5-0-m1" target="_blank" rel="external">第一个里程碑版本</a>的博客。</p>
]]>
    
    </summary>
    
      <category term="Spring" scheme="http://colobu.com/tags/Spring/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[tc: 模拟网络异常的工具]]></title>
    <link href="http://colobu.com/2017/04/21/tc-introduction/"/>
    <id>http://colobu.com/2017/04/21/tc-introduction/</id>
    <published>2017-04-21T06:34:24.000Z</published>
    <updated>2017-04-21T07:59:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/2017/04/21/tc-introduction/network.png" alt=""></p>
<p>Linux Traffic Control (tc)的扩展 Network Emulation (netem)可以很方便的模拟网络不好的情况，一般新的linux内核中(&gt;= 2.6)已经内置了这个工具，可以方便的进行测试。</p>
<p>本文罗列了了 <code>tc</code>的常用的模拟命令， 以备将来使用的时候查询。</p>
<p>主要参考了Linux基金会的官方介绍: <a href="https://wiki.linuxfoundation.org/networking/netem" target="_blank" rel="external">netem</a><br><a id="more"></a></p>
<h3 id="监控网卡。">监控网卡。</h3>
<p>首先要查看你的网卡信息，如: <code>eth0</code>，然后将这个网卡加入监控列表 <code>sudo tc qdisc add dev eth0 root netem</code>。 </p>
<p>如果不想再监控，可以移除这个网卡 <code>sudo tc qdisc del dev eth0 root netem</code></p>
<p>如果想查看监控列表， 可以使用 <code>tc -s qdisc</code>。</p>
<p><code>qdisc</code>是<code>queueing discipline</code>的缩写。</p>
<h3 id="模拟网络延迟">模拟网络延迟</h3>
<h4 id="固定延迟">固定延迟</h4>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc add dev eth0 root netem delay <span class="number">100</span>ms</div></pre></td></tr></table></figure>

<p>每个包都固定延迟 <code>100</code>毫秒， 设置好后你可以使用<code>ping</code>命令测试。</p>
<h4 id="固定延迟+小随机值">固定延迟+小随机值</h4>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem delay <span class="number">100</span>ms <span class="number">10</span>ms</div></pre></td></tr></table></figure>

<p>延迟时间变成了 <code>100ms ± 10ms</code>。</p>
<h4 id="固定延迟+小随机值+相关系数">固定延迟+小随机值+相关系数</h4>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem delay <span class="number">100</span>ms <span class="number">10</span>ms <span class="number">25</span>%</div></pre></td></tr></table></figure>

<blockquote>
<p>This causes the added delay to be 100ms ± 10ms with the next random element depending 25% on the last one. This isn&#39;t true statistical correlation, but an approximation.</p>
</blockquote>
<h4 id="遵循正态分布的延迟">遵循正态分布的延迟</h4>
<p>典型情况下延迟并不是均分分布的，而是遵循类似正态分布的规律。所以你可以使用某种分布模拟延迟。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem delay <span class="number">100</span>ms <span class="number">20</span>ms distribution normal</div></pre></td></tr></table></figure>

<p>分布为<code>normal</code>、 <code>pareto</code>、 <code>paretonormal</code>等。</p>
<h3 id="模拟丢包">模拟丢包</h3>
<p>随机丢弃一些包， 丢弃比率可以设置。丢失比最小为 <code>232 = 0.0000000232%</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem loss <span class="number">0.1</span>%</div></pre></td></tr></table></figure>

<p>上述命令会随机丢弃千分之一的包。</p>
<p>你还可以增加一个相关参数：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem loss <span class="number">0.3</span>% <span class="number">25</span>%</div></pre></td></tr></table></figure>

<p>丢弃率为千分之三， 后一个的丢弃的可能性和前一个的可能性的25%相关：</p>
<p>Prob<sub>n</sub> = .25 <em> Prob<sub>n-1</sub> + .75 </em> Random</p>
<h3 id="模拟包重复">模拟包重复</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem duplicate <span class="number">1</span>%</div></pre></td></tr></table></figure>

<p>类似丢包的命令，上面命令产生百分之一的重复包。</p>
<h3 id="模拟错误包">模拟错误包</h3>
<p>模拟随机噪音(错误包)， 这个功能在 2.6.16以及以后的版本中才加入。它会在包中随机位置更改一个bit。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem corrupt <span class="number">0.1</span>%</div></pre></td></tr></table></figure>

<h3 id="模拟包乱序">模拟包乱序</h3>
<p>1） 方式一<br>使用 gap。 第5th包（5、10、15、20）立即发送，其它的包会延迟10毫秒。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem gap <span class="number">5</span> delay <span class="number">10</span>ms</div></pre></td></tr></table></figure>

<p>2） 方式二<br>方式一乱序方式是固定的，可以预测的。方式二引入随机性：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem delay <span class="number">10</span>ms reorder <span class="number">25</span>% <span class="number">50</span>%</div></pre></td></tr></table></figure>

<p>25%的包会立即发送， 其它的包会延迟10毫秒。相关系数为50%。</p>
<p>新版的netem的包延迟设置也可能导致包乱序，如果包延迟的有一定的随机性的话：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem delay <span class="number">100</span>ms <span class="number">75</span>ms</div></pre></td></tr></table></figure>

<p>因为延迟时间在<code>100ms ± 75ms</code>返回内， 就有可能第二包的延迟比第一个包的延迟小，先发出去。</p>
<h3 id="控制包速(带宽)">控制包速(带宽)</h3>
<p>没有直接命令，需要两条命令配合使用。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># tc qdisc add dev eth0 root handle 1:0 netem delay 100ms</span></div><div class="line"><span class="comment"># tc qdisc add dev eth0 parent 1:1 handle 10: tbf rate 256kbit buffer 1600 limit 3000</span></div><div class="line"><span class="comment"># tc -s qdisc ls dev eth0</span></div><div class="line">qdisc netem <span class="number">1</span>: limit <span class="number">1000</span> delay <span class="number">100.0</span>ms</div><div class="line"> Sent <span class="number">0</span> bytes <span class="number">0</span> pkts (dropped <span class="number">0</span>, overlimits <span class="number">0</span> )</div><div class="line">qdisc tbf <span class="number">10</span>: rate <span class="number">256</span>Kbit burst <span class="number">1599</span>b lat <span class="number">26.6</span>ms</div><div class="line"> Sent <span class="number">0</span> bytes <span class="number">0</span> pkts (dropped <span class="number">0</span>, overlimits <span class="number">0</span> )</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/2017/04/21/tc-introduction/network.png" alt=""></p>
<p>Linux Traffic Control (tc)的扩展 Network Emulation (netem)可以很方便的模拟网络不好的情况，一般新的linux内核中(&gt;= 2.6)已经内置了这个工具，可以方便的进行测试。</p>
<p>本文罗列了了 <code>tc</code>的常用的模拟命令， 以备将来使用的时候查询。</p>
<p>主要参考了Linux基金会的官方介绍: <a href="https://wiki.linuxfoundation.org/networking/netem" target="_blank" rel="external">netem</a><br>]]>
    
    </summary>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go HTTP Redirect的知识点总结]]></title>
    <link href="http://colobu.com/2017/04/19/go-http-redirect/"/>
    <id>http://colobu.com/2017/04/19/go-http-redirect/</id>
    <published>2017-04-19T08:28:01.000Z</published>
    <updated>2017-04-20T06:10:21.000Z</updated>
    <content type="html"><![CDATA[<p>HTTP 规范中定义了返回码为 <code>3xx</code> 代表客户端需要做一些额外的工作来完成请求，大部分<code>3xx</code>用来做转发(redirect)。</p>
<p>状态码的详细说明可以参照规范或者 <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection" target="_blank" rel="external">wikipedia</a>、<a href="https://zh.wikipedia.org/wiki/HTTP状态码#3xx" target="_blank" rel="external">维基百科</a>, 以下是代码的简短介绍。</p>
<ul>
<li>300 Multiple Choices: 返回多个可供选择的资源</li>
<li>301 Moved Permanently: 请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一</li>
<li>302 Found: 请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求,HTTP 1.0中的意义是<code>Moved Temporarily</code>,但是很多浏览器的实现是按照303的处实现的，所以HTTP 1.1中增加了 303和307的状态码来区分不同的行为</li>
<li>303 See Other (since HTTP/1.1): 对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源</li>
<li>304 Not Modified (RFC 7232): 请求的资源没有改变</li>
<li>305 Use Proxy (since HTTP/1.1): 被请求的资源必须通过指定的代理才能被访问</li>
<li>306 Switch Proxy: 在最新版的规范中，306状态码已经不再被使用</li>
<li>307 Temporary Redirect (since HTTP/1.1): 请求的资源现在临时从不同的URI响应请求,和303不同，它还是使用原先的Method</li>
<li>308 Permanent Redirect (RFC 7538): 请求的资源已永久移动到新位置,并且新请求的Method不能改变</li>
</ul>
<p>Go 的 http 库在实现的过程中也在不断的完成和修改其中的Bug,在 1.8版本中解决了前面版本中实现的问题 (你可以在 Go issues中搜索 redirect 来查看相关的issue)。 本文梳理了 Go 中 Redirect 的相关知识，以便你在遇到转发的问题时心中有数。</p>
<a id="more"></a>
<h3 id="转发策略和默认转发次数。">转发策略和默认转发次数。</h3>
<p><a href="">http.Client</a>包含一个<code>CheckRedirect</code>字段，用来定义转发的策略，如果你没有设置，则默认使用<code>defaultCheckRedirect</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (c *Client) checkRedirect(req *Request, via []*Request) error {</div><div class="line">	fn := c.CheckRedirect</div><div class="line">	<span class="keyword">if</span> fn == <span class="constant">nil</span> {</div><div class="line">		fn = defaultCheckRedirect</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> fn(req, via)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个函数会在执行转发之前被调用,可以看到这个函数如果返回err,则不再进行转发了。<br>这个函数的第一个参数<code>req</code>是即将转发使用的request，第二个参数 <code>via</code>已经请求的requests。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> {</div><div class="line">    ……</div><div class="line">    <span class="comment">//需要转发</span></div><div class="line">    {</div><div class="line">        ……</div><div class="line">        err = c.checkRedirect(req, reqs)</div><div class="line">		<span class="keyword">if</span> err == ErrUseLastResponse {</div><div class="line">			<span class="keyword">return</span> resp, <span class="constant">nil</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="comment">//discard previous response</span></div><div class="line">        ……</div><div class="line"></div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			ue := uerr(err)</div><div class="line">			ue.(*url.Error).URL = loc</div><div class="line">			<span class="keyword">return</span> resp, ue</div><div class="line">		}</div><div class="line">    }</div><div class="line"></div><div class="line">    ……</div><div class="line">}</div></pre></td></tr></table></figure>

<p>默认的转发策略是最多10次转发， 避免转发次数过高或者死循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> defaultCheckRedirect(req *Request, via []*Request) error {</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(via) &gt;=<span class="number"> 10</span> {</div><div class="line">		<span class="keyword">return</span> errors.New(<span class="string">"stopped after 10 redirects"</span>)</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你要实现不同的转发策略，你需要定义自己的<code>CheckRedirect</code>。</p>
<h3 id="转发安全">转发安全</h3>
<p>1）当转发的request中包含安全的信息Header时， 比如<code>Authorization</code>、<code>WWW-Authenticate</code>、<code>Cookie</code>等Header,如果是跨域，则这些头部不会被复制到新的请求中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> shouldCopyHeaderOnRedirect(headerKey <span class="typename">string</span>, initial, dest *url.URL) <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">switch</span> CanonicalHeaderKey(headerKey) {</div><div class="line">	<span class="keyword">case</span> <span class="string">"Authorization"</span>, <span class="string">"Www-Authenticate"</span>, <span class="string">"Cookie"</span>, <span class="string">"Cookie2"</span>:</div><div class="line">		ihost := strings.ToLower(initial.Host)</div><div class="line">		dhost := strings.ToLower(dest.Host)</div><div class="line">		<span class="keyword">return</span> isDomainOrSubdomain(dhost, ihost)</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>2）如果设置了一个非空的 cookie Jar, 转发响应会修改 cookie jar中的值，但是下一次转发的时候， <code>Cookie</code>header会被处理，忽略那些变动的cookie.</p>
<p>  when forwarding the &quot;Cookie&quot; header with a non-nil cookie Jar.<br>  Since each redirect may mutate the state of the cookie jar,<br>  a redirect may possibly alter a cookie set in the initial request.<br>  When forwarding the &quot;Cookie&quot; header, any mutated cookies will be omitted,<br>  with the expectation that the Jar will insert those mutated cookies<br>  with the updated values (assuming the origin matches).<br>  If Jar is nil, the initial cookies are forwarded without change.</p>
<p>  具体的你可以查看 <code>makeHeadersCopier</code>的实现。<br>  可以看到每次redirect会删除上次的Redirect造成的变动，再恢复原始的请求的Coookie。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">if</span> c.Jar != <span class="constant">nil</span> && icookies != <span class="constant">nil</span> {</div><div class="line">	<span class="keyword">var</span> changed <span class="typename">bool</span></div><div class="line">	resp := req.Response <span class="comment">// The response that caused the upcoming redirect</span></div><div class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> resp.Cookies() {</div><div class="line">		<span class="keyword">if</span> _, ok := icookies[c.Name]; ok {</div><div class="line">			<span class="built_in">delete</span>(icookies, c.Name)</div><div class="line">			changed = <span class="constant">true</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> changed {</div><div class="line">		ireqhdr.Del(<span class="string">"Cookie"</span>)</div><div class="line">		<span class="keyword">var</span> ss []<span class="typename">string</span></div><div class="line">		<span class="keyword">for</span> _, cs := <span class="keyword">range</span> icookies {</div><div class="line">			<span class="keyword">for</span> _, c := <span class="keyword">range</span> cs {</div><div class="line">				ss = <span class="built_in">append</span>(ss, c.Name+<span class="string">"="</span>+c.Value)</div><div class="line">			}</div><div class="line">		}</div><div class="line">		sort.Strings(ss) <span class="comment">// Ensure deterministic headers</span></div><div class="line">		ireqhdr.Set(<span class="string">"Cookie"</span>, strings.Join(ss, <span class="string">"; "</span>))</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Copy the initial request's Header values</span></div><div class="line"><span class="comment">// (at least the safe ones).</span></div><div class="line"><span class="keyword">for</span> k, vv := <span class="keyword">range</span> ireqhdr {</div><div class="line">	<span class="keyword">if</span> shouldCopyHeaderOnRedirect(k, preq.URL, req.URL) {</div><div class="line">		req.Header[k] = vv</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="转发规则">转发规则</h3>
<p>当服务器返回一个转发response的时候， client首先使用<code>CheckRedirect</code>函数检查是否要进行转发。</p>
<p>默认会处理下列请求：</p>
<ul>
<li>301 (Moved Permanently)</li>
<li>302 (Found)</li>
<li>303 (See Other)</li>
<li>307 (Temporary Redirect)</li>
<li>308 (Permanent Redirect)</li>
</ul>
<p>如果需要转发， 对于<code>301</code>、<code>302</code>、<code>303</code>的状态码， 接下来转发的请求会将请求<strong>Method</strong>转换成<code>GET</code> method (如果原始请求Method是<code>HEAD</code>则不变，还是<code>HEAD</code>)， 而且body为空， 尽管原始的请求可能包含body。 对于<code>307</code>、<code>308</code>状态码，接下来转发的请求的<strong>Method</strong>没有变化，和原始的请求保持一致， 并且还是使用原始的body内容来发送转发请求。</p>
<p>代码处理的逻辑是由<code>redirectBehavior</code>函数实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> redirectBehavior(reqMethod <span class="typename">string</span>, resp *Response, ireq *Request) (redirectMethod <span class="typename">string</span>, shouldRedirect, includeBody <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">switch</span> resp.StatusCode {</div><div class="line">	<span class="keyword">case</span><span class="number"> 301</span>,<span class="number"> 302</span>,<span class="number"> 303</span>:</div><div class="line">		redirectMethod = reqMethod</div><div class="line">		shouldRedirect = <span class="constant">true</span></div><div class="line">		includeBody = <span class="constant">false</span></div><div class="line"></div><div class="line">		<span class="keyword">if</span> reqMethod != <span class="string">"GET"</span> && reqMethod != <span class="string">"HEAD"</span> {</div><div class="line">			redirectMethod = <span class="string">"GET"</span></div><div class="line">		}</div><div class="line">	<span class="keyword">case</span><span class="number"> 307</span>,<span class="number"> 308</span>:</div><div class="line">		redirectMethod = reqMethod</div><div class="line">		shouldRedirect = <span class="constant">true</span></div><div class="line">		includeBody = <span class="constant">true</span></div><div class="line"></div><div class="line">	</div><div class="line">		<span class="keyword">if</span> resp.Header.Get(<span class="string">"Location"</span>) == <span class="string">""</span> {</div><div class="line">			shouldRedirect = <span class="constant">false</span></div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> ireq.GetBody == <span class="constant">nil</span> && ireq.outgoingLength() !=<span class="number"> 0</span> {</div><div class="line">			shouldRedirect = <span class="constant">false</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> redirectMethod, shouldRedirect, includeBody</div><div class="line">}</div></pre></td></tr></table></figure>

<p>以上是介绍的http Redirect相关的内容，它们主要是客户端的代码逻辑。 下面两节介绍一下与http redirect有一点点关系的内容。</p>
<h3 id="RedirectHandler">RedirectHandler</h3>
<p>http定义了一个便利类型: <a href="https://golang.org/pkg/net/http/#RedirectHandler" target="_blank" rel="external">RedirectHandler</a>, 它是一个预定义的http handler,可以将指定的请求转发到指定的url中， 主要就是使用设定的 url 和 status code 设置 response 的 Location。</p>
<p>它用作服务器端的开发中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> RedirectHandler(url <span class="typename">string</span>, code <span class="typename">int</span>) Handler</div></pre></td></tr></table></figure>

<p>注意 code应该是 <code>3xx</code>的状态码， 通常是<code>StatusMovedPermanently</code>, <code>StatusFound</code> 或者 <code>StatusSeeOther</code>。</p>
<h3 id="RoundTripper">RoundTripper</h3>
<p><a href="https://golang.org/pkg/net/http/#RoundTripper" target="_blank" rel="external">RoundTripper</a>也用作客户端的开发。</p>
<p>RoundTripper代表一次http 的请求。 当使用redirect的时候，你可能redirect多次，也就是执行了n次的http请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> RoundTripper <span class="keyword">interface</span> {</div><div class="line">        RoundTrip(*Request) (*Response, error)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>DefaultTransport</code>是默认RoundTripper的实现。它建立网络连接，并且会缓存以便后续的请求重用。它会使用<code>$HTTP_PROXY</code>和<code>$NO_PROXY</code> (或者 $http_proxy， $no_proxy)环境变量来设置代理.</p>
<p>其它的RoundTripper的实现还有<code>NewFileTransport</code>创建的RoundTripper,用来服务文件系统，将文件系统映射成http的处理方式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> DefaultTransport RoundTripper = &Transport{</div><div class="line">        Proxy: ProxyFromEnvironment,</div><div class="line">        DialContext: (&net.Dialer{</div><div class="line">                Timeout:  <span class="number"> 30</span> * time.Second,</div><div class="line">                KeepAlive:<span class="number"> 30</span> * time.Second,</div><div class="line">                DualStack: <span class="constant">true</span>,</div><div class="line">        }).DialContext,</div><div class="line">        MaxIdleConns:         <span class="number"> 100</span>,</div><div class="line">        IdleConnTimeout:      <span class="number"> 90</span> * time.Second,</div><div class="line">        TLSHandshakeTimeout:  <span class="number"> 10</span> * time.Second,</div><div class="line">        ExpectContinueTimeout:<span class="number"> 1</span> * time.Second,</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当<code>Redirect</code>的时候，默认转发是http库自动帮你实现的，如果你想对于转发过程做深入的跟踪的话(简单跟踪可以使用<a href="https://golang.org/pkg/net/http/httptrace/" target="_blank" rel="external">httptrace</a>),你可以自定义一个RoundTripper,比如下面的这个：</p>
<figure class="highlight go"><figcaption><span>http://stackoverflow.com/questions/24577494/how-to-get-the-http-redirect-status-codes-in-golang</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> LogRedirects <span class="keyword">struct</span> {</div><div class="line">    Transport http.RoundTripper</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (l LogRedirects) RoundTrip(req *http.Request) (resp *http.Response, err error) {</div><div class="line">    t := l.Transport</div><div class="line">    <span class="keyword">if</span> t == <span class="constant">nil</span> {</div><div class="line">        t = http.DefaultTransport</div><div class="line">    }</div><div class="line">    resp, err = t.RoundTrip(req)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line">    <span class="keyword">switch</span> resp.StatusCode {</div><div class="line">    <span class="keyword">case</span> http.StatusMovedPermanently, http.StatusFound, http.StatusSeeOther, http.StatusTemporaryRedirect:</div><div class="line">        log.Println(<span class="string">"Request for"</span>, req.URL, <span class="string">"redirected with status"</span>, resp.StatusCode)</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>创建<code>Client</code>的时候可以使用下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">client := &http.Client{Transport: LogRedirects{}}</div></pre></td></tr></table></figure>

<p>这样每次转发过程我们都可以追踪。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>HTTP 规范中定义了返回码为 <code>3xx</code> 代表客户端需要做一些额外的工作来完成请求，大部分<code>3xx</code>用来做转发(redirect)。</p>
<p>状态码的详细说明可以参照规范或者 <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection" target="_blank" rel="external">wikipedia</a>、<a href="https://zh.wikipedia.org/wiki/HTTP状态码#3xx" target="_blank" rel="external">维基百科</a>, 以下是代码的简短介绍。</p>
<ul>
<li>300 Multiple Choices: 返回多个可供选择的资源</li>
<li>301 Moved Permanently: 请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一</li>
<li>302 Found: 请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求,HTTP 1.0中的意义是<code>Moved Temporarily</code>,但是很多浏览器的实现是按照303的处实现的，所以HTTP 1.1中增加了 303和307的状态码来区分不同的行为</li>
<li>303 See Other (since HTTP/1.1): 对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源</li>
<li>304 Not Modified (RFC 7232): 请求的资源没有改变</li>
<li>305 Use Proxy (since HTTP/1.1): 被请求的资源必须通过指定的代理才能被访问</li>
<li>306 Switch Proxy: 在最新版的规范中，306状态码已经不再被使用</li>
<li>307 Temporary Redirect (since HTTP/1.1): 请求的资源现在临时从不同的URI响应请求,和303不同，它还是使用原先的Method</li>
<li>308 Permanent Redirect (RFC 7538): 请求的资源已永久移动到新位置,并且新请求的Method不能改变</li>
</ul>
<p>Go 的 http 库在实现的过程中也在不断的完成和修改其中的Bug,在 1.8版本中解决了前面版本中实现的问题 (你可以在 Go issues中搜索 redirect 来查看相关的issue)。 本文梳理了 Go 中 Redirect 的相关知识，以便你在遇到转发的问题时心中有数。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gRPC的那些事 - interceptor]]></title>
    <link href="http://colobu.com/2017/04/17/dive-into-gRPC-interceptor/"/>
    <id>http://colobu.com/2017/04/17/dive-into-gRPC-interceptor/</id>
    <published>2017-04-17T04:42:32.000Z</published>
    <updated>2017-04-17T05:41:16.000Z</updated>
    <content type="html"><![CDATA[<p>gRPC-Go 增加了拦截器(interceptor)的功能， 就像Java Servlet中的 filter一样，可以对RPC的请求和响应进行拦截处理，而且既可以在客户端进行拦截，也可以对服务器端进行拦截。</p>
<p>利用拦截器，可以对gRPC进行扩展，利用社区的力量将gRPC发展壮大，也可以让开发者更灵活地处理gRPC流程中的业务逻辑。下面列出了利用拦截器实现的一些功能框架：<br><a id="more"></a></p>
<ol>
<li><a href="https://github.com/grpc-ecosystem/go-grpc-middleware" target="_blank" rel="external">Go gRPC Middleware</a>:提供了拦截器的interceptor链式的功能，可以将多个拦截器组合成一个拦截器链，当然它还提供了其它的功能，所以以gRPC中间件命名。</li>
<li><a href="https://github.com/kazegusuri/grpc-multi-interceptor" target="_blank" rel="external">grpc-multi-interceptor</a>: 是另一个interceptor链式功能的库，也可以将单向的或者流式的拦截器组合。</li>
<li><a href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/auth" target="_blank" rel="external">grpc_auth</a>: 身份验证拦截器</li>
<li><a href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/tags" target="_blank" rel="external">grpc_ctxtags</a>: 为上下文增加<code>Tag</code> map对象</li>
<li><a href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/logging/zap" target="_blank" rel="external">grpc_zap</a>: 支持<code>zap</code>日志框架</li>
<li><a href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/logging/logrus" target="_blank" rel="external">grpc_logrus</a>: 支持<code>logrus</code>日志框架</li>
<li><a href="https://github.com/grpc-ecosystem/go-grpc-prometheus" target="_blank" rel="external">grpc_prometheus</a>: 支持 <code>prometheus</code></li>
<li><a href="https://github.com/grpc-ecosystem/grpc-opentracing/tree/master/go/otgrpc" target="_blank" rel="external">otgrpc</a>: 支持opentracing/zipkin</li>
<li><a href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/tracing/opentracing" target="_blank" rel="external">grpc_opentracing</a>:支持opentracing/zipkin</li>
<li><a href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/retry" target="_blank" rel="external">grpc_retry</a>: 为客户端增加重试的功能</li>
<li><a href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/validator" target="_blank" rel="external">grpc_validator</a>: 为服务器端增加校验的功能</li>
<li><a href="https://github.com/mercari/go-grpc-interceptor/tree/master/xrequestid" target="_blank" rel="external">xrequestid</a>: 将request id 设置到context中</li>
<li><a href="https://github.com/mercari/go-grpc-interceptor/tree/master/acceptlang" target="_blank" rel="external">go-grpc-interceptor</a>: 解析<code>Accept-Language</code>并设置到context</li>
<li><a href="https://github.com/mercari/go-grpc-interceptor/tree/master/requestdump" target="_blank" rel="external">requestdump</a>: 输出request/response</li>
</ol>
<p>也有其它一些文章介绍的利用拦截器的例子，如下面的两篇文章：<br><a href="https://texlution.com/post/oauth-and-grpc-go/" target="_blank" rel="external">Introduction to OAuth on gRPC</a>、<a href="https://segmentfault.com/a/1190000007997759" target="_blank" rel="external">gRPC实践 拦截器 Interceptor</a></p>
<p>相信会有更多有趣的拦截器被贡献出来。</p>
<p>注意，服务器只能配置一个 unary interceptor和 stream interceptor，否则会报错，客户端也是，虽然不会报错，但是只有最后一个才起作用。 如果你想配置多个，可以使用前面提到的拦截器链或者自己实现一个。</p>
<p>实现拦截器麻烦吗？一点都不麻烦，相反，非常的简单。</p>
<p>对于服务器端的单向调用的拦截器，只需定义一个<code>UnaryServerInterceptor</code>方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> UnaryServerInterceptor <span class="keyword">func</span>(ctx context.Context, req <span class="keyword">interface</span>{}, info *UnaryServerInfo, handler UnaryHandler) (resp <span class="keyword">interface</span>{}, err error)</div></pre></td></tr></table></figure>

<p>对于服务器端stream调用的拦截器，只需定义一个<code>StreamServerInterceptor</code>方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> StreamServerInterceptor <span class="keyword">func</span>(srv <span class="keyword">interface</span>{}, ss ServerStream, info *StreamServerInfo, handler StreamHandler) error</div></pre></td></tr></table></figure>

<p>方法的参数中包含了上下文，请求和stream以及要调用对象的信息。</p>
<p>对于客户端的单向的拦截，只需定义一个``方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> UnaryClientInterceptor <span class="keyword">func</span>(ctx context.Context, method <span class="typename">string</span>, req, reply <span class="keyword">interface</span>{}, cc *ClientConn, invoker UnaryInvoker, opts ...CallOption) error</div></pre></td></tr></table></figure>

<p>对于客户端的stream的拦截，只需定义一个``方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> StreamClientInterceptor <span class="keyword">func</span>(ctx context.Context, desc *StreamDesc, cc *ClientConn, method <span class="typename">string</span>, streamer Streamer, opts ...CallOption) (ClientStream, error)</div></pre></td></tr></table></figure>

<p>你可以查看上面提到的一些开源的拦截器的实现，它们的实现都不是太复杂，下面我们以一个简单的例子来距离，在方法调用的前后打印一个log。</p>
<p><strong>Server端的拦截器</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line"></div><div class="line">	<span class="string">"flag"</span></div><div class="line"></div><div class="line">	pb <span class="string">"github.com/smallnest/grpc/a/pb"</span></div><div class="line">	<span class="string">"golang.org/x/net/context"</span></div><div class="line">	<span class="string">"google.golang.org/grpc"</span></div><div class="line">	<span class="string">"google.golang.org/grpc/reflection"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	port = flag.String(<span class="string">"p"</span>, <span class="string">":8972"</span>, <span class="string">"port"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> server <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {</div><div class="line">	<span class="keyword">return</span> &pb.HelloReply{Message: <span class="string">"Hello "</span> + in.Name}, <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	lis, err := net.Listen(<span class="string">"tcp"</span>, *port)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</div><div class="line">	}</div><div class="line">	s := grpc.NewServer(grpc.StreamInterceptor(StreamServerInterceptor),</div><div class="line">		grpc.UnaryInterceptor(UnaryServerInterceptor))</div><div class="line">	pb.RegisterGreeterServer(s, &server{})</div><div class="line"></div><div class="line">	reflection.Register(s)</div><div class="line">	<span class="keyword">if</span> err := s.Serve(lis); err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"failed to serve: %v"</span>, err)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> UnaryServerInterceptor(ctx context.Context, req <span class="keyword">interface</span>{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (<span class="keyword">interface</span>{}, error) {</div><div class="line">	log.Printf(<span class="string">"before handling. Info: %+v"</span>, info)</div><div class="line">	resp, err := handler(ctx, req)</div><div class="line">	log.Printf(<span class="string">"after handling. resp: %+v"</span>, resp)</div><div class="line">	<span class="keyword">return</span> resp, err</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// StreamServerInterceptor is a gRPC server-side interceptor that provides Prometheus monitoring for Streaming RPCs.</span></div><div class="line"><span class="keyword">func</span> StreamServerInterceptor(srv <span class="keyword">interface</span>{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {</div><div class="line">	log.Printf(<span class="string">"before handling. Info: %+v"</span>, info)</div><div class="line">	err := handler(srv, ss)</div><div class="line">	log.Printf(<span class="string">"after handling. err: %v"</span>, err)</div><div class="line">	<span class="keyword">return</span> err</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>grpc.NewServer</code>可以将拦截器作为参数传入，在提供服务的时候，我们可以看到拦截器打印出log:</p>
<figure class="highlight log"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017</span>/<span class="number">04</span>/<span class="number">17</span> <span class="number">23</span><span class="symbol">:</span><span class="number">34</span><span class="symbol">:</span><span class="number">20</span> before handling. <span class="constant">Info</span><span class="symbol">:</span> &{<span class="constant">Server</span><span class="symbol">:</span><span class="number">0x17309c8</span> <span class="constant">FullMethod</span><span class="symbol">:/pb</span>.<span class="constant">Greeter</span>/<span class="constant">SayHello</span>}</div><div class="line"><span class="number">2017</span>/<span class="number">04</span>/<span class="number">17</span> <span class="number">23</span><span class="symbol">:</span><span class="number">34</span><span class="symbol">:</span><span class="number">20</span> after handling. <span class="symbol">resp:</span> &<span class="constant">HelloReply</span>{<span class="constant">Message</span><span class="symbol">:Hello</span> world,}</div></pre></td></tr></table></figure>

<p><strong>客户端的拦截器</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="comment">//"context"</span></div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line"></div><div class="line">	<span class="string">"golang.org/x/net/context"</span></div><div class="line"></div><div class="line">	pb <span class="string">"github.com/smallnest/grpc/a/pb"</span></div><div class="line">	<span class="string">"google.golang.org/grpc"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	address = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:8972"</span>, <span class="string">"address"</span>)</div><div class="line">	name    = flag.String(<span class="string">"n"</span>, <span class="string">"world"</span>, <span class="string">"name"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	<span class="comment">// 连接服务器</span></div><div class="line">	conn, err := grpc.Dial(*address, grpc.WithInsecure(), grpc.WithUnaryInterceptor(UnaryClientInterceptor),</div><div class="line">		grpc.WithStreamInterceptor(StreamClientInterceptor))</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"faild to connect: %v"</span>, err)</div><div class="line">	}</div><div class="line">	<span class="keyword">defer</span> conn.Close()</div><div class="line"></div><div class="line">	c := pb.NewGreeterClient(conn)</div><div class="line"></div><div class="line">	r, err := c.SayHello(context.Background(), &pb.HelloRequest{Name: *name})</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"could not greet: %v"</span>, err)</div><div class="line">	}</div><div class="line">	log.Printf(<span class="string">"Greeting: %s"</span>, r.Message)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> UnaryClientInterceptor(ctx context.Context, method <span class="typename">string</span>, req, reply <span class="keyword">interface</span>{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {</div><div class="line">	log.Printf(<span class="string">"before invoker. method: %+v, request:%+v"</span>, method, req)</div><div class="line">	err := invoker(ctx, method, req, reply, cc, opts...)</div><div class="line">	log.Printf(<span class="string">"after invoker. reply: %+v"</span>, reply)</div><div class="line">	<span class="keyword">return</span> err</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> StreamClientInterceptor(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method <span class="typename">string</span>, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) {</div><div class="line">	log.Printf(<span class="string">"before invoker. method: %+v, StreamDesc:%+v"</span>, method, desc)</div><div class="line">	clientStream, err := streamer(ctx, desc, cc, method, opts...)</div><div class="line">	log.Printf(<span class="string">"before invoker. method: %+v"</span>, method)</div><div class="line">	<span class="keyword">return</span> clientStream, err</div><div class="line">}</div></pre></td></tr></table></figure>

<p>通过<code>grpc.WithUnaryInterceptor</code>、<code>grpc.WithStreamInterceptor</code>可以将拦截器传递给<code>Dial</code>做参数。在客户端调用的时候，可以查看拦截器输出的日志:</p>
<figure class="highlight log"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017</span>/<span class="number">04</span>/<span class="number">17</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">20</span> before invoker. <span class="function"><span class="keyword">method</span>:</span> /pb.Greeter/SayHello, request:&HelloRequest<span class="comment">{Name:world,}</span></div><div class="line"><span class="number">2017</span>/<span class="number">04</span>/<span class="number">17</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">20</span> after invoker. reply: &HelloReply<span class="comment">{Message:Hello world,}</span></div><div class="line"><span class="number">2017</span>/<span class="number">04</span>/<span class="number">17</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">20</span> Greeting: Hello world</div></pre></td></tr></table></figure>

<p>通过这个简单的例子，你可以很容易的了解拦截器的开发。unary和stream两种类型的拦截器可以根据你的gRPC server/client实现的不同，有选择的实现。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>gRPC-Go 增加了拦截器(interceptor)的功能， 就像Java Servlet中的 filter一样，可以对RPC的请求和响应进行拦截处理，而且既可以在客户端进行拦截，也可以对服务器端进行拦截。</p>
<p>利用拦截器，可以对gRPC进行扩展，利用社区的力量将gRPC发展壮大，也可以让开发者更灵活地处理gRPC流程中的业务逻辑。下面列出了利用拦截器实现的一些功能框架：<br>]]>
    
    </summary>
    
      <category term="gRPC" scheme="http://colobu.com/tags/gRPC/"/>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go Web 框架性能比拼 2017 春季版]]></title>
    <link href="http://colobu.com/2017/04/07/go-webframework-benchmark-2017-Spring/"/>
    <id>http://colobu.com/2017/04/07/go-webframework-benchmark-2017-Spring/</id>
    <published>2017-04-07T05:04:22.000Z</published>
    <updated>2017-04-17T02:05:28.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://colobu.com/2016/04/06/the-fastest-golang-web-framework/" target="_blank" rel="external">谁是最快的Go Web框架?</a>, 这是我去年发布的Go web 框架的评测。现在一年过去了，有些框架因为缺乏维护而被放弃了，又有新的轮子被创造出来，既有的轮子也在不停的演化升级，来去之间，Go的版本也已经升级的1.8了。 青年节前， <a href="https://github.com/kirillDanshin" target="_blank" rel="external">kirillDanshin</a>提了一个issue,希望能更新最新的测试结果，现在这篇文章就记录了最新的测试结果。</p>
<a id="more"></a>
<p><strong>测试环境</strong></p>
<ul>
<li>CPU:      Intel(R) Xeon(R) CPU E5-2630 v3 @ 2.40GHz, 32 cores</li>
<li>Memory:   32G</li>
<li>Go:       1.8.0</li>
<li>OS:       CentOS 7 / 3.10.0-229.el7.x86_64</li>
</ul>
<p>所有的评测的 web 框架都已经更新到 2017-04-01 的最新版本。</p>
<p><strong>说明</strong><br>Julien Schmidt实现的 <a href="https://github.com/julienschmidt/go-http-routing-benchmark" target="_blank" rel="external">go-http-routing-benchmark</a> 是对 router的一个评测，但是作为完整的web框架，从接收用户请求到发送给客户端／浏览器，中间会经过多个组件的处理， router的性能影响到底在整体的web请求处理中影像多大呢？看测试结果。</p>
<p>本项目的代码在 <a href="https://github.com/smallnest/go-web-framework-benchmark" target="_blank" rel="external">go-web-framework-benchmark</a>, 你可以查看，也欢迎提 pull request。</p>
<p>测试中的 <strong>gear</strong> 测试代码有问题，没有加上router中间件， 你可以在这次测试中忽略它的benchmark。参看 <a href="https://github.com/smallnest/go-web-framework-benchmark/pull/33" target="_blank" rel="external"># 33</a></p>
<h3 id="模拟业务不同的处理时间框架的性能">模拟业务不同的处理时间框架的性能</h3>
<p>使用 5000 个客户端模拟请求，比较各web框架在不同的处理时间下的性能。</p>
<h4 id="1、0ms">1、0ms</h4>
<p><code>0ms</code>模拟理想的业务处理。在这种处理时间下， 每个请求基本只耗费小于1毫秒的处理时间，这是理想的极端的情况，比如访问内存中缓存的对象就返回。 </p>
<p><img src="benchmark.png" alt="吞吐率"></p>
<p><img src="benchmark_latency.png" alt="延迟"></p>
<p><img src="benchmark_alloc.png" alt="对象分配"></p>
<h4 id="2、10ms">2、10ms</h4>
<p><code>10ms</code>模拟比较好的业务处理。在这种情况下，服务器只需在极短的情况下(10ms)处理完请求，如果业务不是太复杂，没有访问本地磁盘、数据库或者其它远程服务的情况下，比较符合这种测试。</p>
<p><img src="benchmark10.png" alt="吞吐率"></p>
<p><img src="benchmark_latency10.png" alt="延迟"></p>
<p><img src="benchmark_alloc10.png" alt="对象分配"></p>
<h4 id="3、100ms">3、100ms</h4>
<p><code>100ms</code>模拟一般的业务处理。一般接收请求后，可能访问本地磁盘上的文件、数据库或者调用一个或多个远程服务，在这种情况下，完成一次请求可能要花费较少的时间。</p>
<p><img src="benchmark100.png" alt="吞吐率"></p>
<p><img src="benchmark_latency100.png" alt="延迟"></p>
<p><img src="benchmark_alloc100.png" alt="对象分配"></p>
<h3 id="pipelining">pipelining</h3>
<p>这个测试是模拟在 <a href="https://en.wikipedia.org/wiki/HTTP_pipelining" target="_blank" rel="external">pipelining</a> 情况下 web 框架的表现。</p>
<p>HTTP管线化（HTTP pipelining）是将多个HTTP请求（request）整批提交的技术，而在发送过程中不需先等待服务端的回应。<br>请求结果管线化使得 HTML 网页加载时间动态提升，特别是在具体有高延迟的连接环境下，如卫星上网。在宽带连接中，加速不是那么显著的，因为需要服务器端应用 HTTP/1.1 协议:服务器端必须按照客户端的请求顺序恢复请求，这样整个连接还是先进先出的，对头阻塞（HOL blocking）可能会发生，造成延迟。未来的 HTTP/2.0 或者SPDY中的异步操作将会解决这个问题。因为它可能将多个 HTTP 请求填充在一个TCP数据包内，HTTP 管线化需要在网络上传输较少的 TCP 数据包，减少了网络负载。</p>
<p><img src="pipelining.png" alt="来自 wikipedia"></p>
<p>下图是使用 5000 客户端 测试不同的处理时间的性能比较图。</p>
<p><img src="benchmark-pipeline.png" alt=""></p>
<h3 id="并发">并发</h3>
<p>下面这组测试是在业务处理时间限定在<code>30ms</code>的情况下， 使用100、1000、5000的并发client的吞吐情况。</p>
<h4 id="1、100并发">1、100并发</h4>
<p><img src="concurrency100.png" alt="吞吐率"></p>
<p><img src="concurrency_latency100.png" alt="延迟"></p>
<h4 id="2、1000并发">2、1000并发</h4>
<p><img src="concurrency1000.png" alt="吞吐率"></p>
<p><img src="concurrency_latency1000.png" alt="延迟"></p>
<h4 id="3、5000并发">3、5000并发</h4>
<p><img src="concurrency5000.png" alt="吞吐率"></p>
<p><img src="concurrency_latency5000.png" alt="延迟"></p>
<h3 id="总结">总结</h3>
<p>Go Web框架目前已经非常多了，不断的有人造轮子，这是Go Web的设计简单易扩展有关。如果我觉得官方的路由不方便，我就可以很容易的再造一个轮子，这也是go web 框架／router泛滥的缘故， 以至于有人呼吁不要再早轮子了。</p>
<p>从目前既有的web框架看，根据框架的低层看，可以分为两类。一类是基于官方 <code>net/http</code>标准库开发的web框架，一类是基于<code>fasthttp</code>开发的标准库框架。很明显基于<code>fasthttp</code>有更好的性能，但是这类框架也有它们的缺点，不完全支持HTTP协议，比如不支持<code>HEAD</code>，不支持 HTTP2， 各有优缺点，如何选择交给使用者，结合自己实际的情况来选择。比如Echo框架，在最新版中就把对<code>fasthttp</code>的支持去掉了。</p>
<p>另外，julienschmidt的<a href="https://github.com/julienschmidt/httprouter" target="_blank" rel="external">httprouter</a>有着良好的性能，这也是很几个web框架的路由器使用它的原因。</p>
<p>为什么没有关注量很高<a href="https://github.com/kataras/iris" target="_blank" rel="external">iris</a>？这是一个复杂而又有争议的问题，参照<a href="https://github.com/smallnest/go-web-framework-benchmark/issues/29" target="_blank" rel="external">issue #29</a>、<a href="https://github.com/smallnest/go-web-framework-benchmark/pull/16" target="_blank" rel="external">issue #16</a>， 暂时把iris去掉了。</p>
<p>测试代码和最新结果都在 <a href="https://github.com/smallnest/go-web-framework-benchmark" target="_blank" rel="external">go-web-framework-benchmark</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://colobu.com/2016/04/06/the-fastest-golang-web-framework/" target="_blank" rel="external">谁是最快的Go Web框架?</a>, 这是我去年发布的Go web 框架的评测。现在一年过去了，有些框架因为缺乏维护而被放弃了，又有新的轮子被创造出来，既有的轮子也在不停的演化升级，来去之间，Go的版本也已经升级的1.8了。 青年节前， <a href="https://github.com/kirillDanshin" target="_blank" rel="external">kirillDanshin</a>提了一个issue,希望能更新最新的测试结果，现在这篇文章就记录了最新的测试结果。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gRPC的那些事 - streaming]]></title>
    <link href="http://colobu.com/2017/04/06/dive-into-gRPC-streaming/"/>
    <id>http://colobu.com/2017/04/06/dive-into-gRPC-streaming/</id>
    <published>2017-04-06T03:40:26.000Z</published>
    <updated>2017-04-17T04:44:11.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.grpc.io" target="_blank" rel="external">gRPC</a>是一个高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。 gRPC提供了一种简单的方法来精确地定义服务和为iOS、Android和后台支持服务自动生成可靠性很强的客户端功能库。 客户端充分利用高级流和链接功能，从而有助于节省带宽、降低的TCP链接次数、节省CPU使用、和电池寿命。</p>
<p>gRPC具有以下重要特征：<br>强大的IDL特性 RPC使用ProtoBuf来定义服务，ProtoBuf是由Google开发的一种数据序列化协议，性能出众，得到了广泛的应用。<br>支持多种语言 支持C++、Java、Go、Python、Ruby、C#、Node.js、Android Java、Objective-C、PHP等编程语言。 3.基于HTTP/2标准设计</p>
<p><img src="/2017/04/06/dive-into-gRPC-streaming/gRPC.png" alt=""></p>
<p>gRPC已经应用在Google的云服务和对外提供的API中。</p>
<p>gRPC开发起来非常的简单，你可以阅读 一个 <a href="https://github.com/smallnest/grpc-examples/tree/master/helloworld" target="_blank" rel="external">helloworld 的例子</a>来了解它的基本开发流程 (本系列文章以Go语言的开发为例)。</p>
<p>最基本的开发步骤是定义 <code>proto</code> 文件， 定义请求 Request 和 响应 Response 的格式，然后定义一个服务 Service， Service可以包含多个方法。</p>
<p>基本的gRPC开发很多文章都介绍过了，官方也有相关的文档，这个系列的文章也就不介绍这些基础的开发，而是想通过代码演示gRPC更深入的开发。 作为这个系列的第一篇文章，想和大家分享一下gRPC流式开发的知识。</p>
<p>gRPC的流可以分为三类， 客户端流式发送、服务器流式返回以及客户端／服务器同时流式处理, 也就是单向流和双向流。 下面针对这三种情况分别通过例子介绍。</p>
<a id="more"></a>
<h3 id="服务器流式响应">服务器流式响应</h3>
<p>通过使用流(streaming)，你可以向服务器或者客户端发送批量的数据， 服务器和客户端在接收这些数据的时候，可以不必等所有的消息全收到后才开始响应，而是接收到第一条消息的时候就可以及时的响应， 这显然比以前的类HTTP 1.1的方式更快的提供响应，从而提高性能。</p>
<p>比如有一批记录个人收入数据，客户端流式发送给服务器，服务器计算出每个人的个人所得税，将结果流式发给客户端。这样客户端的发送可以和服务器端的计算并行之行，从而减少服务的延迟。这只是一个简单的例子，你可以利用流来实现RPC调用的异步执行，将客户端的调用和服务器端的执行并行的处理，</p>
<p>当前gRPC通过 HTTP2 协议传输，可以方便的实现 streaming 功能。 如果你对gRPC如何通过 HTTP2 传输的感兴趣， 你可以阅读这篇文章 <a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md" target="_blank" rel="external">gRPC over HTTP2</a>, 它描述了 gRPC 通过 HTTP2 传输的低层格式。Request 和 Response 的格式如下：</p>
<ul>
<li>Request → Request-Headers *Length-Prefixed-Message EOS</li>
<li>Response → (Response-Headers *Length-Prefixed-Message Trailers) / Trailers-Only</li>
</ul>
<p>要实现服务器的流式响应，只需在<code>proto</code>中的方法定义中将响应前面加上<code>stream</code>标记， 如下图中<code>SayHello1</code>方法，<code>HelloReply</code>前面加上<code>stream</code>标识。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">syntax = "proto3";</div><div class="line"></div><div class="line">package pb;</div><div class="line"></div><div class="line">import "github.com/gogo/protobuf/gogoproto/gogo.proto";</div><div class="line"></div><div class="line">// The greeting service definition.</div><div class="line">service Greeter {</div><div class="line">  // Sends a greeting</div><div class="line">  rpc SayHello1 (HelloRequest) returns (stream HelloReply) {}</div><div class="line">}</div><div class="line"></div><div class="line">// The request message containing the user's name.</div><div class="line">message HelloRequest {</div><div class="line">  string name = 1;</div><div class="line">}</div><div class="line"></div><div class="line">// The response message containing the greetings</div><div class="line">message HelloReply {</div><div class="line">  string message = 1;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个例子中我使用<a href="https://github.com/gogo/protobuf" target="_blank" rel="external">gogo</a>来生成更有效的protobuf代码，当然你也可以使用原生的工具生成。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GOGO_ROOT=<span class="variable">${GOPATH}</span>/src/github.com/gogo/protobuf</div><div class="line">protoc -I.:<span class="variable">${GOPATH}</span>/src  --gogofaster_out=plugins=grpc:. helloworld.proto</div></pre></td></tr></table></figure>

<p>生成的代码就已经包含了流的处理，所以和普通的gRPC代码差别不是很大， 只需要注意的服务器端代码的实现要通过流的方式发送响应。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (s *server) SayHello1(in *pb.HelloRequest, gs pb.Greeter_SayHello1Server) error {</div><div class="line">	name := in.Name</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 100</span>; i++ {</div><div class="line">		gs.Send(&pb.HelloReply{Message: <span class="string">"Hello "</span> + name + strconv.Itoa(i)})</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>和普通的gRPC有什么区别？</p>
<p>普通的gRPC是直接返回一个<code>HelloReply</code>对象，而流式响应你可以通过<code>Send</code>方法返回多个<code>HelloReply</code>对象，对象流序列化后流式返回。</p>
<p>查看它低层的实现其实是使用<code>ServerStream.SendMsg</code>实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Greeter_SayHello1Server <span class="keyword">interface</span> {</div><div class="line">	Send(*HelloReply) error</div><div class="line">	grpc.ServerStream</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">func</span> (x *greeterSayHello1Server) Send(m *HelloReply) error {</div><div class="line">	<span class="keyword">return</span> x.ServerStream.SendMsg(m)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>对于客户端，我们需要关注两个方面有没有变化， 一是发送请求，一是读取响应。下面是客户端的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">   conn, err := grpc.Dial(*address, grpc.WithInsecure())</div><div class="line">   <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">   	log.Fatalf(<span class="string">"faild to connect: %v"</span>, err)</div><div class="line">   }</div><div class="line">   <span class="keyword">defer</span> conn.Close()</div><div class="line"></div><div class="line">   c := pb.NewGreeterClient(conn)</div><div class="line"></div><div class="line">stream, err := c.SayHello1(context.Background(), &pb.HelloRequest{Name: *name})</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	log.Fatalf(<span class="string">"could not greet: %v"</span>, err)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> {</div><div class="line">	reply, err := stream.Recv()</div><div class="line">	<span class="keyword">if</span> err == io.EOF {</div><div class="line">		<span class="keyword">break</span></div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Printf(<span class="string">"failed to recv: %v"</span>, err)</div><div class="line">	}</div><div class="line"></div><div class="line">	log.Printf(<span class="string">"Greeting: %s"</span>, reply.Message)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>发送请求看起来没有太大的区别，只是返回结果不再是一个单一的<code>HelloReply</code>对象，而是一个<code>Stream</code>。这和服务器端代码正好对应，通过调用<code>stream.Recv()</code>返回每一个<code>HelloReply</code>对象， 直到出错或者流结束(io.EOF)。</p>
<p>可以看出，生成的代码提供了往/从流中方便的发送／读取对象的能力，而这一切， gRPC都帮你生成好了。</p>
<h3 id="客户端流式发送">客户端流式发送</h3>
<p>客户端也可以流式的发送对象，当然这些对象也和上面的一样，都是同一类型的对象。</p>
<p>首先还是要在<code>proto</code>文件中定义，与上面的定义类似，在请求的前面加上<code>stream</code>标识。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">syntax = "proto3";</div><div class="line"></div><div class="line">package pb;</div><div class="line"></div><div class="line">import "github.com/gogo/protobuf/gogoproto/gogo.proto";</div><div class="line">option (gogoproto.unmarshaler_all) = true;</div><div class="line"></div><div class="line"></div><div class="line">// The greeting service definition.</div><div class="line">service Greeter {</div><div class="line">  rpc SayHello2 (stream HelloRequest) returns (HelloReply) {}</div><div class="line">}</div><div class="line"></div><div class="line">// The request message containing the user's name.</div><div class="line">message HelloRequest {</div><div class="line">  string name = 1;</div><div class="line">}</div><div class="line"></div><div class="line">// The response message containing the greetings</div><div class="line">message HelloReply {</div><div class="line">  string message = 1;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意这里我们只标记了请求是流式的， 响应还是以前的样子。</p>
<p>生成相关的代码后， 客户端的代码为:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> sayHello2(c pb.GreeterClient) {</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	stream, err := c.SayHello2(context.Background())</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 100</span>; i++ {</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Printf(<span class="string">"failed to call: %v"</span>, err)</div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">		stream.Send(&pb.HelloRequest{Name: *name + strconv.Itoa(i)})</div><div class="line">	}</div><div class="line"></div><div class="line">	reply, err := stream.CloseAndRecv()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Printf(<span class="string">"failed to recv: %v"</span>, err)</div><div class="line">	}</div><div class="line"></div><div class="line">	log.Printf(<span class="string">"Greeting: %s"</span>, reply.Message)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里的调用<code>c.SayHello2</code>并没有直接穿入请求参数，而是返回一个<code>stream</code>，通过这个<code>stream</code>的<code>Send</code>发送，我们可以将对象流式发送。这个例子中我们发送了100个请求。 </p>
<p>客户端读取的方法是<code>stream.CloseAndRecv()</code>,读取完毕会关闭这个流的发送，这个方法返回最终结果。注意客户端只负责关闭流的发送。</p>
<p>服务器端的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (s *server) SayHello2(gs pb.Greeter_SayHello2Server) error {</div><div class="line">	<span class="keyword">var</span> names []<span class="typename">string</span></div><div class="line"></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		in, err := gs.Recv()</div><div class="line">		<span class="keyword">if</span> err == io.EOF {</div><div class="line">			gs.SendAndClose(&pb.HelloReply{Message: <span class="string">"Hello "</span> + strings.Join(names, <span class="string">","</span>)})</div><div class="line">			<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Printf(<span class="string">"failed to recv: %v"</span>, err)</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		}</div><div class="line">		names = <span class="built_in">append</span>(names, in.Name)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>服务器端收到每条消息都进行了处理，这里的处理简化为增加到一个slice中。一旦它检测的客户端关闭了流的发送，它则把最终结果发送给客户端，通过关闭这个流。流的关闭通过<code>io.EOF</code>这个error来区分。</p>
<h3 id="双向流">双向流</h3>
<p>将上面两个例子整合，就是双向流的例子。 客户端流式发送，服务器端流式响应，所有的发送和读取都是流式处理的。</p>
<p><code>proto</code>中的定义如下, 请求和响应的前面都加上了<code>stream</code>标识:</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">syntax = "proto3";</div><div class="line"></div><div class="line">package pb;</div><div class="line"></div><div class="line">import "github.com/gogo/protobuf/gogoproto/gogo.proto";</div><div class="line"></div><div class="line"></div><div class="line">// The greeting service definition.</div><div class="line">service Greeter {</div><div class="line">  rpc SayHello3 (stream HelloRequest) returns (stream HelloReply) {}</div><div class="line">}</div><div class="line"></div><div class="line">// The request message containing the user's name.</div><div class="line">message HelloRequest {</div><div class="line">  string name = 1;</div><div class="line">}</div><div class="line"></div><div class="line">// The response message containing the greetings</div><div class="line">message HelloReply {</div><div class="line">  string message = 1;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>客户端的代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> sayHello3(c pb.GreeterClient) {</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line"></div><div class="line">	stream, err := c.SayHello3(context.Background())</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Printf(<span class="string">"failed to call: %v"</span>, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">var</span> i <span class="typename">int64</span></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		stream.Send(&pb.HelloRequest{Name: *name + strconv.FormatInt(i,<span class="number"> 10</span>)})</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Printf(<span class="string">"failed to send: %v"</span>, err)</div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">		reply, err := stream.Recv()</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Printf(<span class="string">"failed to recv: %v"</span>, err)</div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">		log.Printf(<span class="string">"Greeting: %s"</span>, reply.Message)</div><div class="line">		i++</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>通过<code>stream.Send</code>发送请求，通过<code>stream.Recv</code>读取响应。客户端可以通过<code>CloseSend</code>方法关闭发送流。</p>
<p>服务器端代码也是通过<code>Send</code>发送响应，通过<code>Recv</code>响应:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (s *server) SayHello3(gs pb.Greeter_SayHello3Server) error {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		in, err := gs.Recv()</div><div class="line">		<span class="keyword">if</span> err == io.EOF {</div><div class="line">			<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Printf(<span class="string">"failed to recv: %v"</span>, err)</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		}</div><div class="line"></div><div class="line">		gs.Send(&pb.HelloReply{Message: <span class="string">"Hello "</span> + in.Name})</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这基本上&quot;退化&quot;成一个TCP的client和server的架构。</p>
<p>在实际的应用中，你可以根据你的场景来使用单向流还是双向流。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.grpc.io" target="_blank" rel="external">gRPC</a>是一个高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。 gRPC提供了一种简单的方法来精确地定义服务和为iOS、Android和后台支持服务自动生成可靠性很强的客户端功能库。 客户端充分利用高级流和链接功能，从而有助于节省带宽、降低的TCP链接次数、节省CPU使用、和电池寿命。</p>
<p>gRPC具有以下重要特征：<br>强大的IDL特性 RPC使用ProtoBuf来定义服务，ProtoBuf是由Google开发的一种数据序列化协议，性能出众，得到了广泛的应用。<br>支持多种语言 支持C++、Java、Go、Python、Ruby、C#、Node.js、Android Java、Objective-C、PHP等编程语言。 3.基于HTTP/2标准设计</p>
<p><img src="/2017/04/06/dive-into-gRPC-streaming/gRPC.png" alt=""></p>
<p>gRPC已经应用在Google的云服务和对外提供的API中。</p>
<p>gRPC开发起来非常的简单，你可以阅读 一个 <a href="https://github.com/smallnest/grpc-examples/tree/master/helloworld" target="_blank" rel="external">helloworld 的例子</a>来了解它的基本开发流程 (本系列文章以Go语言的开发为例)。</p>
<p>最基本的开发步骤是定义 <code>proto</code> 文件， 定义请求 Request 和 响应 Response 的格式，然后定义一个服务 Service， Service可以包含多个方法。</p>
<p>基本的gRPC开发很多文章都介绍过了，官方也有相关的文档，这个系列的文章也就不介绍这些基础的开发，而是想通过代码演示gRPC更深入的开发。 作为这个系列的第一篇文章，想和大家分享一下gRPC流式开发的知识。</p>
<p>gRPC的流可以分为三类， 客户端流式发送、服务器流式返回以及客户端／服务器同时流式处理, 也就是单向流和双向流。 下面针对这三种情况分别通过例子介绍。</p>
]]>
    
    </summary>
    
      <category term="gRPC" scheme="http://colobu.com/tags/gRPC/"/>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]gRPC服务发现&负载均衡]]></title>
    <link href="http://colobu.com/2017/03/25/grpc-naming-and-load-balance/"/>
    <id>http://colobu.com/2017/03/25/grpc-naming-and-load-balance/</id>
    <published>2017-03-25T15:26:42.000Z</published>
    <updated>2017-04-05T08:06:34.000Z</updated>
    <content type="html"><![CDATA[<p>原文出处: <a href="https://segmentfault.com/a/1190000008672912" target="_blank" rel="external">gRPC服务发现&amp;负载均衡</a>, 作者: <a href="https://segmentfault.com/u/softfn" target="_blank" rel="external">softfn</a>。</p>
<p>构建高可用、高性能的通信服务，通常采用服务注册与发现、负载均衡和容错处理等机制实现。根据负载均衡实现所在的位置不同，通常可分为以下三种解决方案：</p>
<a id="more"></a>
<h4 id="1、集中式LB（Proxy_Model）">1、集中式LB（Proxy Model）</h4>
<p><img src="1.png" alt=""></p>
<p>在服务消费者和服务提供者之间有一个独立的LB，通常是专门的硬件设备如 F5，或者基于软件如 LVS，HAproxy等实现。LB上有所有服务的地址映射表，通常由运维配置注册，当服务消费方调用某个目标服务时，它向LB发起请求，由LB以某种策略，比如轮询（Round-Robin）做负载均衡后将请求转发到目标服务。LB一般具备健康检查能力，能自动摘除不健康的服务实例。 该方案主要问题：</p>
<ol>
<li>单点问题，所有服务调用流量都经过LB，当服务数量和调用量大的时候，LB容易成为瓶颈，且一旦LB发生故障影响整个系统；</li>
<li>服务消费方、提供方之间增加了一级，有一定性能开销。</li>
</ol>
<h4 id="2、进程内LB（Balancing-aware_Client）">2、进程内LB（Balancing-aware Client）</h4>
<p><img src="2.png" alt=""></p>
<p>针对第一个方案的不足，此方案将LB的功能集成到服务消费方进程里，也被称为软负载或者客户端负载方案。服务提供方启动时，首先将服务地址注册到服务注册表，同时定期报心跳到服务注册表以表明服务的存活状态，相当于健康检查，服务消费方要访问某个服务时，它通过内置的LB组件向服务注册表查询，同时缓存并定期刷新目标服务地址列表，然后以某种负载均衡策略选择一个目标服务地址，最后向目标服务发起请求。LB和服务发现能力被分散到每一个服务消费者的进程内部，同时服务消费方和服务提供方之间是直接调用，没有额外开销，性能比较好。该方案主要问题：</p>
<ol>
<li>开发成本，该方案将服务调用方集成到客户端的进程里头，如果有多种不同的语言栈，就要配合开发多种不同的客户端，有一定的研发和维护成本；</li>
<li>另外生产环境中，后续如果要对客户库进行升级，势必要求服务调用方修改代码并重新发布，升级较复杂。</li>
</ol>
<h4 id="3、独立_LB_进程（External_Load_Balancing_Service）">3、独立 LB 进程（External Load Balancing Service）</h4>
<p><img src="3.png" alt=""></p>
<p>该方案是针对第二种方案的不足而提出的一种折中方案，原理和第二种方案基本类似。<br>不同之处是将LB和服务发现功能从进程内移出来，变成主机上的一个独立进程。主机上的一个或者多个服务要访问目标服务时，他们都通过同一主机上的独立LB进程做服务发现和负载均衡。该方案也是一种分布式方案没有单点问题，一个LB进程挂了只影响该主机上的服务调用方，服务调用方和LB之间是进程内调用性能好，同时该方案还简化了服务调用方，不需要为不同语言开发客户库，LB的升级不需要服务调用方改代码。<br>该方案主要问题：部署较复杂，环节多，出错调试排查问题不方便。</p>
<h4 id="gRPC服务发现及负载均衡实现">gRPC服务发现及负载均衡实现</h4>
<p>gRPC开源组件官方并未直接提供服务注册与发现的功能实现，但其设计文档已提供实现的思路，并在不同语言的gRPC代码API中已提供了命名解析和负载均衡接口供扩展。</p>
<p><img src="4.png" alt=""></p>
<p>其基本实现原理：</p>
<ol>
<li>服务启动后gRPC客户端向命名服务器发出名称解析请求，名称将解析为一个或多个IP地址，每个IP地址标示它是服务器地址还是负载均衡器地址，以及标示要使用那个客户端负载均衡策略或服务配置。</li>
<li>客户端实例化负载均衡策略，如果解析返回的地址是负载均衡器地址，则客户端将使用grpclb策略，否则客户端使用服务配置请求的负载均衡策略。</li>
<li>负载均衡策略为每个服务器地址创建一个子通道（channel）。</li>
<li>当有rpc请求时，负载均衡策略决定那个子通道即grpc服务器将接收请求，当可用服务器为空时客户端的请求将被阻塞。</li>
</ol>
<p>根据gRPC官方提供的设计思路，基于进程内LB方案（即第2个案，阿里开源的服务框架 Dubbo 也是采用类似机制），结合分布式一致的组件（如Zookeeper、Consul、Etcd），可找到gRPC服务发现和负载均衡的可行解决方案。接下来以GO语言为例，简单介绍下基于Etcd3的关键代码实现：</p>
<h5 id="1）命名解析实现：resolver-go">1）命名解析实现：resolver.go</h5>
<figure class="highlight go"><figcaption><span>resolver.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> etcdv3</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"errors"</span></div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"strings"</span></div><div class="line"></div><div class="line">    etcd3 <span class="string">"github.com/coreos/etcd/clientv3"</span></div><div class="line">    <span class="string">"google.golang.org/grpc/naming"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// resolver is the implementaion of grpc.naming.Resolver</span></div><div class="line"><span class="keyword">type</span> resolver <span class="keyword">struct</span> {</div><div class="line">    serviceName <span class="typename">string</span> <span class="comment">// service name to resolve</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// NewResolver return resolver with service name</span></div><div class="line"><span class="keyword">func</span> NewResolver(serviceName <span class="typename">string</span>) *resolver {</div><div class="line">    <span class="keyword">return</span> &resolver{serviceName: serviceName}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Resolve to resolve the service from etcd, target is the dial address of etcd</span></div><div class="line"><span class="comment">// target example: "http://127.0.0.1:2379,http://127.0.0.1:12379,http://127.0.0.1:22379"</span></div><div class="line"><span class="keyword">func</span> (re *resolver) Resolve(target <span class="typename">string</span>) (naming.Watcher, error) {</div><div class="line">    <span class="keyword">if</span> re.serviceName == <span class="string">""</span> {</div><div class="line">        <span class="keyword">return</span> <span class="constant">nil</span>, errors.New(<span class="string">"grpclb: no service name provided"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// generate etcd client</span></div><div class="line">    client, err := etcd3.New(etcd3.Config{</div><div class="line">        Endpoints: strings.Split(target, <span class="string">","</span>),</div><div class="line">    })</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span> <span class="constant">nil</span>, fmt.Errorf(<span class="string">"grpclb: creat etcd3 client failed: %s"</span>, err.Error())</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Return watcher</span></div><div class="line">    <span class="keyword">return</span> &watcher{re: re, client: *client}, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h5 id="2）服务发现实现：watcher-go">2）服务发现实现：watcher.go</h5>
<figure class="highlight go"><figcaption><span>watcher.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> etcdv3</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    etcd3 <span class="string">"github.com/coreos/etcd/clientv3"</span></div><div class="line">    <span class="string">"golang.org/x/net/context"</span></div><div class="line">    <span class="string">"google.golang.org/grpc/naming"</span></div><div class="line">    <span class="string">"github.com/coreos/etcd/mvcc/mvccpb"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// watcher is the implementaion of grpc.naming.Watcher</span></div><div class="line"><span class="keyword">type</span> watcher <span class="keyword">struct</span> {</div><div class="line">    re            *resolver <span class="comment">// re: Etcd Resolver</span></div><div class="line">    client        etcd3.Client</div><div class="line">    isInitialized <span class="typename">bool</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Close do nothing</span></div><div class="line"><span class="keyword">func</span> (w *watcher) Close() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Next to return the updates</span></div><div class="line"><span class="keyword">func</span> (w *watcher) Next() ([]*naming.Update, error) {</div><div class="line">    <span class="comment">// prefix is the etcd prefix/value to watch</span></div><div class="line">    prefix := fmt.Sprintf(<span class="string">"/%s/%s/"</span>, Prefix, w.re.serviceName)</div><div class="line"></div><div class="line">    <span class="comment">// check if is initialized</span></div><div class="line">    <span class="keyword">if</span> !w.isInitialized {</div><div class="line">        <span class="comment">// query addresses from etcd</span></div><div class="line">        resp, err := w.client.Get(context.Background(), prefix, etcd3.WithPrefix())</div><div class="line">        w.isInitialized = <span class="constant">true</span></div><div class="line">        <span class="keyword">if</span> err == <span class="constant">nil</span> {</div><div class="line">            addrs := extractAddrs(resp)</div><div class="line">            <span class="comment">//if not empty, return the updates or watcher new dir</span></div><div class="line">            <span class="keyword">if</span> l := <span class="built_in">len</span>(addrs); l !=<span class="number"> 0</span> {</div><div class="line">                updates := <span class="built_in">make</span>([]*naming.Update, l)</div><div class="line">                <span class="keyword">for</span> i := <span class="keyword">range</span> addrs {</div><div class="line">                    updates[i] = &naming.Update{Op: naming.Add, Addr: addrs[i]}</div><div class="line">                }</div><div class="line">                <span class="keyword">return</span> updates, <span class="constant">nil</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// generate etcd Watcher</span></div><div class="line">    rch := w.client.Watch(context.Background(), prefix, etcd3.WithPrefix())</div><div class="line">    <span class="keyword">for</span> wresp := <span class="keyword">range</span> rch {</div><div class="line">        <span class="keyword">for</span> _, ev := <span class="keyword">range</span> wresp.Events {</div><div class="line">            <span class="keyword">switch</span> ev.Type {</div><div class="line">            <span class="keyword">case</span> mvccpb.PUT:</div><div class="line">                <span class="keyword">return</span> []*naming.Update{ {Op: naming.Add, Addr: <span class="typename">string</span>(ev.Kv.Value)} }, <span class="constant">nil</span></div><div class="line">            <span class="keyword">case</span> mvccpb.DELETE:</div><div class="line">                <span class="keyword">return</span> []*naming.Update{ {Op: naming.Delete, Addr: <span class="typename">string</span>(ev.Kv.Value)} }, <span class="constant">nil</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="constant">nil</span>, <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> extractAddrs(resp *etcd3.GetResponse) []<span class="typename">string</span> {</div><div class="line">    addrs := []<span class="typename">string</span>{}</div><div class="line"></div><div class="line">    <span class="keyword">if</span> resp == <span class="constant">nil</span> || resp.Kvs == <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span> addrs</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> resp.Kvs {</div><div class="line">        <span class="keyword">if</span> v := resp.Kvs[i].Value; v != <span class="constant">nil</span> {</div><div class="line">            addrs = <span class="built_in">append</span>(addrs, <span class="typename">string</span>(v))</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> addrs</div><div class="line">}</div></pre></td></tr></table></figure>

<h5 id="3）服务注册实现：register-go">3）服务注册实现：register.go</h5>
<figure class="highlight go"><figcaption><span>register.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> etcdv3</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"strings"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line"></div><div class="line">    etcd3 <span class="string">"github.com/coreos/etcd/clientv3"</span></div><div class="line">    <span class="string">"golang.org/x/net/context"</span></div><div class="line">    <span class="string">"github.com/coreos/etcd/etcdserver/api/v3rpc/rpctypes"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Prefix should start and end with no slash</span></div><div class="line"><span class="keyword">var</span> Prefix = <span class="string">"etcd3_naming"</span></div><div class="line"><span class="keyword">var</span> client etcd3.Client</div><div class="line"><span class="keyword">var</span> serviceKey <span class="typename">string</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> stopSignal = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">bool</span>,<span class="number"> 1</span>)</div><div class="line"></div><div class="line"><span class="comment">// Register</span></div><div class="line"><span class="keyword">func</span> Register(name <span class="typename">string</span>, host <span class="typename">string</span>, port <span class="typename">int</span>, target <span class="typename">string</span>, interval time.Duration, ttl <span class="typename">int</span>) error {</div><div class="line">    serviceValue := fmt.Sprintf(<span class="string">"%s:%d"</span>, host, port)</div><div class="line">    serviceKey = fmt.Sprintf(<span class="string">"/%s/%s/%s"</span>, Prefix, name, serviceValue)</div><div class="line"></div><div class="line">    <span class="comment">// get endpoints for register dial address</span></div><div class="line">    <span class="keyword">var</span> err error</div><div class="line">    client, err := etcd3.New(etcd3.Config{</div><div class="line">        Endpoints: strings.Split(target, <span class="string">","</span>),</div><div class="line">    })</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"grpclb: create etcd3 client failed: %v"</span>, err)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">        <span class="comment">// invoke self-register with ticker</span></div><div class="line">        ticker := time.NewTicker(interval)</div><div class="line">        <span class="keyword">for</span> {</div><div class="line">            <span class="comment">// minimum lease TTL is ttl-second</span></div><div class="line">            resp, _ := client.Grant(context.TODO(), <span class="typename">int64</span>(ttl))</div><div class="line">            <span class="comment">// should get first, if not exist, set it</span></div><div class="line">            _, err := client.Get(context.Background(), serviceKey)</div><div class="line">            <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">                <span class="keyword">if</span> err == rpctypes.ErrKeyNotFound {</div><div class="line">                    <span class="keyword">if</span> _, err := client.Put(context.TODO(), serviceKey, serviceValue, etcd3.WithLease(resp.ID)); err != <span class="constant">nil</span> {</div><div class="line">                        log.Printf(<span class="string">"grpclb: set service '%s' with ttl to etcd3 failed: %s"</span>, name, err.Error())</div><div class="line">                    }</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    log.Printf(<span class="string">"grpclb: service '%s' connect to etcd3 failed: %s"</span>, name, err.Error())</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// refresh set to true for not notifying the watcher</span></div><div class="line">                <span class="keyword">if</span> _, err := client.Put(context.Background(), serviceKey, serviceValue, etcd3.WithLease(resp.ID)); err != <span class="constant">nil</span> {</div><div class="line">                    log.Printf(<span class="string">"grpclb: refresh service '%s' with ttl to etcd3 failed: %s"</span>, name, err.Error())</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keyword">select</span> {</div><div class="line">            <span class="keyword">case</span> &lt;-stopSignal:</div><div class="line">                <span class="keyword">return</span></div><div class="line">            <span class="keyword">case</span> &lt;-ticker.C:</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }()</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// UnRegister delete registered service from etcd</span></div><div class="line"><span class="keyword">func</span> UnRegister() error {</div><div class="line">    stopSignal &lt;- <span class="constant">true</span></div><div class="line">    stopSignal = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">bool</span>,<span class="number"> 1</span>) <span class="comment">// just a hack to avoid multi UnRegister deadlock</span></div><div class="line">    <span class="keyword">var</span> err error;</div><div class="line">    <span class="keyword">if</span> _, err := client.Delete(context.Background(), serviceKey); err != <span class="constant">nil</span> {</div><div class="line">        log.Printf(<span class="string">"grpclb: deregister '%s' failed: %s"</span>, serviceKey, err.Error())</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        log.Printf(<span class="string">"grpclb: deregister '%s' ok."</span>, serviceKey)</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> err</div><div class="line">}</div></pre></td></tr></table></figure>

<h5 id="4）接口描述文件：helloworld-proto">4）接口描述文件：helloworld.proto</h5>
<figure class="highlight protobuf"><figcaption><span>helloworld.proto</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">syntax = "proto3";</div><div class="line"></div><div class="line">option java_multiple_files = true;</div><div class="line">option java_package = "com.midea.jr.test.grpc";</div><div class="line">option java_outer_classname = "HelloWorldProto";</div><div class="line">option objc_class_prefix = "HLW";</div><div class="line"></div><div class="line">package helloworld;</div><div class="line"></div><div class="line">// The greeting service definition.</div><div class="line">service Greeter {</div><div class="line">    //   Sends a greeting</div><div class="line">    rpc SayHello (HelloRequest) returns (HelloReply) {</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">// The request message containing the user's name.</div><div class="line">message HelloRequest {</div><div class="line">    string name = 1;</div><div class="line">}</div><div class="line"></div><div class="line">// The response message containing the greetings</div><div class="line">message HelloReply {</div><div class="line">    string message = 1;</div><div class="line">}</div></pre></td></tr></table></figure>

<h5 id="5）实现服务端接口：helloworldserver-go">5）实现服务端接口：helloworldserver.go</h5>
<figure class="highlight go"><figcaption><span>helloworldserver.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"flag"</span></div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"net"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line">    <span class="string">"os/signal"</span></div><div class="line">    <span class="string">"syscall"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line"></div><div class="line">    <span class="string">"golang.org/x/net/context"</span></div><div class="line">    <span class="string">"google.golang.org/grpc"</span></div><div class="line"></div><div class="line">    grpclb <span class="string">"com.midea/jr/grpclb/naming/etcd/v3"</span></div><div class="line">    <span class="string">"com.midea/jr/grpclb/example/pb"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    serv = flag.String(<span class="string">"service"</span>, <span class="string">"hello_service"</span>, <span class="string">"service name"</span>)</div><div class="line">    port = flag.Int(<span class="string">"port"</span>,<span class="number"> 50001</span>, <span class="string">"listening port"</span>)</div><div class="line">    reg = flag.String(<span class="string">"reg"</span>, <span class="string">"http://127.0.0.1:2379"</span>, <span class="string">"register etcd address"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    flag.Parse()</div><div class="line"></div><div class="line">    lis, err := net.Listen(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">"0.0.0.0:%d"</span>, *port))</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="built_in">panic</span>(err)</div><div class="line">    }</div><div class="line"></div><div class="line">    err = grpclb.Register(*serv, <span class="string">"127.0.0.1"</span>, *port, *reg, time.Second<span class="number">*10</span>,<span class="number"> 15</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="built_in">panic</span>(err)</div><div class="line">    }</div><div class="line"></div><div class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal,<span class="number"> 1</span>)</div><div class="line">    signal.Notify(ch, syscall.SIGTERM, syscall.SIGINT, syscall.SIGKILL, syscall.SIGHUP, syscall.SIGQUIT)</div><div class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">        s := &lt;-ch</div><div class="line">        log.Printf(<span class="string">"receive signal '%v'"</span>, s)</div><div class="line">        grpclb.UnRegister()</div><div class="line">        os.Exit<span class="number">(1</span>)</div><div class="line">    }()</div><div class="line"></div><div class="line">    log.Printf(<span class="string">"starting hello service at %d"</span>, *port)</div><div class="line">    s := grpc.NewServer()</div><div class="line">    pb.RegisterGreeterServer(s, &server{})</div><div class="line">    s.Serve(lis)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// server is used to implement helloworld.GreeterServer.</span></div><div class="line"><span class="keyword">type</span> server <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="comment">// SayHello implements helloworld.GreeterServer</span></div><div class="line"><span class="keyword">func</span> (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {</div><div class="line">    fmt.Printf(<span class="string">"%v: Receive is %s\n"</span>, time.Now(), in.Name)</div><div class="line">    <span class="keyword">return</span> &pb.HelloReply{Message: <span class="string">"Hello "</span> + in.Name}, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h5 id="6）实现客户端接口：helloworldclient-go">6）实现客户端接口：helloworldclient.go</h5>
<figure class="highlight go"><figcaption><span>helloworldclient.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"flag"</span></div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line"></div><div class="line">    grpclb <span class="string">"com.midea/jr/grpclb/naming/etcd/v3"</span></div><div class="line">    <span class="string">"com.midea/jr/grpclb/example/pb"</span></div><div class="line">    <span class="string">"golang.org/x/net/context"</span></div><div class="line">    <span class="string">"google.golang.org/grpc"</span></div><div class="line">    <span class="string">"strconv"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    serv = flag.String(<span class="string">"service"</span>, <span class="string">"hello_service"</span>, <span class="string">"service name"</span>)</div><div class="line">    reg = flag.String(<span class="string">"reg"</span>, <span class="string">"http://127.0.0.1:2379"</span>, <span class="string">"register etcd address"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    flag.Parse()</div><div class="line">    r := grpclb.NewResolver(*serv)</div><div class="line">    b := grpc.RoundRobin(r)</div><div class="line"></div><div class="line">    ctx, _ := context.WithTimeout(context.Background(),<span class="number"> 10</span>*time.Second)</div><div class="line">    conn, err := grpc.DialContext(ctx, *reg, grpc.WithInsecure(), grpc.WithBalancer(b))</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="built_in">panic</span>(err)</div><div class="line">    }</div><div class="line"></div><div class="line">    ticker := time.NewTicker<span class="number">(1</span> * time.Second)</div><div class="line">    <span class="keyword">for</span> t := <span class="keyword">range</span> ticker.C {</div><div class="line">        client := pb.NewGreeterClient(conn)</div><div class="line">        resp, err := client.SayHello(context.Background(), &pb.HelloRequest{Name: <span class="string">"world "</span> + strconv.Itoa(t.Second())})</div><div class="line">        <span class="keyword">if</span> err == <span class="constant">nil</span> {</div><div class="line">            fmt.Printf(<span class="string">"%v: Reply is %s\n"</span>, t, resp.Message)</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h5 id="7）运行测试">7）运行测试</h5>
<p>1、运行3个服务端S1、S2、S3，1个客户端C，观察各服务端接收的请求数是否相等？<br><img src="5.png" alt=""></p>
<p>2、关闭1个服务端S1，观察请求是否会转移到另外2个服务端？<br><img src="6.png" alt=""></p>
<p>3、重新启动S1服务端，观察另外2个服务端请求是否会平均分配到S1？<br><img src="7.png" alt=""><br><img src="8.png" alt=""></p>
<p>4、关闭Etcd3服务器，观察客户端与服务端通信是否正常？ 关闭通信仍然正常，但新服务端不会注册进来，服务端掉线了也无法摘除掉。</p>
<p>5、重新启动Etcd3服务器，服务端上下线可自动恢复正常。</p>
<p>6、关闭所有服务端，客户端请求将被阻塞。</p>
<h4 id="参考">参考</h4>
<ol>
<li><a href="http://www.grpc.io/docs/" target="_blank" rel="external">http://www.grpc.io/docs/</a></li>
<li><a href="https://github.com/grpc/grpc/blob/master/doc/load-balancing.md" target="_blank" rel="external">https://github.com/grpc/grpc/blob/master/doc/load-balancing.md</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文出处: <a href="https://segmentfault.com/a/1190000008672912" target="_blank" rel="external">gRPC服务发现&amp;负载均衡</a>, 作者: <a href="https://segmentfault.com/u/softfn" target="_blank" rel="external">softfn</a>。</p>
<p>构建高可用、高性能的通信服务，通常采用服务注册与发现、负载均衡和容错处理等机制实现。根据负载均衡实现所在的位置不同，通常可分为以下三种解决方案：</p>
]]>
    
    </summary>
    
      <category term="gRPC" scheme="http://colobu.com/tags/gRPC/"/>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Go Slice 秘籍]]></title>
    <link href="http://colobu.com/2017/03/22/Slice-Tricks/"/>
    <id>http://colobu.com/2017/03/22/Slice-Tricks/</id>
    <published>2017-03-22T11:50:03.000Z</published>
    <updated>2017-03-22T12:17:19.000Z</updated>
    <content type="html"><![CDATA[<p>这是 Golang官方的一个总结: <a href="https://github.com/golang/go/wiki/SliceTricks" target="_blank" rel="external">SliceTricks</a></p>
<p>由于引入了内建的<code>append</code>的方法， 包<code>container/vector</code>的很多方法都被移除了，可以被内建的<code>append</code>和<code>copy</code>方法代替。</p>
<p>下面是栈vector的操作方法的实现，使用slice实现相关的操作。<br><a id="more"></a></p>
<h3 id="AppendVector">AppendVector</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">append</span>(a, b...)</div></pre></td></tr></table></figure>

<h3 id="Copy">Copy</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">b = <span class="built_in">make</span>([]T, <span class="built_in">len</span>(a))</div><div class="line"><span class="built_in">copy</span>(b, a)</div><div class="line"><span class="comment">// 如果a不为空，也可以用下面的方式</span></div><div class="line">b = <span class="built_in">append</span>([]T(<span class="constant">nil</span>), a...)</div></pre></td></tr></table></figure>

<h3 id="Cut">Cut</h3>
<p>切掉一段数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">append</span>(a[:i], a[j:]...)</div></pre></td></tr></table></figure>

<h3 id="Delete">Delete</h3>
<p>删除一个元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">append</span>(a[:i], a[i<span class="number">+1</span>:]...)</div><div class="line"><span class="comment">// or</span></div><div class="line">a = a[:i+<span class="built_in">copy</span>(a[i:], a[i<span class="number">+1</span>:])]</div></pre></td></tr></table></figure>

<h3 id="Delete，但不保持原来顺序">Delete，但不保持原来顺序</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a[i] = a[<span class="built_in">len</span>(a<span class="number">)-1</span>] </div><div class="line">a = a[:<span class="built_in">len</span>(a<span class="number">)-1</span>]</div></pre></td></tr></table></figure>

<p><strong>注意</strong>:如果元素是一个指针，或者是一个包含指针字段的struct，上面的<code>cut</code>、<code>delete</code>实现可能会有潜在的内存泄漏的问题。一些元素的值可能会被<code>a</code>一直引用而不被释放，下面的代码可以解决这个问题。</p>
<blockquote>
<h3 id="Cut-1">Cut</h3>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">copy</span>(a[i:], a[j:])</div><div class="line"><span class="keyword">for</span> k, n := <span class="built_in">len</span>(a)-j+i, <span class="built_in">len</span>(a); k &lt; n; k++ {</div><div class="line">	a[k] = <span class="constant">nil</span> <span class="comment">// or the zero value of T</span></div><div class="line">}</div><div class="line">a = a[:<span class="built_in">len</span>(a)-j+i]</div></pre></td></tr></table></figure>



<blockquote>
<h3 id="Delete-1">Delete</h3>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">copy</span>(a[i:], a[i<span class="number">+1</span>:])</div><div class="line">a[<span class="built_in">len</span>(a<span class="number">)-1</span>] = <span class="constant">nil</span> <span class="comment">// or the zero value of T</span></div><div class="line">a = a[:<span class="built_in">len</span>(a<span class="number">)-1</span>]</div></pre></td></tr></table></figure>

<blockquote>
<h3 id="Delete，但不保持原来顺序-1">Delete，但不保持原来顺序</h3>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a[i] = a[<span class="built_in">len</span>(a<span class="number">)-1</span>]</div><div class="line">a[<span class="built_in">len</span>(a<span class="number">)-1</span>] = <span class="constant">nil</span></div><div class="line">a = a[:<span class="built_in">len</span>(a<span class="number">)-1</span>]</div></pre></td></tr></table></figure>

<h3 id="Expand">Expand</h3>
<p>插入一段到中间</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>(<span class="built_in">make</span>([]T, j), a[i:]...)...)</div></pre></td></tr></table></figure>

<h3 id="Extend">Extend</h3>
<p>插入一段到尾部</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">append</span>(a, <span class="built_in">make</span>([]T, j)...)</div></pre></td></tr></table></figure>

<h3 id="Insert">Insert</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]T{x}, a[i:]...)...)</div></pre></td></tr></table></figure>

<p><strong>注意</strong>: 第二个<code>append</code>会使用它底层的存储创建一个新的slice，然后复制<code>a[i:]</code>到这个slice,然后把这个slice再复制回<code>s</code>。 新的slice的创建和第二次copy可以使用下面的方式来避免：</p>
<blockquote>
<h3 id="Insert-1">Insert</h3>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s = <span class="built_in">append</span>(s,<span class="number"> 0</span>)</div><div class="line"><span class="built_in">copy</span>(s[i<span class="number">+1</span>:], s[i:])</div><div class="line">s[i] = x</div></pre></td></tr></table></figure>

<h3 id="InsertVector">InsertVector</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>(b, a[i:]...)...)</div></pre></td></tr></table></figure>

<h3 id="Pop">Pop</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x, a = a[<span class="built_in">len</span>(a<span class="number">)-1</span>], a[:<span class="built_in">len</span>(a<span class="number">)-1</span>]</div></pre></td></tr></table></figure>

<h3 id="Push">Push</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">append</span>(a, x)</div></pre></td></tr></table></figure>

<h3 id="Shift">Shift</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x, a := a<span class="number">[0</span>], a<span class="number">[1</span>:]</div></pre></td></tr></table></figure>

<h3 id="Unshift">Unshift</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">append</span>([]T{x}, a...)</div></pre></td></tr></table></figure>

<h2 id="其它技巧">其它技巧</h2>
<h3 id="无额外对象分配的filter">无额外对象分配的filter</h3>
<p>这个技巧利用了slice会共享它的底层的数据存储和容量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">b := a[<span class="number">:0</span>]</div><div class="line"><span class="keyword">for</span> _, x := <span class="keyword">range</span> a {</div><div class="line">	<span class="keyword">if</span> f(x) {</div><div class="line">		b = <span class="built_in">append</span>(b, x)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="反转">反转</h3>
<p>将slice中的元素反转。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(a)<span class="number">/2</span><span class="number">-1</span>; i &gt;=<span class="number"> 0</span>; i-- {</div><div class="line">	opp := <span class="built_in">len</span>(a<span class="number">)-1</span>-i</div><div class="line">	a[i], a[opp] = a[opp], a[i]</div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面的代码类似，只不过使用了两个索引变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> left, right :=<span class="number"> 0</span>, <span class="built_in">len</span>(a<span class="number">)-1</span>; left &lt; right; left, right = left<span class="number">+1</span>, right<span class="number">-1</span> {</div><div class="line">	a[left], a[right] = a[right], a[left]</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>这是 Golang官方的一个总结: <a href="https://github.com/golang/go/wiki/SliceTricks" target="_blank" rel="external">SliceTricks</a></p>
<p>由于引入了内建的<code>append</code>的方法， 包<code>container/vector</code>的很多方法都被移除了，可以被内建的<code>append</code>和<code>copy</code>方法代替。</p>
<p>下面是栈vector的操作方法的实现，使用slice实现相关的操作。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]Protobuf3 语法指南]]></title>
    <link href="http://colobu.com/2017/03/16/Protobuf3-language-guide/"/>
    <id>http://colobu.com/2017/03/16/Protobuf3-language-guide/</id>
    <published>2017-03-16T04:59:21.000Z</published>
    <updated>2017-03-16T11:52:32.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/logos/protobuf.png" alt=""></p>
<p>以前我翻译了 <a href="http://colobu.com/2015/01/07/Protobuf-language-guide/" target="_blank" rel="external">Protobuf2 语法指南</a>，现在 <a href="http://blog.csdn.net/u011518120" target="_blank" rel="external">千念飞羽</a>把protobuf3的语法指南也翻译了，我也转载一下，读者可以有个参考。 译文地址是: <a href="http://blog.csdn.net/u011518120/article/details/54604615" target="_blank" rel="external">Protobuf3语言指南</a>。</p>
<a id="more"></a>
<blockquote>
<p>英文原文：<br><a href="https://developers.google.com/protocol-buffers/docs/proto3?hl=zh-cn#generating" target="_blank" rel="external">Language Guide (proto3)</a><br>中文出处：<br><a href="http://www.open-open.com/home/space.php?uid=37924&amp;do=blog&amp;id=5873" target="_blank" rel="external">Protobuf语言指南</a><br><a href="http://colobu.com/2015/01/07/Protobuf-language-guide/" target="_blank" rel="external">[译]Protobuf 语法指南</a><br>中文出处是proto2的译文，proto3的英文出现后在原来基础上增改了，水平有限，还请指正</p>
</blockquote>
<p>这个指南描述了如何使用Protocol buffer 语言去描述你的protocol buffer 数据， 包括 .proto文件符号和如何从.proto文件生成类。包含了proto2版本的protocol buffer语言：对于老版本的proto3 符号，请见<a href="https://developers.google.com/protocol-buffers/docs/proto?hl=zh-cn" target="_blank" rel="external">Proto2 Language Guide</a>（以及<a href="http://colobu.com/2015/01/07/Protobuf-language-guide/" target="_blank" rel="external">中文译本</a>，抄了很多这里的感谢下老版本的翻译者）</p>
<p>本文是一个参考指南——如果要查看如何使用本文中描述的多个特性的循序渐进的例子，请在教程中查找需要的语言的教程。</p>
<h2 id="定义一个消息类型">定义一个消息类型</h2>
<p>先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的查询结果所在的页数，以及每一页多少条查询结果。可以采用如下的方式来定义消息类型的.proto文件了：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">syntax = <span class="string">"proto3"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>{</div><div class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</div><div class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</div><div class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>文件的第一行指定了你正在使用proto3语法：如果你没有指定这个，编译器会使用proto2。这个指定语法行必须是文件的非空非注释的第一个行。</li>
<li>SearchRequest消息格式有3个字段，在消息中承载的数据分别对应于每一个字段。其中每个字段都有一个名字和一种类型。</li>
</ul>
<h3 id="指定字段类型">指定字段类型</h3>
<p>在上面的例子中，所有字段都是标量类型：两个整型（page_number和result_per_page），一个string类型（query）。当然，你也可以为字段指定其他的合成类型，包括枚举（enumerations）或其他消息类型。</p>
<h3 id="分配标识号">分配标识号</h3>
<p>正如你所见，在消息定义中，每个字段都有唯一的一个数字标识符。这些标识符是用来在消息的二进制格式中识别各个字段的，一旦开始使用就不能够再改变。注：[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留 [1,15]之内的标识号。切记：要为将来有可能添加的、频繁出现的标识号预留一些标识号。</p>
<p>最小的标识号可以从1开始，最大到2^29 - 1, or 536,870,911。不可以使用其中的[19000－19999]（ (从FieldDescriptor::kFirstReservedNumber 到 FieldDescriptor::kLastReservedNumber)）的标识号， Protobuf协议实现中对这些进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报警。同样你也不能使用早期保留的标识号。</p>
<h3 id="指定字段规则">指定字段规则</h3>
<p>所指定的消息字段修饰符必须是如下之一：</p>
<ul>
<li>singular：一个格式良好的消息应该有0个或者1个这种字段（但是不能超过1个）。</li>
<li>repeated：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。</li>
</ul>
<p>在proto3中，repeated的标量域默认情况虾使用packed。</p>
<p>你可以了解更多的pakced属性在<a href="https://developers.google.com/protocol-buffers/docs/encoding?hl=zh-cn#packed" target="_blank" rel="external">Protocol Buffer 编码</a></p>
<h3 id="添加更多消息类型">添加更多消息类型</h3>
<p>在一个.proto文件中可以定义多个消息类型。在定义多个相关的消息的时候，这一点特别有用——例如，如果想定义与SearchResponse消息类型对应的回复消息格式的话，你可以将它添加到相同的.proto文件中，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>{</div><div class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</div><div class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</div><div class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>{</div><div class="line"> ...</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="添加注释">添加注释</h3>
<p>向.proto文件添加注释，可以使用C/C++/Java风格的双斜杠（//） 语法格式，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>{</div><div class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</div><div class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;  <span class="comment">// Which page number do we want?</span></div><div class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;  <span class="comment">// Number of results to return per page.</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="保留标识符（Reserved）">保留标识符（Reserved）</h3>
<p>如果你通过删除或者注释所有域，以后的用户在更新这个类型的时候可能重用这些标识号。如果你使用旧版本加载相同的.proto文件会导致严重的问题，包括数据损坏、隐私错误等等。现在有一种确保不会发生这种情况的方法就是为字段tag（reserved name可能会JSON序列化的问题）指定<code>reserved</code>标识符，protocol buffer的编译器会警告未来尝试使用这些域标识符的用户。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>{</div><div class="line">  reserved <span class="number">2</span>, <span class="number">15</span>, <span class="number">9</span> to <span class="number">11</span>;</div><div class="line">  reserved <span class="string">"foo"</span>, <span class="string">"bar"</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注：不要在同一行reserved声明中同时声明域名字和tag number。</p>
<h3 id="从-proto文件生成了什么？">从.proto文件生成了什么？</h3>
<p>当用protocol buffer编译器来运行.proto文件时，编译器将生成所选择语言的代码，这些代码可以操作在.proto文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。</p>
<ul>
<li>对C++来说，编译器会为每个.proto文件生成一个.h文件和一个.cc文件，.proto文件中的每一个消息有一个对应的类。</li>
<li>对Java来说，编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。</li>
<li>对Python来说，有点不太一样——Python编译器为.proto文件中的每个消息类型生成一个含有静态描述符的模块，，该模块与一个元类（metaclass）在运行时（runtime）被用来创建所需的Python数据访问类。</li>
<li>对go来说，编译器会位每个消息类型生成了一个.pd.go文件。</li>
<li>对于Ruby来说，编译器会为每个消息类型生成了一个.rb文件。</li>
<li>javaNano来说，编译器输出类似域java但是没有Builder类</li>
<li>对于Objective-C来说，编译器会为每个消息类型生成了一个pbobjc.h文件和pbobjcm文件，.proto文件中的每一个消息有一个对应的类。</li>
<li>对于C#来说，编译器会为每个消息类型生成了一个.cs文件，.proto文件中的每一个消息有一个对应的类。<br>你可以从如下的文档链接中获取每种语言更多API(proto3版本的内容很快就公布)。<a href="https://developers.google.com/protocol-buffers/docs/reference/overview" target="_blank" rel="external">API Reference</a></li>
</ul>
<h2 id="标量数值类型">标量数值类型</h2>
<p>一个标量消息字段可以含有一个如下的类型——该表格展示了定义于.proto文件中的类型，以及与之对应的、在自动生成的访问类中定义的类型：</p>
<table><thead><tr><th>.proto Type</th><th align="center">Notes</th><th align="right">C++ Type</th><th>Java Type</th><th>Python Type[2]</th><th>Go Type</th><th>Ruby Type</th><th>C# Type</th><th>PHP Type</th></tr></thead><tbody><tr><td>double</td><td align="center"></td><td align="right">double</td><td>double</td><td>float</td><td>float64</td><td>Float</td><td>double</td><td>float</td></tr><tr><td>float</td><td align="center"></td><td align="right">float</td><td>float</td><td>float</td><td>float32</td><td>Float</td><td>float</td><td>float</td></tr><tr><td>int32</td><td align="center">使用变长编码，对于负值的效率很低，如果你的域有可能有负值，请使用sint64替代</td><td align="right">int32</td><td>int</td><td>int</td><td>int32</td><td>Fixnum 或者 Bignum（根据需要）</td><td>int</td><td>integer</td></tr><tr><td>uint32</td><td align="center">使用变长编码</td><td align="right">uint32</td><td>int</td><td>int/long</td><td>uint32</td><td>Fixnum 或者 Bignum（根据需要）</td><td>uint</td><td>integer</td></tr><tr><td>uint64</td><td align="center">使用变长编码</td><td align="right">uint64</td><td>long</td><td>int/long</td><td>uint64</td><td>Bignum</td><td>ulong</td><td>integer/string</td></tr><tr><td>sint32</td><td align="center">使用变长编码，这些编码在负值时比int32高效的多</td><td align="right">int32</td><td>int</td><td>int</td><td>int32</td><td>Fixnum 或者 Bignum（根据需要）</td><td>int</td><td>integer</td></tr><tr><td>sint64</td><td align="center">使用变长编码，有符号的整型值。编码时比通常的int64高效。</td><td align="right">int64</td><td>long</td><td>int/long</td><td>int64</td><td>Bignum</td><td>long</td><td>integer/string</td></tr><tr><td>fixed32</td><td align="center">总是4个字节，如果数值总是比总是比228大的话，这个类型会比uint32高效。</td><td align="right">uint32</td><td>int</td><td>int</td><td>uint32</td><td>Fixnum 或者 Bignum（根据需要）</td><td>uint</td><td>integer</td></tr><tr><td>fixed64</td><td align="center">总是8个字节，如果数值总是比总是比256大的话，这个类型会比uint64高效。</td><td align="right">uint64</td><td>long</td><td>int/long</td><td>uint64</td><td>Bignum</td><td>ulong</td><td>integer/string</td></tr><tr><td>sfixed32</td><td align="center">总是4个字节</td><td align="right">int32</td><td>int</td><td>int</td><td>int32</td><td>Fixnum 或者 Bignum（根据需要）</td><td>int</td><td>integer</td></tr><tr><td>sfixed64</td><td align="center">总是8个字节</td><td align="right">int64</td><td>long</td><td>int/long</td><td>int64</td><td>Bignum</td><td>long</td><td>integer/string</td></tr><tr><td>bool</td><td align="center"></td><td align="right">bool</td><td>boolean</td><td>bool</td><td>bool</td><td>TrueClass/FalseClass</td><td>bool</td><td>boolean</td></tr><tr><td>string</td><td align="center">一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。</td><td align="right">string</td><td>String</td><td>str/unicode</td><td>string</td><td>String (UTF-8)</td><td>string</td><td>string</td></tr><tr><td>bytes</td><td align="center">可能包含任意顺序的字节数据。</td><td align="right">string</td><td>ByteString</td><td>str</td><td>[]byte</td><td>String (ASCII-8BIT)</td><td>ByteString</td><td>string</td></tr></tbody></table>


<p>你可以在文章<a href="https://developers.google.com/protocol-buffers/docs/encoding?hl=zh-cn" target="_blank" rel="external">Protocol Buffer 编码</a>中，找到更多“序列化消息时各种类型如何编码”的信息。</p>
<ol>
<li>在java中，无符号32位和64位整型被表示成他们的整型对应形式，最高位被储存在标志位中。</li>
<li>对于所有的情况，设定值会执行类型检查以确保此值是有效。</li>
<li>64位或者无符号32位整型在解码时被表示成为ilong，但是在设置时可以使用int型值设定，在所有的情况下，值必须符合其设置其类型的要求。</li>
<li>python中string被表示成在解码时表示成unicode。但是一个ASCIIstring可以被表示成str类型。</li>
<li>Integer在64位的机器上使用，string在32位机器上使用</li>
</ol>
<h2 id="默认值">默认值</h2>
<p>当一个消息被解析的时候，如果被编码的信息不包含一个特定的singular元素，被解析的对象锁对应的域被设置位一个默认值，对于不同类型指定如下：</p>
<ul>
<li>对于string，默认是一个空string</li>
<li>对于bytes，默认是一个空的bytes</li>
<li>对于bool，默认是false</li>
<li>对于数值类型，默认是0</li>
<li>对于枚举，默认是第一个定义的枚举值，必须为0;</li>
<li>对于消息类型（message），域没有被设置，确切的消息是根据语言确定的，详见generated code guide</li>
</ul>
<p>对于可重复域的默认值是空（通常情况下是对应语言中空列表）。</p>
<p><em>注：对于标量消息域，一旦消息被解析，就无法判断域释放被设置为默认值（例如，例如boolean值是否被设置为false）还是根本没有被设置。你应该在定义你的消息类型时非常注意。例如，比如你不应该定义boolean的默认值false作为任何行为的触发方式。也应该注意如果一个标量消息域被设置为标志位，这个值不应该被序列化传输。</em></p>
<p>查看<a href="https://developers.google.com/protocol-buffers/docs/reference/overview?hl=zh-cn" target="_blank" rel="external">generated code guide</a>选择你的语言的默认值的工作细节。</p>
<h2 id="枚举">枚举</h2>
<p>当需要定义一个消息类型的时候，可能想为一个字段指定某“预定义值序列”中的一个值。例如，假设要为每一个SearchRequest消息添加一个 corpus字段，而corpus的值可能是UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS或VIDEO中的一个。 其实可以很容易地实现这一点：通过向消息定义中添加一个枚举（enum）并且为每个可能的值定义一个常量就可以了。</p>
<p>在下面的例子中，在消息格式中添加了一个叫做Corpus的枚举类型——它含有所有可能的值 ——以及一个类型为Corpus的字段：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>{</div><div class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</div><div class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</div><div class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</div><div class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Corpus</span> </span>{</div><div class="line"><span class="constant">    UNIVERSAL</span> = <span class="number">0</span>;</div><div class="line"><span class="constant">    WEB</span> = <span class="number">1</span>;</div><div class="line"><span class="constant">    IMAGES</span> = <span class="number">2</span>;</div><div class="line"><span class="constant">    LOCAL</span> = <span class="number">3</span>;</div><div class="line"><span class="constant">    NEWS</span> = <span class="number">4</span>;</div><div class="line"><span class="constant">    PRODUCTS</span> = <span class="number">5</span>;</div><div class="line"><span class="constant">    VIDEO</span> = <span class="number">6</span>;</div><div class="line">  }</div><div class="line"><span class="constant">  Corpus corpus</span> = <span class="number">4</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如你所见，Corpus枚举的第一个常量映射为0：每个枚举类型必须将其第一个类型映射为0，这是因为：</p>
<ul>
<li>必须有有一个0值，我们可以用这个0值作为默认值。</li>
<li>这个零值必须为第一个元素，为了兼容proto2语义，枚举类的第一个值总是默认值。</li>
</ul>
<p>你可以通过将不同的枚举常量指定位相同的值。如果这样做你需要将allow_alias设定位true，否则编译器会在别名的地方产生一个错误信息。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumAllowingAlias</span> </span>{</div><div class="line">  <span class="keyword">option</span> allow_alias = <span class="literal">true</span>;</div><div class="line"><span class="constant">  UNKNOWN</span> = <span class="number">0</span>;</div><div class="line"><span class="constant">  STARTED</span> = <span class="number">1</span>;</div><div class="line"><span class="constant">  RUNNING</span> = <span class="number">1</span>;</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumNotAllowingAlias</span> </span>{</div><div class="line"><span class="constant">  UNKNOWN</span> = <span class="number">0</span>;</div><div class="line"><span class="constant">  STARTED</span> = <span class="number">1</span>;</div><div class="line">  <span class="comment">// RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>枚举常量必须在32位整型值的范围内。因为enum值是使用可变编码方式的，对负数不够高效，因此不推荐在enum中使用负数。如上例所示，可以在 一个消息定义的内部或外部定义枚举——这些枚举可以在.proto文件中的任何消息定义里重用。当然也可以在一个消息中声明一个枚举类型，而在另一个不同 的消息中使用它——采用MessageType.EnumType的语法格式。</p>
<p>当对一个使用了枚举的.proto文件运行protocol buffer编译器的时候，生成的代码中将有一个对应的enum（对Java或C++来说），或者一个特殊的EnumDescriptor类（对 Python来说），它被用来在运行时生成的类中创建一系列的整型值符号常量（symbolic constants）。</p>
<p>在反序列化的过程中，无法识别的枚举值会被保存在消息中，虽然这种表示方式需要依据所使用语言而定。在那些支持开放枚举类型超出指定范围之外的语言中（例如C++和Go），为识别的值会被表示成所支持的整型。在使用封闭枚举类型的语言中（Java），使用枚举中的一个类型来表示未识别的值，并且可以使用所支持整型来访问。在其他情况下，如果解析的消息被序列号，未识别的值将保持原样。</p>
<p>关于如何在你的应用程序的消息中使用枚举的更多信息，请查看所选择的语言<a href="http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/reference/overview.html" target="_blank" rel="external">generated code guide</a>。</p>
<h2 id="使用其他消息类型">使用其他消息类型</h2>
<p>你可以将其他消息类型用作字段类型。例如，假设在每一个SearchResponse消息中包含Result消息，此时可以在相同的.proto文件中定义一个Result消息类型，然后在SearchResponse消息中指定一个Result类型的字段，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>{</div><div class="line">  <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">Result</span> </span>{</div><div class="line">  <span class="built_in">string</span> url = <span class="number">1</span>;</div><div class="line">  <span class="built_in">string</span> title = <span class="number">2</span>;</div><div class="line">  <span class="keyword">repeated</span> <span class="built_in">string</span> snippets = <span class="number">3</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="导入定义">导入定义</h3>
<p>在上面的例子中，Result消息类型与SearchResponse是定义在同一文件中的。如果想要使用的消息类型已经在其他.proto文件中已经定义过了呢？<br>你可以通过导入（importing）其他.proto文件中的定义来使用它们。要导入其他.proto文件的定义，你需要在你的文件中添加一个导入声明，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"myproject/other_protos.proto"</span>;</div></pre></td></tr></table></figure>

<p>默认情况下你只能使用直接导入的.proto文件中的定义. 然而， 有时候你需要移动一个.proto文件到一个新的位置， 可以不直接移动.proto文件， 只需放入一个伪 .proto 文件在老的位置， 然后使用import public转向新的位置。import public 依赖性会通过任意导入包含import public声明的proto文件传递。例如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这是新的proto</span></div><div class="line"><span class="comment">// All definitions are moved here</span></div></pre></td></tr></table></figure>



<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这是久的proto</span></div><div class="line"><span class="comment">// 这是所有客户端正在导入的包</span></div><div class="line"><span class="keyword">import</span> public <span class="string">"new.proto"</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">"other.proto"</span>;</div></pre></td></tr></table></figure>



<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 客户端proto</span></div><div class="line"><span class="keyword">import</span> <span class="string">"old.proto"</span>;</div><div class="line"><span class="comment">// 现在你可以使用新旧两种包的proto定义了。</span></div></pre></td></tr></table></figure>

<p>通过在编译器命令行参数中使用-I/--proto_pathprotocal 编译器会在指定目录搜索要导入的文件。如果没有给出标志，编译器会搜索编译命令被调用的目录。通常你只要指定proto_path标志为你的工程根目录就好。并且指定好导入的正确名称就好。</p>
<h3 id="使用proto2消息类型">使用proto2消息类型</h3>
<p>在你的proto3消息中导入proto2的消息类型也是可以的，反之亦然，然后proto2枚举不可以直接在proto3的标识符中使用（如果仅仅在proto2消息中使用是可以的）。</p>
<h2 id="嵌套类型">嵌套类型</h2>
<p>你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result消息就定义在SearchResponse消息内，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>{</div><div class="line">  <span class="class"><span class="keyword">message</span> <span class="title">Result</span> </span>{</div><div class="line">    <span class="built_in">string</span> url = <span class="number">1</span>;</div><div class="line">    <span class="built_in">string</span> title = <span class="number">2</span>;</div><div class="line">    <span class="keyword">repeated</span> <span class="built_in">string</span> snippets = <span class="number">3</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你想在它的父消息类型的外部重用这个消息类型，你需要以Parent.Type的形式使用它，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SomeOtherMessage</span> </span>{</div><div class="line"><span class="constant">  SearchResponse.Result result</span> = <span class="number">1</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当然，你也可以将消息嵌套任意多层，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">Outer</span> </span>{                  <span class="comment">// Level 0</span></div><div class="line">  <span class="class"><span class="keyword">message</span> <span class="title">MiddleAA</span> </span>{  <span class="comment">// Level 1</span></div><div class="line">    <span class="class"><span class="keyword">message</span> <span class="title">Inner</span> </span>{   <span class="comment">// Level 2</span></div><div class="line">      <span class="built_in">int64</span> ival = <span class="number">1</span>;</div><div class="line">      <span class="built_in">bool</span>  booly = <span class="number">2</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="class"><span class="keyword">message</span> <span class="title">MiddleBB</span> </span>{  <span class="comment">// Level 1</span></div><div class="line">    <span class="class"><span class="keyword">message</span> <span class="title">Inner</span> </span>{   <span class="comment">// Level 2</span></div><div class="line">      <span class="built_in">int32</span> ival = <span class="number">1</span>;</div><div class="line">      <span class="built_in">bool</span>  booly = <span class="number">2</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="更新一个消息类型">更新一个消息类型</h2>
<p>如果一个已有的消息格式已无法满足新的需求——如，要在消息中添加一个额外的字段——但是同时旧版本写的代码仍然可用。不用担心！更新消息而不破坏已有代码是非常简单的。在更新时只要记住以下的规则即可。</p>
<ul>
<li>不要更改任何已有的字段的数值标识。</li>
<li>如果你增加新的字段，使用旧格式的字段仍然可以被你新产生的代码所解析。你应该记住这些元素的默认值这样你的新代码就可以以适当的方式和旧代码产生的数据交互。相似的，通过新代码产生的消息也可以被旧代码解析：只不过新的字段会被忽视掉。注意，未被识别的字段会在反序列化的过程中丢弃掉，所以如果消息再被传递给新的代码，新的字段依然是不可用的（这和proto2中的行为是不同的，在proto2中未定义的域依然会随着消息被序列化）</li>
<li>非required的字段可以移除——只要它们的标识号在新的消息类型中不再使用（更好的做法可能是重命名那个字段，例如在字段前添加“OBSOLETE_”前缀，那样的话，使用的.proto文件的用户将来就不会无意中重新使用了那些不该使用的标识号）。</li>
<li>int32, uint32, int64, uint64,和bool是全部兼容的，这意味着可以将这些类型中的一个转换为另外一个，而不会破坏向前、 向后的兼容性。如果解析出来的数字与对应的类型不相符，那么结果就像在C++中对它进行了强制类型转换一样（例如，如果把一个64位数字当作int32来 读取，那么它就会被截断为32位的数字）。</li>
<li>sint32和sint64是互相兼容的，但是它们与其他整数类型不兼容。</li>
<li>string和bytes是兼容的——只要bytes是有效的UTF-8编码。</li>
<li>嵌套消息与bytes是兼容的——只要bytes包含该消息的一个编码过的版本。</li>
<li>fixed32与sfixed32是兼容的，fixed64与sfixed64是兼容的。</li>
<li>枚举类型与int32，uint32，int64和uint64相兼容（注意如果值不相兼容则会被截断），然而在客户端反序列化之后他们可能会有不同的处理方式，例如，未识别的proto3枚举类型会被保留在消息中，但是他的表示方式会依照语言而定。int类型的字段总会保留他们的</li>
</ul>
<h2 id="Any">Any</h2>
<p>Any类型消息允许你在没有指定他们的.proto定义的情况下使用消息作为一个嵌套类型。一个Any类型包括一个可以被序列化bytes类型的任意消息，以及一个URL作为一个全局标识符和解析消息类型。为了使用Any类型，你需要导入<code>import google/protobuf/any.proto</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/any.proto"</span>;</div><div class="line"></div><div class="line">message ErrorStatus {</div><div class="line">  <span class="typename">string</span> message =<span class="number"> 1</span>;</div><div class="line">  repeated google.protobuf.Any details =<span class="number"> 2</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>对于给定的消息类型的默认类型URL是type.googleapis.com/packagename.messagename。</p>
<p>不同语言的实现会支持动态库以线程安全的方式去帮助封装或者解封装Any值。例如在java中，Any类型会有特殊的<code>pack()</code>和<code>unpack()</code>访问器，在C++中会有<code>PackFrom()</code>和<code>UnpackTo()</code>方法。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Storing an arbitrary message type in Any.</span></div><div class="line"><span class="constant">NetworkErrorDetails details</span> = ...;</div><div class="line"><span class="constant">ErrorStatus status;</span></div><div class="line">status.add_details()-&gt;PackFrom(details);</div><div class="line"></div><div class="line">// Reading an arbitrary message from Any.</div><div class="line">ErrorStatus status = ...;</div><div class="line">for (const Any& detail : status.details()) {</div><div class="line">  if (detail.Is&lt;NetworkErrorDetails&gt;()) {</div><div class="line"><span class="constant">    NetworkErrorDetails network_error;</span></div><div class="line">    detail.UnpackTo(&network_error);</div><div class="line">    ... processing network_error ...</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>目前，用于Any类型的动态库仍在开发之中<br>如果你已经很熟悉<a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="external">proto2语法</a>，使用Any替换<a href="https://developers.google.com/protocol-buffers/docs/proto#extensions" target="_blank" rel="external">扩展</a>。</p>
<h2 id="Oneof">Oneof</h2>
<p>如果你的消息中有很多可选字段， 并且同时至多一个字段会被设置， 你可以加强这个行为，使用oneof特性节省内存.</p>
<p>Oneof字段就像可选字段， 除了它们会共享内存， 至多一个字段会被设置。 设置其中一个字段会清除其它字段。 你可以使用<code>case()</code>或者<code>WhichOneof()</code> 方法检查哪个oneof字段被设置， 看你使用什么语言了.</p>
<h3 id="使用Oneof">使用Oneof</h3>
<p>为了在.proto定义Oneof字段， 你需要在名字前面加上oneof关键字, 比如下面例子的test_oneof:</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SampleMessage</span> </span>{</div><div class="line">  oneof test_oneof {</div><div class="line">    <span class="built_in">string</span> name = <span class="number">4</span>;</div><div class="line"><span class="constant">    SubMessage sub_message</span> = <span class="number">9</span>;</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后你可以增加oneof字段到 oneof 定义中. 你可以增加任意类型的字段, 但是不能使用repeated 关键字.</p>
<p>在产生的代码中, oneof字段拥有同样的 getters 和setters， 就像正常的可选字段一样. 也有一个特殊的方法来检查到底那个字段被设置. 你可以在相应的语言<a href="https://developers.google.com/protocol-buffers/docs/reference/overview" target="_blank" rel="external">API指南</a>中找到oneof API介绍.</p>
<h3 id="Oneof_特性">Oneof 特性</h3>
<ul>
<li>设置oneof会自动清楚其它oneof字段的值. 所以设置多次后，只有最后一次设置的字段有值.</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="constant">SampleMessage message;</span></div><div class="line">message.set_name("name");</div><div class="line">CHECK(message.has_name());</div><div class="line">message.mutable_sub_message();   // Will clear name field.</div><div class="line">CHECK(!message.has_name());</div></pre></td></tr></table></figure>

<ul>
<li>如果解析器遇到同一个oneof中有多个成员，只有最会一个会被解析成消息。</li>
<li>oneof不支持repeated.</li>
<li>反射API对oneof 字段有效.</li>
<li>如果使用C++,需确保代码不会导致内存泄漏. 下面的代码会崩溃， 因为sub_message 已经通过set_name()删除了</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="constant">SampleMessage message;</span></div><div class="line">SubMessage* sub_message = <span class="class"><span class="keyword">message</span>.<span class="title">mutable_sub_message</span>();</span></div><div class="line">message.set_name("name");      // Will delete sub_message</div><div class="line">sub_message-&gt;set_...            // Crashes here</div></pre></td></tr></table></figure>

<ul>
<li>在C++中，如果你使用Swap()两个oneof消息，每个消息，两个消息将拥有对方的值，例如在下面的例子中，msg1会拥有sub_message并且msg2会有name。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="constant">SampleMessage msg1;</span></div><div class="line">msg1.set_name("name");</div><div class="line">SampleMessage msg2;</div><div class="line">msg2.mutable_sub_message();</div><div class="line">msg1.swap(&msg2);</div><div class="line">CHECK(msg1.has_sub_message());</div><div class="line">CHECK(msg2.has_name());</div></pre></td></tr></table></figure>

<h3 id="向后兼容性问题">向后兼容性问题</h3>
<p>当增加或者删除oneof字段时一定要小心. 如果检查oneof的值返回None/NOT_SET, 它意味着oneof字段没有被赋值或者在一个不同的版本中赋值了。 你不会知道是哪种情况，因为没有办法判断如果未识别的字段是一个oneof字段。</p>
<p>Tag 重用问题：</p>
<ul>
<li><strong>将字段移入或移除oneof</strong>：在消息被序列号或者解析后，你也许会失去一些信息（有些字段也许会被清除）</li>
<li><strong>删除一个字段或者加入一个字段</strong>：在消息被序列号或者解析后，这也许会清除你现在设置的oneof字段</li>
<li><strong>分离或者融合oneof</strong>：行为与移动常规字段相似。</li>
</ul>
<h2 id="Map">Map</h2>
<p>如果你希望创建一个关联映射，protocol buffer提供了一种快捷的语法：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map&lt;key_type, value_type&gt; map_field = N;</div></pre></td></tr></table></figure>

<p>其中key_type可以是任意Integer或者string类型（所以，除了floating和bytes的任意标量类型都是可以的）value_type可以是任意类型。</p>
<p>例如，如果你希望创建一个project的映射，每个Projecct使用一个string作为key，你可以像下面这样定义：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map&lt;<span class="built_in">string</span>, Project&gt; projects = <span class="number">3</span>;</div></pre></td></tr></table></figure>

<ul>
<li>Map的字段可以是repeated。</li>
<li>序列化后的顺序和map迭代器的顺序是不确定的，所以你不要期望以固定顺序处理Map</li>
<li>当为.proto文件产生生成文本格式的时候，map会按照key 的顺序排序，数值化的key会按照数值排序。</li>
<li>从序列化中解析或者融合时，如果有重复的key则后一个key不会被使用，当从文本格式中解析map时，如果存在重复的key。</li>
</ul>
<p>生成map的API现在对于所有proto3支持的语言都可用了，你可以从<a href="https://developers.google.com/protocol-buffers/docs/reference/overview" target="_blank" rel="external">API指南</a>找到更多信息。</p>
<h3 id="向后兼容性问题-1">向后兼容性问题</h3>
<p>map语法序列化后等同于如下内容，因此即使是不支持map语法的protocol buffer实现也是可以处理你的数据的：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">MapFieldEntry</span> </span>{</div><div class="line">  key_type key = <span class="number">1</span>;</div><div class="line">  value_type value = <span class="number">2</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">repeated</span> MapFieldEntry map_field = N;</div></pre></td></tr></table></figure>

<h2 id="Package">Package</h2>
<p>当然可以为.proto文件新增一个可选的package声明符，用来防止不同的消息类型有命名冲突。如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> foo.bar;</div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">Open</span> </span>{ ... }</div></pre></td></tr></table></figure>

<p>在其他的消息格式定义中可以使用包名+消息名的方式来定义域的类型，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">message Foo {</div><div class="line">  ...</div><div class="line">  required foo.bar.Open open =<span class="number"> 1</span>;</div><div class="line">  ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>包的声明符会根据使用语言的不同影响生成的代码。</p>
<ul>
<li>对于C++，产生的类会被包装在C++的命名空间中，如上例中的Open会被封装在 foo::bar空间中； - 对于Java，包声明符会变为java的一个包，除非在.proto文件中提供了一个明确有java_package；</li>
<li>对于 Python，这个包声明符是被忽略的，因为Python模块是按照其在文件系统中的位置进行组织的。</li>
<li>对于Go，包可以被用做Go包名称，除非你显式的提供一个option go_package在你的.proto文件中。</li>
<li>对于Ruby，生成的类可以被包装在内置的Ruby名称空间中，转换成Ruby所需的大小写样式 （首字母大写；如果第一个符号不是一个字母，则使用PB_前缀），例如Open会在Foo::Bar名称空间中。</li>
<li>对于javaNano包会使用Java包，除非你在你的文件中显式的提供一个option java_package。</li>
<li>对于C#包可以转换为PascalCase后作为名称空间，除非你在你的文件中显式的提供一个option csharp_namespace，例如，Open会在Foo.Bar名称空间中</li>
</ul>
<h3 id="包及名称的解析">包及名称的解析</h3>
<p>Protocol buffer语言中类型名称的解析与C++是一致的：首先从最内部开始查找，依次向外进行，每个包会被看作是其父类包的内部类。当然对于 （foo.bar.Baz）这样以“.”分隔的意味着是从最外围开始的。</p>
<p>ProtocolBuffer编译器会解析.proto文件中定义的所有类型名。 对于不同语言的代码生成器会知道如何来指向每个具体的类型，即使它们使用了不同的规则。</p>
<h2 id="定义服务(Service)">定义服务(Service)</h2>
<p>如果想要将消息类型用在RPC(远程方法调用)系统中，可以在.proto文件中定义一个RPC服务接口，protocol buffer编译器将会根据所选择的不同语言生成服务接口代码及存根。如，想要定义一个RPC服务并具有一个方法，该方法能够接收 SearchRequest并返回一个SearchResponse，此时可以在.proto文件中进行如下定义：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">service</span> <span class="title">SearchService</span> </span>{</div><div class="line">  <span class="function"><span class="keyword">rpc</span> Search (SearchRequest) <span class="keyword">returns</span> (SearchResponse)</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>最直观的使用protocol buffer的RPC系统是<a href="https://github.com/grpc/grpc-experiments" target="_blank" rel="external">gRPC</a>,一个由谷歌开发的语言和平台中的开源的PRC系统，gRPC在使用protocl buffer时非常有效，如果使用特殊的protocol buffer插件可以直接为您从.proto文件中产生相关的RPC代码。</p>
<p>如果你不想使用gRPC，也可以使用protocol buffer用于自己的RPC实现，你可以从<a href="https://developers.google.com/protocol-buffers/docs/proto#services" target="_blank" rel="external">proto2语言指南</a>中找到更多信息</p>
<p>还有一些第三方开发的PRC实现使用Protocol Buffer。参考<a href="https://github.com/google/protobuf/blob/master/docs/third_party.md" target="_blank" rel="external">第三方插件wiki</a>查看这些实现的列表。</p>
<h2 id="JSON_映射">JSON 映射</h2>
<p>Proto3 支持JSON的编码规范，使他更容易在不同系统之间共享数据，在下表中逐个描述类型。</p>
<p>如果JSON编码的数据丢失或者其本身就是null，这个数据会在解析成protocol buffer的时候被表示成默认值。如果一个字段在protocol buffer中表示为默认值，体会在转化成JSON的时候编码的时候忽略掉以节省空间。具体实现可以提供在JSON编码中可选的默认值。</p>
<table><thead><tr><th>proto3</th><th>JSON</th><th>JSON示例</th><th>注意</th></tr></thead><tbody><tr><td>message</td><td>object</td><td>{“fBar”: v, “g”: null, …}</td><td>产生JSON对象，消息字段名可以被映射成lowerCamelCase形式，并且成为JSON对象键，null被接受并成为对应字段的默认值</td></tr><tr><td>enum</td><td>string</td><td>“FOO_BAR”</td><td>枚举值的名字在proto文件中被指定</td></tr><tr><td>map</td><td>object</td><td>{“k”: v, …}</td><td>所有的键都被转换成string</td></tr><tr><td>repeated V</td><td>array</td><td>[v, …]</td><td>null被视为空列表</td></tr><tr><td>bool</td><td>true, false</td><td>true, false</td><td></td></tr><tr><td>string</td><td>string</td><td>“Hello World!”</td><td></td></tr><tr><td>bytes</td><td>base64 string</td><td>“YWJjMTIzIT8kKiYoKSctPUB+”</td><td></td></tr><tr><td>int32, fixed32, uint32</td><td>number</td><td>1, -10, 0</td><td>JSON值会是一个十进制数，数值型或者string类型都会接受</td></tr><tr><td>int64, fixed64, uint64</td><td>string</td><td>“1”, “-10”</td><td>JSON值会是一个十进制数，数值型或者string类型都会接受</td></tr><tr><td>float, double</td><td>number</td><td>1.1, -10.0, 0, “NaN”, “Infinity”</td><td>JSON值会是一个数字或者一个指定的字符串如”NaN”,”infinity”或者”-Infinity”，数值型或者字符串都是可接受的，指数符号也可以接受</td></tr><tr><td>Any</td><td>object</td><td>{“@type”: “url”, “f”: v, … }</td><td>如果一个Any保留一个特上述的JSON映射，则它会转换成一个如下形式：<code>{&quot;@type&quot;: xxx, &quot;value&quot;: yyy}</code>否则，该值会被转换成一个JSON对象，<code>@type</code>字段会被插入所指定的确定的值</td></tr><tr><td>Timestamp</td><td>string</td><td>“1972-01-01T10:00:20.021Z”</td><td>使用RFC 339，其中生成的输出将始终是Z-归一化啊的，并且使用0，3，6或者9位小数</td></tr><tr><td>Duration</td><td>string</td><td>“1.000340012s”, “1s”</td><td>生成的输出总是0，3，6或者9位小数，具体依赖于所需要的精度，接受所有可以转换为纳秒级的精度</td></tr><tr><td>Struct</td><td>object</td><td>{ … }</td><td>任意的JSON对象，见struct.proto</td></tr><tr><td>Wrapper types</td><td>various types</td><td>2, “2”, “foo”, true, “true”, null, 0, …</td><td>包装器在JSON中的表示方式类似于基本类型，但是允许nulll，并且在转换的过程中保留null</td></tr><tr><td>FieldMask</td><td>string</td><td>“f.fooBar,h”</td><td>见fieldmask.proto</td></tr><tr><td>ListValue</td><td>array</td><td>[foo, bar, …]</td><td></td></tr><tr><td>Value</td><td>value</td><td></td><td>任意JSON值</td></tr><tr><td>NullValue</td><td>null</td><td></td><td>JSON null</td></tr></tbody></table>

<h2 id="选项">选项</h2>
<p>定义.proto文件时能够标注一系列的option。Option并不改变整个文件声明的含义，但却能够影响特定环境下处理方式。完整的可用选项可以在<code>google/protobuf/descriptor.proto</code>找到。</p>
<p>一些选项是文件级别的，意味着它可以作用于最外范围，不包含在任何消息内部、enum或服务定义中。一些选项是消息级别的，意味着它可以用在消息定义的内部。当然有些选项可以作用在域、enum类型、enum值、服务类型及服务方法中。到目前为止，并没有一种有效的选项能作用于所有的类型。</p>
<p>如下就是一些常用的选项：</p>
<ul>
<li>java_package (文件选项) :这个选项表明生成java类所在的包。如果在.proto文件中没有明确的声明java_package，就采用默认的包名。当然了，默认方式产生的 java包名并不是最好的方式，按照应用名称倒序方式进行排序的。如果不需要产生java代码，则该选项将不起任何作用。如：</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">option</span> java_package = <span class="string">"com.example.foo"</span>;</div></pre></td></tr></table></figure>

<ul>
<li>java_outer_classname (文件选项): 该选项表明想要生成Java类的名称。如果在.proto文件中没有明确的java_outer_classname定义，生成的class名称将会根据.proto文件的名称采用驼峰式的命名方式进行生成。如（foo_bar.proto生成的java类名为FooBar.java）,如果不生成java代码，则该选项不起任何作用。如：</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">"Ponycopter"</span>;</div></pre></td></tr></table></figure>

<ul>
<li>optimize_for(文件选项): 可以被设置为 SPEED, CODE_SIZE,或者LITE_RUNTIME。这些值将通过如下的方式影响C++及java代码的生成： <ul>
<li>SPEED (default): protocol buffer编译器将通过在消息类型上执行序列化、语法分析及其他通用的操作。这种代码是最优的。</li>
<li>CODE_SIZE: protocol buffer编译器将会产生最少量的类，通过共享或基于反射的代码来实现序列化、语法分析及各种其它操作。采用该方式产生的代码将比SPEED要少得多， 但是操作要相对慢些。当然实现的类及其对外的API与SPEED模式都是一样的。这种方式经常用在一些包含大量的.proto文件而且并不盲目追求速度的 应用中。</li>
<li>LITE_RUNTIME: protocol buffer编译器依赖于运行时核心类库来生成代码（即采用libprotobuf-lite 替代libprotobuf）。这种核心类库由于忽略了一 些描述符及反射，要比全类库小得多。这种模式经常在移动手机平台应用多一些。编译器采用该模式产生的方法实现与SPEED模式不相上下，产生的类通过实现 MessageLite接口，但它仅仅是Messager接口的一个子集。</li>
</ul>
</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">option</span> optimize_for = CODE_SIZE;</div></pre></td></tr></table></figure>

<ul>
<li>cc_enable_arenas(文件选项):对于C++产生的代码启用arena allocation</li>
<li>objc_class_prefix(文件选项):设置Objective-C类的前缀，添加到所有Objective-C从此.proto文件产生的类和枚举类型。没有默认值，所使用的前缀应该是苹果推荐的3-5个大写字符，注意2个字节的前缀是苹果所保留的。</li>
<li>deprecated(字段选项):如果设置为true则表示该字段已经被废弃，并且不应该在新的代码中使用。在大多数语言中没有实际的意义。在java中，这回变成@Deprecated注释，在未来，其他语言的代码生成器也许会在字标识符中产生废弃注释，废弃注释会在编译器尝试使用该字段时发出警告。如果字段没有被使用你也不希望有新用户使用它，尝试使用保留语句替换字段声明。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int32</span> old_field = <span class="number">6</span> [deprecated=<span class="literal">true</span>];</div></pre></td></tr></table></figure>

<h3 id="自定义选项">自定义选项</h3>
<p>ProtocolBuffers允许自定义并使用选项。该功能应该属于一个高级特性，对于大部分人是用不到的。如果你的确希望创建自己的选项，请参看 Proto2 Language Guide。注意创建自定义选项使用了拓展，拓展只在proto3中可用。</p>
<h2 id="生成访问类">生成访问类</h2>
<p>可以通过定义好的.proto文件来生成Java,Python,C++, Ruby, JavaNano, Objective-C,或者C# 代码，需要基于.proto文件运行protocol buffer编译器protoc。如果你没有安装编译器，下载安装包并遵照README安装。对于Go,你还需要安装一个特殊的代码生成器插件。你可以通过GitHub上的protobuf库找到安装过程</p>
<p>通过如下方式调用protocol编译器：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR --ruby_out=DST_DIR --javanano_out=DST_DIR --objc_out=DST_DIR --csharp_out=DST_DIR path/to/file.proto</div></pre></td></tr></table></figure>

<ul>
<li>IMPORT_PATH声明了一个.proto文件所在的解析import具体目录。如果忽略该值，则使用当前目录。如果有多个目录则可以多次调用--proto_path，它们将会顺序的被访问并执行导入。-I=IMPORT_PATH是--proto_path的简化形式。</li>
<li>当然也可以提供一个或多个输出路径： <ul>
<li>--cpp_out 在目标目录DST_DIR中产生C++代码，可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated" target="_blank" rel="external">C++代码生成参考</a>中查看更多。</li>
<li>--java_out 在目标目录DST_DIR中产生Java代码，可以在 <a href="https://developers.google.com/protocol-buffers/docs/reference/java-generated" target="_blank" rel="external">Java代码生成参考</a>中查看更多。</li>
<li>--python_out 在目标目录 DST_DIR 中产生Python代码，可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/python-generated" target="_blank" rel="external">Python代码生成参考</a>中查看更多。</li>
<li>--go_out 在目标目录 DST_DIR 中产生Go代码，可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated" target="_blank" rel="external">GO代码生成参考</a>中查看更多。</li>
<li>--ruby_out在目标目录 DST_DIR 中产生Ruby代码，参考正在制作中。</li>
<li>--javanano_out在目标目录DST_DIR中生成JavaNano，JavaNano代码生成器有一系列的选项用于定制自定义生成器的输出：你可以通过生成器的<a href="https://github.com/google/protobuf/tree/master/javanano" target="_blank" rel="external">README</a>查找更多信息，JavaNano参考正在制作中。</li>
<li>--objc_out在目标目录DST_DIR中产生Object代码，可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/objective-c-generated" target="_blank" rel="external">Objective-C代码生成参考</a>中查看更多。</li>
<li>--csharp_out在目标目录DST_DIR中产生Object代码，可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/csharp-generated" target="_blank" rel="external">C#代码生成参考</a>中查看更多。</li>
<li>--php_out在目标目录DST_DIR中产生Object代码，可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/php-generated" target="_blank" rel="external">PHP代码生成参考</a>中查看更多。</li>
</ul>
</li>
</ul>
<p>作为一个方便的拓展，如果DST_DIR以.zip或者.jar结尾，编译器会将输出写到一个ZIP格式文件或者符合JAR标准的.jar文件中。注意如果输出已经存在则会被覆盖，编译器还没有智能到可以追加文件。 </p>
<ul>
<li>你必须提议一个或多个.proto文件作为输入，多个.proto文件可以只指定一次。虽然文件路径是相对于当前目录的，每个文件必须位于其IMPORT_PATH下，以便每个文件可以确定其规范的名称。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/logos/protobuf.png" alt=""></p>
<p>以前我翻译了 <a href="http://colobu.com/2015/01/07/Protobuf-language-guide/" target="_blank" rel="external">Protobuf2 语法指南</a>，现在 <a href="http://blog.csdn.net/u011518120" target="_blank" rel="external">千念飞羽</a>把protobuf3的语法指南也翻译了，我也转载一下，读者可以有个参考。 译文地址是: <a href="http://blog.csdn.net/u011518120/article/details/54604615" target="_blank" rel="external">Protobuf3语言指南</a>。</p>
]]>
    
    </summary>
    
      <category term="protobuf" scheme="http://colobu.com/tags/protobuf/"/>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为 Go Mutex 实现 TryLock 方法]]></title>
    <link href="http://colobu.com/2017/03/09/implement-TryLock-in-Go/"/>
    <id>http://colobu.com/2017/03/09/implement-TryLock-in-Go/</id>
    <published>2017-03-09T07:31:15.000Z</published>
    <updated>2017-03-09T09:49:54.000Z</updated>
    <content type="html"><![CDATA[<p>Go标准库的<code>sync/Mutex</code>、<code>RWMutex</code>实现了<code>sync/Locker</code>接口， 提供了<code>Lock()</code>和<code>UnLock()</code>方法，可以获取锁和释放锁，我们可以方便的使用它来控制我们对共享资源的并发控制上。</p>
<p>但是标准库中的<code>Mutex.Lock</code>的锁被获取后，如果在未释放之前再调用<code>Lock</code>则会被阻塞住，这种设计在有些情况下可能不能满足我的需求。有时候我们想尝试获取锁，如果获取到了，没问题继续执行，如果获取不到，我们不想阻塞住，而是去调用其它的逻辑，这个时候我们就想要<code>TryLock</code>方法了。</p>
<p>虽然很早(13年)就有人给Go开发组提需求了，但是这个请求并没有纳入官方库中，最终在官方库的清理中被关闭了，也就是官方库目前不会添加这个方法。<br><a id="more"></a></p>
<p>顺便说一句， <code>sync/Mutex</code>的源代码实现可以访问<a href="https://golang.org/src/sync/mutex.go" target="_blank" rel="external">这里</a>，它应该是实现了一种自旋(spin)加休眠的方式实现， 有兴趣的读者可以阅读源码，或者阅读相关的文章，比如 <a href="http://www.pydevops.com/2016/11/21/go-mutex-源码剖析/" target="_blank" rel="external">Go Mutex 源码剖析</a>。这不是本文要介绍的内容，读者可以找一些资料来阅读。</p>
<p>好了，转入正题，看看几种实现<code>TryLock</code>的方式吧。</p>
<h3 id="使用_unsafe_操作指针">使用 <code>unsafe</code> 操作指针</h3>
<p>如果你查看<code>sync/Mutex</code>的代码，会发现<code>Mutext</code>的数据结构如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> {</div><div class="line">	state <span class="typename">int32</span></div><div class="line">	sema  <span class="typename">uint32</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>它使用<code>state</code>这个32位的整数来标记锁的占用，所以我们可以使用<code>CAS</code>来尝试获取锁。</p>
<p>代码实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mutexLocked =<span class="number"> 1</span> &lt;&lt; <span class="constant">iota</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> {</div><div class="line">	sync.Mutex</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> atomic.CompareAndSwapInt32((*<span class="typename">int32</span>)(unsafe.Pointer(&m.Mutex)),<span class="number"> 0</span>, mutexLocked)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用起来和标准库的<code>Mutex</code>用法一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> m Mutex</div><div class="line"></div><div class="line">	m.Lock()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		m.Lock()</div><div class="line">	}()</div><div class="line"></div><div class="line">	time.Sleep(time.Second)</div><div class="line">	fmt.Printf(<span class="string">"TryLock: %t\n"</span>, m.TryLock()) <span class="comment">//false</span></div><div class="line">	fmt.Printf(<span class="string">"TryLock: %t\n"</span>, m.TryLock()) <span class="comment">// false</span></div><div class="line">	m.Unlock()</div><div class="line">	fmt.Printf(<span class="string">"TryLock: %t\n"</span>, m.TryLock()) <span class="comment">//true</span></div><div class="line">	fmt.Printf(<span class="string">"TryLock: %t\n"</span>, m.TryLock()) <span class="comment">//false</span></div><div class="line">	m.Unlock()</div><div class="line">	fmt.Printf(<span class="string">"TryLock: %t\n"</span>, m.TryLock()) <span class="comment">//true</span></div><div class="line">	m.Unlock()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意<code>TryLock</code>不是检查锁的状态，而是<strong>尝试获取</strong>锁，所以<code>TryLock</code>返回true的时候事实上这个锁已经被获取了。</p>
<h3 id="实现自旋锁">实现自旋锁</h3>
<p>上面一节给了我们启发，利用 <code>uint32</code>和<code>CAS</code>操作我们可以一个自定义的锁:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> SpinLock <span class="keyword">struct</span> {</div><div class="line">	f <span class="typename">uint32</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (sl *SpinLock) Lock() {</div><div class="line">	<span class="keyword">for</span> !sl.TryLock() {</div><div class="line">		runtime.Gosched()</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (sl *SpinLock) Unlock() {</div><div class="line">	atomic.StoreUint32(&sl.f,<span class="number"> 0</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (sl *SpinLock) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> atomic.CompareAndSwapUint32(&sl.f,<span class="number"> 0</span>,<span class="number"> 1</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>整体来看，它好像是标准库的一个精简版，没有休眠和唤醒的功能。</p>
<p>当然这个自旋锁可以在大并发的情况下CPU的占用率可能比较高，这是因为它的<code>Lock</code>方法使用了自旋的方式，如果别人没有释放锁，这个循环会一直执行，速度可能更快但CPU占用率高。</p>
<p>当然这个版本还可以进一步的优化，尤其是在复制的时候。下面是一个优化的版本:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> spinLock <span class="typename">uint32</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> (sl *spinLock) Lock() {</div><div class="line">	<span class="keyword">for</span> !atomic.CompareAndSwapUint32((*<span class="typename">uint32</span>)(sl),<span class="number"> 0</span>,<span class="number"> 1</span>) {</div><div class="line">		runtime.Gosched() <span class="comment">//without this it locks up on GOMAXPROCS &gt; 1</span></div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (sl *spinLock) Unlock() {</div><div class="line">	atomic.StoreUint32((*<span class="typename">uint32</span>)(sl),<span class="number"> 0</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (sl *spinLock) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> atomic.CompareAndSwapUint32((*<span class="typename">uint32</span>)(sl),<span class="number"> 0</span>,<span class="number"> 1</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> SpinLock() sync.Locker {</div><div class="line">	<span class="keyword">var</span> lock spinLock</div><div class="line">	<span class="keyword">return</span> &lock</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="使用_channel_实现">使用 channel 实现</h3>
<p>另一种方式是使用channel:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ChanMutex <span class="keyword">chan</span> <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *ChanMutex) Lock() {</div><div class="line">	ch := (<span class="keyword">chan</span> <span class="keyword">struct</span>{})(*m)</div><div class="line">	ch &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *ChanMutex) Unlock() {</div><div class="line">	ch := (<span class="keyword">chan</span> <span class="keyword">struct</span>{})(*m)</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> &lt;-ch:</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"unlock of unlocked mutex"</span>)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *ChanMutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	ch := (<span class="keyword">chan</span> <span class="keyword">struct</span>{})(*m)</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> ch &lt;- <span class="keyword">struct</span>{}{}:</div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>有兴趣的同学可以关注我的同事写的库 <a href="https://github.com/lrita/gosync" target="_blank" rel="external">lrita/gosync</a>。</p>
<h3 id="性能比较">性能比较</h3>
<p>首先看看上面三种方式和标准库中的<code>Mutex</code>、<code>RWMutex</code>的<code>Lock</code>和<code>Unlock</code>的性能比较：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BenchmarkMutex_LockUnlock<span class="number">-4</span>         <span class="number">	100000000</span>	       <span class="number"> 16.8</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkRWMutex_LockUnlock<span class="number">-4</span>       <span class="number">	50000000</span>	       <span class="number"> 36.8</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkUnsafeMutex_LockUnlock<span class="number">-4</span>   <span class="number">	100000000</span>	       <span class="number"> 16.8</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkChannMutex_LockUnlock<span class="number">-4</span>    <span class="number">	20000000</span>	       <span class="number"> 65.6</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkSpinLock_LockUnlock<span class="number">-4</span>      <span class="number">	100000000</span>	       <span class="number"> 18.6</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div></pre></td></tr></table></figure>

<p>可以看到单线程(goroutine)的情况下｀spinlock｀并没有比标准库好多少，反而差一点,并发测试的情况比较好，如下表中显示，这是符合预期的。</p>
<p><code>unsafe</code>方式和标准库差不多。</p>
<p><code>channel</code>方式的性能就比较差了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BenchmarkMutex_LockUnlock_C<span class="number">-4</span>         <span class="number">	20000000</span>	       <span class="number"> 75.3</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkRWMutex_LockUnlock_C<span class="number">-4</span>       <span class="number">	20000000</span>	      <span class="number"> 100</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkUnsafeMutex_LockUnlock_C<span class="number">-4</span>   <span class="number">	20000000</span>	       <span class="number"> 75.3</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkChannMutex_LockUnlock_C<span class="number">-4</span>    <span class="number">	10000000</span>	      <span class="number"> 231</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkSpinLock_LockUnlock_C<span class="number">-4</span>      <span class="number">	50000000</span>	       <span class="number"> 32.3</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div></pre></td></tr></table></figure>

<p>再看看三种实现<code>TryLock</code>方法的锁的性能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BenchmarkUnsafeMutex_Trylock<span class="number">-4</span>        <span class="number">	50000000</span>	       <span class="number"> 34.0</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkChannMutex_Trylock<span class="number">-4</span>         <span class="number">	20000000</span>	       <span class="number"> 83.8</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkSpinLock_Trylock<span class="number">-4</span>           <span class="number">	50000000</span>	       <span class="number"> 30.9</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div></pre></td></tr></table></figure>

<h3 id="参考资料">参考资料</h3>
<p>本文参考了下面的文章和开源项目：</p>
<ol>
<li><a href="https://github.com/golang/go/issues/6123" target="_blank" rel="external">https://github.com/golang/go/issues/6123</a></li>
<li><a href="https://github.com/LK4D4/trylock/blob/master/trylock.go" target="_blank" rel="external">https://github.com/LK4D4/trylock/blob/master/trylock.go</a></li>
<li><a href="https://github.com/OneOfOne/go-utils/blob/master/sync/spinlock.go" target="_blank" rel="external">https://github.com/OneOfOne/go-utils/blob/master/sync/spinlock.go</a></li>
<li><a href="http://codereview.stackexchange.com/questions/60332/is-my-spin-lock-implementation-correct" target="_blank" rel="external">http://codereview.stackexchange.com/questions/60332/is-my-spin-lock-implementation-correct</a></li>
<li><a href="https://github.com/lrita/gosync" target="_blank" rel="external">https://github.com/lrita/gosync</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go标准库的<code>sync/Mutex</code>、<code>RWMutex</code>实现了<code>sync/Locker</code>接口， 提供了<code>Lock()</code>和<code>UnLock()</code>方法，可以获取锁和释放锁，我们可以方便的使用它来控制我们对共享资源的并发控制上。</p>
<p>但是标准库中的<code>Mutex.Lock</code>的锁被获取后，如果在未释放之前再调用<code>Lock</code>则会被阻塞住，这种设计在有些情况下可能不能满足我的需求。有时候我们想尝试获取锁，如果获取到了，没问题继续执行，如果获取不到，我们不想阻塞住，而是去调用其它的逻辑，这个时候我们就想要<code>TryLock</code>方法了。</p>
<p>虽然很早(13年)就有人给Go开发组提需求了，但是这个请求并没有纳入官方库中，最终在官方库的清理中被关闭了，也就是官方库目前不会添加这个方法。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[谁吃了我的Linux内存?]]></title>
    <link href="http://colobu.com/2017/03/07/what-is-in-linux-cached/"/>
    <id>http://colobu.com/2017/03/07/what-is-in-linux-cached/</id>
    <published>2017-03-07T08:16:42.000Z</published>
    <updated>2017-03-07T12:18:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/2017/03/07/what-is-in-linux-cached/atemyram.png" alt="图片来自 [linuxatemyram](http://www.linuxatemyram.com)"></p>
<p>一个经常被问的Linux问题：为啥我的Linux系统没运行多少程序，显示的可用内存这么少？其实Linux与Win的内存管理不同，会尽量缓存内存以提高读写性能，通常叫做Cache Memory。</p>
<p>比较老的文件都会介绍Linux的cache占用很多没关系，因为Linux尽可能利用内存进行缓存，但是缓存的回收也是需要资源的，比较好的一篇文章是Poor Zorro写的<a href="http://liwei.life/2016/04/26/linux内存中的cache真的能被回收么？/" target="_blank" rel="external">Linux内存中的Cache真的能被回收么？</a>。</p>
<a id="more"></a>
<p>虽然大部分情况下我们看到cache很高没有问题，但是我们还是想弄清楚到底是哪个程序把cache弄的那么高，这居然不是一件容易的事。</p>
<p>内核的模块在分配资源的时候，为了提高效率和资源的利用率，都是透过slab来分配的。slab为结构性缓存占用内存，该项也经常占用很大的内存。不过借助slabtop工具，我们可以很方便的显示内核片缓存信息，该工具可以更直观的显示/proc/slabinfo下的内容。</p>
<p><code>slabtop -s c</code>显示了一台机器缓存中占用对象的情况：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Active / Total Objects (% used)    : <span class="number">856448</span> / <span class="number">873737</span> (<span class="number">98.0</span>%)</div><div class="line"> Active / Total Slabs (% used)      : <span class="number">19737</span> / <span class="number">19737</span> (<span class="number">100.0</span>%)</div><div class="line"> Active / Total Caches (% used)     : <span class="number">67</span> / <span class="number">89</span> (<span class="number">75.3</span>%)</div><div class="line"> Active / Total Size (% used)       : <span class="number">141806.80</span>K / <span class="number">145931.33</span>K (<span class="number">97.2</span>%)</div><div class="line"> Minimum / Average / Maximum Object : <span class="number">0.01</span>K / <span class="number">0.17</span>K / <span class="number">8.00</span>K</div><div class="line"></div><div class="line">  OBJS ACTIVE  USE OBJ SIZE  SLABS OBJ/SLAB CACHE SIZE NAME</div><div class="line"><span class="number">416949</span> <span class="number">416949</span> <span class="number">100</span>%    <span class="number">0.10</span>K  <span class="number">10691</span>	 <span class="number">39</span>     <span class="number">42764</span>K buffer_head</div><div class="line">  <span class="number">5616</span>   <span class="number">5545</span>  <span class="number">98</span>%    <span class="number">2.00</span>K    <span class="number">351</span>	 <span class="number">16</span>     <span class="number">11232</span>K kmalloc-<span class="number">2048</span></div><div class="line">  <span class="number">9114</span>   <span class="number">8990</span>  <span class="number">98</span>%    <span class="number">1.02</span>K    <span class="number">294</span>	 <span class="number">31</span>	 <span class="number">9408</span>K ext4_inode_cache</div><div class="line"> <span class="number">12404</span>  <span class="number">12404</span> <span class="number">100</span>%    <span class="number">0.57</span>K    <span class="number">443</span>	 <span class="number">28</span>	 <span class="number">7088</span>K radix_tree_node</div><div class="line"> <span class="number">10800</span>  <span class="number">10731</span>  <span class="number">99</span>%    <span class="number">0.58</span>K    <span class="number">400</span>	 <span class="number">27</span>	 <span class="number">6400</span>K inode_cache</div><div class="line"> <span class="number">31290</span>  <span class="number">29649</span>  <span class="number">94</span>%    <span class="number">0.19</span>K    <span class="number">745</span>	 <span class="number">42</span>	 <span class="number">5960</span>K dentry</div><div class="line">  <span class="number">3552</span>   <span class="number">3362</span>  <span class="number">94</span>%    <span class="number">1.00</span>K    <span class="number">111</span>	 <span class="number">32</span>	 <span class="number">3552</span>K kmalloc-<span class="number">1024</span></div><div class="line">  <span class="number">1100</span>   <span class="number">1055</span>  <span class="number">95</span>%    <span class="number">2.84</span>K    <span class="number">100</span>	 <span class="number">11</span>	 <span class="number">3200</span>K task_struct</div><div class="line">  <span class="number">1649</span>   <span class="number">1481</span>  <span class="number">89</span>%    <span class="number">1.88</span>K     <span class="number">97</span>	 <span class="number">17</span>	 <span class="number">3104</span>K TCP</div><div class="line"> <span class="number">27000</span>  <span class="number">27000</span> <span class="number">100</span>%    <span class="number">0.11</span>K    <span class="number">750</span>	 <span class="number">36</span>	 <span class="number">3000</span>K sysfs_dir_cache</div><div class="line">  <span class="number">1380</span>   <span class="number">1269</span>  <span class="number">91</span>%    <span class="number">2.06</span>K     <span class="number">92</span>	 <span class="number">15</span>	 <span class="number">2944</span>K sighand_cache</div></pre></td></tr></table></figure>

<p>虽然上面的命令现实了cache中slab的情况，但是还是没有显示什么程序占用的cache。</p>
<p><a href="https://code.google.com/p/linux-ftools/" target="_blank" rel="external">linux-ftools</a>这个工具可以显示某个文件占用的cache的情况, fincore是它其中的一个工具：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">fincore [options] files...</div><div class="line"></div><div class="line">  <span class="variable">--pages=</span><span class="constant">false</span>      Do not print pages</div><div class="line">  --summarize        When comparing multiple files, print a summary report</div><div class="line">  --only-cached      Only print stats for files that are actually <span class="keyword">in</span> cache.</div><div class="line"></div><div class="line">root@xxxxxx:/var/lib/mysql/blogindex<span class="comment"># fincore --pages=false --summarize --only-cached * </span></div><div class="line">stats for CLUSTER_LOG_2010_05_21.MYI: file <span class="variable">size=</span><span class="number">93840384</span> , total <span class="variable">pages=</span><span class="number">22910</span> , cached <span class="variable">pages=</span><span class="number">1</span> , cached <span class="variable">size=</span><span class="number">4096</span>, cached <span class="variable">perc=</span><span class="number">0.004365</span> </div><div class="line">stats for CLUSTER_LOG_2010_05_22.MYI: file <span class="variable">size=</span><span class="number">417792</span> , total <span class="variable">pages=</span><span class="number">102</span> , cached <span class="variable">pages=</span><span class="number">1</span> , cached <span class="variable">size=</span><span class="number">4096</span>, cached <span class="variable">perc=</span><span class="number">0.980392</span> </div><div class="line">stats for CLUSTER_LOG_2010_05_23.MYI: file <span class="variable">size=</span><span class="number">826368</span> , total <span class="variable">pages=</span><span class="number">201</span> , cached <span class="variable">pages=</span><span class="number">1</span> , cached <span class="variable">size=</span><span class="number">4096</span>, cached <span class="variable">perc=</span><span class="number">0.497512</span> </div><div class="line">stats for CLUSTER_LOG_2010_05_24.MYI: file <span class="variable">size=</span><span class="number">192512</span> , total <span class="variable">pages=</span><span class="number">47</span> , cached <span class="variable">pages=</span><span class="number">1</span> , cached <span class="variable">size=</span><span class="number">4096</span>, cached <span class="variable">perc=</span><span class="number">2.127660</span> </div><div class="line">stats for CLUSTER_LOG_2010_06_03.MYI: file <span class="variable">size=</span><span class="number">345088</span> , total <span class="variable">pages=</span><span class="number">84</span> , cached <span class="variable">pages=</span><span class="number">43</span> , cached <span class="variable">size=</span><span class="number">176128</span>, cached <span class="variable">perc=</span><span class="number">51.190476</span> </div><div class="line">stats for CLUSTER_LOG_2010_06_04.MYD: file <span class="variable">size=</span><span class="number">1478552</span> , total <span class="variable">pages=</span><span class="number">360</span> , cached <span class="variable">pages=</span><span class="number">97</span> , cached <span class="variable">size=</span><span class="number">397312</span>, cached <span class="variable">perc=</span><span class="number">26.944444</span> </div><div class="line">stats for CLUSTER_LOG_2010_06_04.MYI: file <span class="variable">size=</span><span class="number">205824</span> , total <span class="variable">pages=</span><span class="number">50</span> , cached <span class="variable">pages=</span><span class="number">29</span> , cached <span class="variable">size=</span><span class="number">118784</span>, cached <span class="variable">perc=</span><span class="number">58.000000</span> </div><div class="line">stats for COMMENT_CONTENT_2010_06_03.MYI: file <span class="variable">size=</span><span class="number">100051968</span> , total <span class="variable">pages=</span><span class="number">24426</span> , cached <span class="variable">pages=</span><span class="number">10253</span> , cached <span class="variable">size=</span><span class="number">41996288</span>, cached <span class="variable">perc=</span><span class="number">41.975764</span> </div><div class="line">stats for COMMENT_CONTENT_2010_06_04.MYD: file <span class="variable">size=</span><span class="number">716369644</span> , total <span class="variable">pages=</span><span class="number">174894</span> , cached <span class="variable">pages=</span><span class="number">79821</span> , cached <span class="variable">size=</span><span class="number">326946816</span>, cached <span class="variable">perc=</span><span class="number">45.639645</span> </div><div class="line">stats for COMMENT_CONTENT_2010_06_04.MYI: file <span class="variable">size=</span><span class="number">56832000</span> , total <span class="variable">pages=</span><span class="number">13875</span> , cached <span class="variable">pages=</span><span class="number">5365</span> , cached <span class="variable">size=</span><span class="number">21975040</span>, cached <span class="variable">perc=</span><span class="number">38.666667</span> </div><div class="line">stats for FEED_CONTENT_2010_06_03.MYI: file <span class="variable">size=</span><span class="number">1001518080</span> , total <span class="variable">pages=</span><span class="number">244511</span> , cached <span class="variable">pages=</span><span class="number">98975</span> , cached <span class="variable">size=</span><span class="number">405401600</span>, cached <span class="variable">perc=</span><span class="number">40.478751</span> </div><div class="line">stats for FEED_CONTENT_2010_06_04.MYD: file <span class="variable">size=</span><span class="number">9206385684</span> , total <span class="variable">pages=</span><span class="number">2247652</span> , cached <span class="variable">pages=</span><span class="number">1018661</span> , cached <span class="variable">size=</span><span class="number">4172435456</span>, cached <span class="variable">perc=</span><span class="number">45.321117</span> </div><div class="line">stats for FEED_CONTENT_2010_06_04.MYI: file <span class="variable">size=</span><span class="number">638005248</span> , total <span class="variable">pages=</span><span class="number">155763</span> , cached <span class="variable">pages=</span><span class="number">52912</span> , cached <span class="variable">size=</span><span class="number">216727552</span>, cached <span class="variable">perc=</span><span class="number">33.969556</span> </div><div class="line">stats for FEED_CONTENT_2010_06_04.frm: file <span class="variable">size=</span><span class="number">9840</span> , total <span class="variable">pages=</span><span class="number">2</span> , cached <span class="variable">pages=</span><span class="number">3</span> , cached <span class="variable">size=</span><span class="number">12288</span>, cached <span class="variable">perc=</span><span class="number">150.000000</span> </div><div class="line">stats for PERMALINK_CONTENT_2010_06_03.MYI: file <span class="variable">size=</span><span class="number">1035290624</span> , total <span class="variable">pages=</span><span class="number">252756</span> , cached <span class="variable">pages=</span><span class="number">108563</span> , cached <span class="variable">size=</span><span class="number">444674048</span>, cached <span class="variable">perc=</span><span class="number">42.951700</span> </div><div class="line">stats for PERMALINK_CONTENT_2010_06_04.MYD: file <span class="variable">size=</span><span class="number">55619712720</span> , total <span class="variable">pages=</span><span class="number">13579031</span> , cached <span class="variable">pages=</span><span class="number">6590322</span> , cached <span class="variable">size=</span><span class="number">26993958912</span>, cached <span class="variable">perc=</span><span class="number">48.533080</span> </div><div class="line">stats for PERMALINK_CONTENT_2010_06_04.MYI: file <span class="variable">size=</span><span class="number">659397632</span> , total <span class="variable">pages=</span><span class="number">160985</span> , cached <span class="variable">pages=</span><span class="number">54304</span> , cached <span class="variable">size=</span><span class="number">222429184</span>, cached <span class="variable">perc=</span><span class="number">33.732335</span> </div><div class="line">stats for PERMALINK_CONTENT_2010_06_04.frm: file <span class="variable">size=</span><span class="number">10156</span> , total <span class="variable">pages=</span><span class="number">2</span> , cached <span class="variable">pages=</span><span class="number">3</span> , cached <span class="variable">size=</span><span class="number">12288</span>, cached <span class="variable">perc=</span><span class="number">150.000000</span> </div><div class="line">---</div><div class="line">total cached size: <span class="number">32847278080</span></div></pre></td></tr></table></figure>

<p>fincore的工作原理是将指定的文件的相应inode data与kernel的 page cache table做对比，如果page cache table有这个inode 信息，就找该inode对应的data block的大小。因为kernel的page cache table只存储data block的引用而不是文件名，即文件的inode信息。所以并没有任何一个工具运行一次就可以找出所有的文件使用缓存的情况。</p>
<p>所以使用linux-fincore只能加文件名，来判断该文件是否被缓存，如果缓存，大小是多少。问题是你不能随便猜哪个文件是否被缓存吧。</p>
<p><a href="http://shanker.blog.51cto.com" target="_blank" rel="external">shanker</a>提供了一个办法，那就查看哪些进程使用的物理内存最多，就找到该进程打开的文件，然后用fincore查看这些文件的缓存使用率。</p>
<p>这个办法在大部分情况下都可以找到占用cache较多的程序和进程。<br>他的这个脚本如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="shebang">#!/bin/bash</span></div><div class="line"><span class="comment">#Author: Shanker</span></div><div class="line"><span class="comment">#Time: 2016/06/08</span></div><div class="line"><span class="comment">#set -e</span></div><div class="line"><span class="comment">#set -u</span></div><div class="line"><span class="comment">#you have to install linux-fincore</span></div><div class="line"><span class="keyword">if</span> [ ! <span class="operator">-f</span> /usr/local/bin/linux-fincore ]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"You haven't installed linux-fincore yet"</span></div><div class="line">    <span class="keyword">exit</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="comment">#find the top 10 processs' cache file</span></div><div class="line">ps <span class="operator">-e</span> -o pid,rss|sort -nk2 -r|head -<span class="number">10</span> |awk <span class="string">'{print $1}'</span>&gt;/tmp/cache.pids</div><div class="line"><span class="comment">#find all the processs' cache file</span></div><div class="line"><span class="comment">#ps -e -o pid&gt;/tmp/cache.pids</span></div><div class="line"><span class="keyword">if</span> [ <span class="operator">-f</span> /tmp/cache.files ]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"the cache.files is exist, removing now "</span></div><div class="line">    rm <span class="operator">-f</span> /tmp/cache.files</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</div><div class="line"><span class="keyword">do</span></div><div class="line">    lsof -p <span class="variable">$line</span> <span class="number">2</span>&gt;/dev/null|awk <span class="string">'{print $9}'</span> &gt;&gt;/tmp/cache.files </div><div class="line"><span class="keyword">done</span>&lt;/tmp/cache.pids</div><div class="line"><span class="keyword">if</span> [ <span class="operator">-f</span> /tmp/cache.fincore ]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"the cache.fincore is exist, removing now"</span></div><div class="line">    rm <span class="operator">-f</span> /tmp/cache.fincore</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `cat /tmp/cache.files`</div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="keyword">if</span> [ <span class="operator">-f</span> <span class="variable">$i</span> ]</div><div class="line">    <span class="keyword">then</span></div><div class="line">        <span class="built_in">echo</span> <span class="variable">$i</span> &gt;&gt;/tmp/cache.fincore</div><div class="line">    <span class="keyword">fi</span></div><div class="line"><span class="keyword">done</span></div><div class="line">linux-fincore <span class="operator">-s</span>  `cat /tmp/cache.fincore`</div><div class="line">rm <span class="operator">-f</span> /tmp/cache.{pids,files,fincore}</div></pre></td></tr></table></figure>

<p>比较遗憾的是，linux-ftools看起来不再维护了。我在我的服务器也没有编译好这个程序，所以还得想办法。</p>
<p>后来找到<a href="https://github.com/tobert/pcstat" target="_blank" rel="external">pcstat</a>这个工具，功能和linux-ftools一样，使用Go开发。<br>然后我修改了Shanker的脚本，让它使用pcstat进行处理，可以很好的找到cache占用的情况。</p>
<p>修改的脚本如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="shebang">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="comment">#you have to install pcstat</span></div><div class="line"><span class="keyword">if</span> [ ! <span class="operator">-f</span> /data0/brokerproxy/pcstat ]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"You haven't installed pcstat yet"</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"run \"go get github.com/tobert/pcstat\" to install"</span></div><div class="line">    <span class="keyword">exit</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="comment">#find the top 10 processs' cache file</span></div><div class="line">ps <span class="operator">-e</span> -o pid,rss|sort -nk2 -r|head -<span class="number">10</span> |awk <span class="string">'{print $1}'</span>&gt;/tmp/cache.pids</div><div class="line"><span class="comment">#find all the processs' cache file</span></div><div class="line"><span class="comment">#ps -e -o pid&gt;/tmp/cache.pids</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="operator">-f</span> /tmp/cache.files ]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"the cache.files is exist, removing now "</span></div><div class="line">    rm <span class="operator">-f</span> /tmp/cache.files</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</div><div class="line"><span class="keyword">do</span></div><div class="line">    lsof -p <span class="variable">$line</span> <span class="number">2</span>&gt;/dev/null|awk <span class="string">'{print $9}'</span> &gt;&gt;/tmp/cache.files </div><div class="line"><span class="keyword">done</span>&lt;/tmp/cache.pids</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="operator">-f</span> /tmp/cache.pcstat ]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"the cache.pcstat is exist, removing now"</span></div><div class="line"></div><div class="line">    rm <span class="operator">-f</span> /tmp/cache.pcstat</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `cat /tmp/cache.files`</div><div class="line"><span class="keyword">do</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> [ <span class="operator">-f</span> <span class="variable">$i</span> ]</div><div class="line">    <span class="keyword">then</span></div><div class="line"></div><div class="line">        <span class="built_in">echo</span> <span class="variable">$i</span> &gt;&gt;/tmp/cache.pcstat</div><div class="line">    <span class="keyword">fi</span></div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line">/data0/brokerproxy/pcstat  `cat /tmp/cache.pcstat`</div><div class="line"></div><div class="line">rm <span class="operator">-f</span> /tmp/cache.{pids,files,pcstat}</div></pre></td></tr></table></figure>

<p>显示结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+------------------------------------------+----------------+------------+-----------+---------+</div><div class="line"><span class="string">| Name                                     | Size (bytes)   | Pages      | Cached    | Percent |</span></div><div class="line"><span class="string">|------------------------------------------+----------------+------------+-----------+---------|</span></div><div class="line"><span class="string">| /data0/abcasyouknow/0307/abc             | 10060771       | 2457       | 2457      | 100.000 |</span></div><div class="line"><span class="string">| /data0/abcasyouknow/0307/logs/abc.log    | 1860           | 1          | 1         | 100.000 |</span></div><div class="line"><span class="string">| /data0/abcasyouknow/0307/logs/uuid.log   | 326326364      | 79670      | 79670     | 100.000 |</span></div><div class="line"><span class="string">| /usr/bin/bash                            | 960384         | 235        | 194       | 082.553 |</span></div><div class="line"><span class="string">| /usr/lib/locale/locale-archive           | 106065056      | 25895      | 211       | 000.815 |</span></div><div class="line"><span class="string">| /usr/lib64/libnss_files-2.17.so          | 58288          | 15         | 15        | 100.000 |</span></div><div class="line"><span class="string">| /usr/lib64/libc-2.17.so                  | 2107760        | 515        | 336       | 065.243 |</span></div><div class="line"><span class="string">| /usr/lib64/libdl-2.17.so                 | 19512          | 5          | 5         | 100.000 |</span></div><div class="line"><span class="string">| /usr/lib64/libtinfo.so.5.9               | 174520         | 43         | 42        | 097.674 |</span></div><div class="line"><span class="string">| /usr/lib64/ld-2.17.so                    | 164336         | 41         | 41        | 100.000 |</span></div><div class="line"><span class="string">| /usr/lib64/gconv/gconv-modules.cache     | 26254          | 7          | 7         | 100.000 |</span></div><div class="line">+------------------------------------------+----------------+------------+-----------+---------+</div></pre></td></tr></table></figure>

<p>可以看到 uuid.log占用cache比较多。我的程序中这个文件是打开的，一直往里面写日志，Linux应该是把它缓存了。</p>
<p><strong>参考文档</strong></p>
<ol>
<li><a href="https://code.google.com/p/linux-ftools/" target="_blank" rel="external">https://code.google.com/p/linux-ftools/</a></li>
<li><a href="https://github.com/tobert/pcstat" target="_blank" rel="external">https://github.com/tobert/pcstat</a></li>
<li><a href="http://shanker.blog.51cto.com/1189689/1787378" target="_blank" rel="external">http://shanker.blog.51cto.com/1189689/1787378</a></li>
<li><a href="http://www.linuxatemyram.com" target="_blank" rel="external">http://www.linuxatemyram.com</a></li>
<li><a href="http://colobu.com/2015/10/31/How-to-Clear-RAM-Memory-Cache-Buffer-and-Swap-Space-on-Linux/" target="_blank" rel="external">http://colobu.com/2015/10/31/How-to-Clear-RAM-Memory-Cache-Buffer-and-Swap-Space-on-Linux/</a></li>
<li><a href="http://liwei.life/2016/04/26/linux内存中的cache真的能被回收么？/" target="_blank" rel="external">http://liwei.life/2016/04/26/linux内存中的cache真的能被回收么？/</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/2017/03/07/what-is-in-linux-cached/atemyram.png" alt="图片来自 [linuxatemyram](http://www.linuxatemyram.com)"></p>
<p>一个经常被问的Linux问题：为啥我的Linux系统没运行多少程序，显示的可用内存这么少？其实Linux与Win的内存管理不同，会尽量缓存内存以提高读写性能，通常叫做Cache Memory。</p>
<p>比较老的文件都会介绍Linux的cache占用很多没关系，因为Linux尽可能利用内存进行缓存，但是缓存的回收也是需要资源的，比较好的一篇文章是Poor Zorro写的<a href="http://liwei.life/2016/04/26/linux内存中的cache真的能被回收么？/" target="_blank" rel="external">Linux内存中的Cache真的能被回收么？</a>。</p>
]]>
    
    </summary>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译] Go 可视化性能分析工具]]></title>
    <link href="http://colobu.com/2017/03/02/a-short-survey-of-golang-pprof/"/>
    <id>http://colobu.com/2017/03/02/a-short-survey-of-golang-pprof/</id>
    <published>2017-03-02T04:41:41.000Z</published>
    <updated>2017-03-06T03:52:32.000Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="http://slcjordan.github.io/post/pprofsurvey/" target="_blank" rel="external">A Short Survey of PProf Visualization Tools</a> by <a href="http://slcjordan.github.io/" target="_blank" rel="external">Jordan Crabtree</a>。</p>
<p>调试CPU相关的问题经常会涉及关于趋势的微妙问题。堆使用的峰值是否逐渐的增长？ routine在什么地方被调用，调用的频度如何？</p>
<p>一图胜千言。<br>一张图片就可以提供很多有用的上下文信息，否则如果用语言解释起来累的半死。将pprof可视化显示可以将有用的CPU统计数据与整个时间的上下文关联起来。</p>
<a id="more"></a>
<h3 id="pprof_是什么？">pprof 是什么？</h3>
<p><a href="https://github.com/google/pprof" target="_blank" rel="external">PProf</a>是一个CPU分析器( cpu profiler)， 它是<a href="https://github.com/gperftools/gperftools" target="_blank" rel="external">gperftools</a>工具的一个组件， 由Google工程师为分析多线程的程序所开发。<br>Go标准库中的<a href="https://golang.org/pkg/net/http/pprof/" target="_blank" rel="external">pprof package</a>通过HTTP的方式为pprof工具提供数据。<br> (译者注：不止这个包，<a href="https://golang.org/pkg/runtime/pprof/" target="_blank" rel="external">runtime/pprof</a>还可以为控制台程序或者测试程序产生pprof数据)</p>
<p>既然pprof数据通过HTTP提供，所以它需要在你的应用中运行一个web服务器。可以通过 import pprof的副作用(这里副作用 side-effect 是指引入这个包让其初始化，不是贬义词)， 这个包就可以在缺省的web服务器中注册它的handler，并补需要其它额外的操作。</p>
<p>下面是一个使用pprof长时间运行的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	_ <span class="string">"net/http/pprof"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main(){</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		log.Println(http.ListenAndServe(<span class="string">"localhost:6060"</span>, <span class="constant">nil</span>))</div><div class="line">	}()</div><div class="line">	...</div></pre></td></tr></table></figure>

<h3 id="使用_pprof">使用 pprof</h3>
<p><img src="graphviz.png" alt="http://blog.golang.org/profiling-go-programs"></p>
<p>pprof能够借助grapgviz产生程序的调用图。默认情况下pprof基于对程序的30秒采样产生调用图。</p>
<ul>
<li>图中的连线代表对方法的调用， 连线上的标签代表指定的方法调用的采样值(译者注：go tool pprof显示的是调用时间)。</li>
<li>方框的大小与方法运行的采样值的大小有关。</li>
<li>每个方框由两个标签：一个是方法运行的时间占比，一个是它在采样的堆栈中出现的时间占比(译者注： 前者你可以看成flat时间，后者看成cumulate时间)。</li>
</ul>
<p><strong>在Mac上安装工具</strong>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ brew install gperftools</div><div class="line">$ brew install graphviz</div></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pprof --web localhost:<span class="number">6060</span>/debug</div></pre></td></tr></table></figure>

<p><strong>译者注</strong>：<br>我并没有使用上面的工具，因为Go开发环境已经集成了pprof工具，所以你不需要安装gperftools工具，而且使用的命令和上面的命令不一样。<br>当然graphviz是必装的。</p>
<p>你可以通过下面的命令采集30s的数据并生成SVG调用图:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go tool pprof -web http://<span class="number">10.75</span>.<span class="number">25.126</span>:<span class="number">9091</span>/debug/pprof/profile</div></pre></td></tr></table></figure>

<h3 id="go-torch">go-torch</h3>
<p><img src="torch.svg" alt="http://github.com/uber/go-torch"></p>
<p><a href="">go-torch</a>是uber开发的一个工具，使用性能分析的专家<a href="http://www.brendangregg.com" target="_blank" rel="external">Brendan Gregg</a> (译者注：口口相传的性能分析的工具图就是来自他， 性能之巅一书的作者。看他的网站可以学到很多性能相关的知识)的脚本生成火焰图。</p>
<p>和pprof一样，它也采用30秒的采样数据生成火焰图。</p>
<ul>
<li>栈帧(Stack frame,调用链)垂直堆叠，显示栈的深度</li>
<li>帧的宽度代表一个方法的运行的时间占比</li>
<li>如果一个方法被调用者调用，它会显示多次，分列在不同的调用者的堆栈上。(译者注：这点和pprof工具不同，pprof至显示一个方法的框，上面的时间标签是所有的调用者调用的时间）</li>
<li>颜色是任意的(arbitrary)， 横坐标根据字母顺序排列</li>
</ul>
<p><strong>安装</strong><br>需要安装go-torch工具和brandangregg的火焰图生成脚本：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ go get github.com/uber/go-torch</div><div class="line">$ git clone git@github.com:brendangregg/FlameGraph.git</div><div class="line">$ <span class="keyword">export</span> PATH-<span class="variable">$PATH</span>:/path/to/FlameGraph</div></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go-torch --file <span class="string">"torch.svg"</span> --url http://localhost:<span class="number">6060</span></div></pre></td></tr></table></figure>

<h3 id="GOM">GOM</h3>
<p><img src="gom.png" alt="http://github.com/rakyll/gom"></p>
<p><a href="http://github.com/rakyll/gom" target="_blank" rel="external">gom</a>是一个实时的 curses-风格的命令行工具，由Google的工程师Jaana Dogan开发。</p>
<ul>
<li>可以显示运行的goroutine和机器线程数</li>
<li>实时更新</li>
<li>出现可视化，gom还提供了基于文本的CPU和heap的数据</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get github.com/rakyll/gom/cmd/gom</div></pre></td></tr></table></figure>

<p>通过 import gom, gom同样可以注册额外的handler在缺省的服务器上，就像pprof一样。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import (</div><div class="line">	_ <span class="string">"github.com/rakyll/gom/http"</span></div><div class="line">)</div></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gom --target http://localhost:<span class="number">6060</span></div></pre></td></tr></table></figure>

<h3 id="Debug_charts">Debug charts</h3>
<p><img src="debugcharts.png" alt="http://github.com/mkevac/debugcharts"></p>
<p><a href="http://github.com/mkevac/debugcharts" target="_blank" rel="external">Debug charts</a>是由Marko Kevac开发的一个工具，使用plotly.js库来为运行的程序创建一个可视化的web视图。</p>
<ul>
<li>运行在浏览器中</li>
<li>可视化gc pause，内存分配和cpu占用等信息</li>
<li>实时更新</li>
</ul>
<p>通过import debugcharts,可以为缺省的web服务器注册额外的handler，就像pprof、gom一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	_ <span class="string">"github.com/mkevac/debugcharts"</span></div><div class="line">)</div></pre></td></tr></table></figure>

<p>然后访问 <code>localhost:6060/debug/charts</code>就可以显示相关的实时性能图表了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="http://slcjordan.github.io/post/pprofsurvey/" target="_blank" rel="external">A Short Survey of PProf Visualization Tools</a> by <a href="http://slcjordan.github.io/" target="_blank" rel="external">Jordan Crabtree</a>。</p>
<p>调试CPU相关的问题经常会涉及关于趋势的微妙问题。堆使用的峰值是否逐渐的增长？ routine在什么地方被调用，调用的频度如何？</p>
<p>一图胜千言。<br>一张图片就可以提供很多有用的上下文信息，否则如果用语言解释起来累的半死。将pprof可视化显示可以将有用的CPU统计数据与整个时间的上下文关联起来。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Go HTTTP Response代码片段]]></title>
    <link href="http://colobu.com/2017/02/22/HTTP-Response-Snippets-for-Go/"/>
    <id>http://colobu.com/2017/02/22/HTTP-Response-Snippets-for-Go/</id>
    <published>2017-02-22T04:50:54.000Z</published>
    <updated>2017-02-22T05:51:59.000Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="http://www.alexedwards.net/blog/golang-response-snippets" target="_blank" rel="external">HTTP Response Snippets for Go</a> by <a href="http://www.alexedwards.net/blog/golang-response-snippets" target="_blank" rel="external">Alex Edwards</a>.</p>
<p>受 Rails <a href="http://guides.rubyonrails.org/layouts_and_rendering.html" target="_blank" rel="external">layouts and rendering</a>启发, 我觉得写一个关于Go HTTP Response的代码片段集合是一个不错的主意， 它可以用来说明Go web应用程序中通用的HTTP Response的使用。</p>
<a id="more"></a>
<h3 id="只发送header">只发送header</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">  <span class="string">"net/http"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">  http.HandleFunc(<span class="string">"/"</span>, foo)</div><div class="line">  http.ListenAndServe(<span class="string">":3000"</span>, <span class="constant">nil</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> foo(w http.ResponseWriter, r *http.Request) {</div><div class="line">  w.Header().Set(<span class="string">"Server"</span>, <span class="string">"A Go Web Server"</span>)</div><div class="line">  w.WriteHeader<span class="number">(200</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ curl -i localhost:<span class="number">3000</span></div><div class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</div><div class="line">Server: A Go Web Server</div><div class="line">Content-Type: text/plain; charset=utf-<span class="number">8</span></div><div class="line">Content-Length: <span class="number">0</span></div></pre></td></tr></table></figure>

<h3 id="返回普通文本">返回普通文本</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">  <span class="string">"net/http"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">  http.HandleFunc(<span class="string">"/"</span>, foo)</div><div class="line">  http.ListenAndServe(<span class="string">":3000"</span>, <span class="constant">nil</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> foo(w http.ResponseWriter, r *http.Request) {</div><div class="line">  w.Write([]<span class="typename">byte</span>(<span class="string">"OK"</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>测试:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ curl -i localhost:<span class="number">3000</span></div><div class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</div><div class="line">Content-Type: text/plain; charset=utf-<span class="number">8</span></div><div class="line">Content-Length: <span class="number">2</span></div><div class="line"></div><div class="line">OK</div></pre></td></tr></table></figure>

<h3 id="返回JSON数据">返回JSON数据</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">  <span class="string">"encoding/json"</span></div><div class="line">  <span class="string">"net/http"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> {</div><div class="line">  Name    <span class="typename">string</span></div><div class="line">  Hobbies []<span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">  http.HandleFunc(<span class="string">"/"</span>, foo)</div><div class="line">  http.ListenAndServe(<span class="string">":3000"</span>, <span class="constant">nil</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> foo(w http.ResponseWriter, r *http.Request) {</div><div class="line">  profile := Profile{<span class="string">"Alex"</span>, []<span class="typename">string</span>{<span class="string">"snowboarding"</span>, <span class="string">"programming"</span>}}</div><div class="line"></div><div class="line">  js, err := json.Marshal(profile)</div><div class="line">  <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class="line">    <span class="keyword">return</span></div><div class="line">  }</div><div class="line"></div><div class="line">  w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</div><div class="line">  w.Write(js)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>测试:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ curl -i localhost:<span class="number">3000</span></div><div class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</div><div class="line">Content-Type: application/json</div><div class="line">Content-Length: <span class="number">56</span></div><div class="line"></div><div class="line">{<span class="string">"Name"</span>:<span class="string">"Alex"</span>,Hobbies<span class="string">":["</span>snowboarding<span class="string">","</span>programming<span class="string">"]}</span></div></pre></td></tr></table></figure>

<h3 id="返回XML数据">返回XML数据</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">  <span class="string">"encoding/xml"</span></div><div class="line">  <span class="string">"net/http"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> {</div><div class="line">  Name    <span class="typename">string</span></div><div class="line">  Hobbies []<span class="typename">string</span> <span class="string">`xml:"Hobbies&gt;Hobby"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">  http.HandleFunc(<span class="string">"/"</span>, foo)</div><div class="line">  http.ListenAndServe(<span class="string">":3000"</span>, <span class="constant">nil</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> foo(w http.ResponseWriter, r *http.Request) {</div><div class="line">  profile := Profile{<span class="string">"Alex"</span>, []<span class="typename">string</span>{<span class="string">"snowboarding"</span>, <span class="string">"programming"</span>}}</div><div class="line"></div><div class="line">  x, err := xml.MarshalIndent(profile, <span class="string">""</span>, <span class="string">"  "</span>)</div><div class="line">  <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class="line">    <span class="keyword">return</span></div><div class="line">  }</div><div class="line"></div><div class="line">  w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/xml"</span>)</div><div class="line">  w.Write(x)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>测试:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ curl -i localhost:<span class="number">3000</span></div><div class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</div><div class="line">Content-Type: application/xml</div><div class="line">Content-Length: <span class="number">128</span></div><div class="line"></div><div class="line">&lt;Profile&gt;</div><div class="line">  &lt;Name&gt;Alex&lt;/Name&gt;</div><div class="line">  &lt;Hobbies&gt;</div><div class="line">    &lt;Hobby&gt;snowboarding&lt;/Hobby&gt;</div><div class="line">    &lt;Hobby&gt;programming&lt;/Hobby&gt;</div><div class="line">  &lt;/Hobbies&gt;</div><div class="line">&lt;/Profile&gt;</div></pre></td></tr></table></figure>

<h3 id="文件服务">文件服务</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">  <span class="string">"net/http"</span></div><div class="line">  <span class="string">"path"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">  http.HandleFunc(<span class="string">"/"</span>, foo)</div><div class="line">  http.ListenAndServe(<span class="string">":3000"</span>, <span class="constant">nil</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> foo(w http.ResponseWriter, r *http.Request) {</div><div class="line">  <span class="comment">// Assuming you want to serve a photo at 'images/foo.png'</span></div><div class="line">  fp := path.Join(<span class="string">"images"</span>, <span class="string">"foo.png"</span>)</div><div class="line">  http.ServeFile(w, r, fp)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>测试:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ curl -I localhost:<span class="number">3000</span></div><div class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</div><div class="line">Accept-Ranges: bytes</div><div class="line">Content-Length: <span class="number">236717</span></div><div class="line">Content-Type: image/png</div><div class="line">Last-Modified: Thu, <span class="number">10</span> Oct <span class="number">2013</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">26</span> GMT</div></pre></td></tr></table></figure>

<h3 id="使用HTML模版">使用HTML模版</h3>
<p>模板文件：templates/index.html</p>
<figure class="highlight html"><figcaption><span>templates/index.html</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>Hello { { .Name } }<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipisicing elit.<span class="tag">&lt;/<span class="title">p</span>&gt;</span></div></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">  <span class="string">"html/template"</span></div><div class="line">  <span class="string">"net/http"</span></div><div class="line">  <span class="string">"path"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> {</div><div class="line">  Name    <span class="typename">string</span></div><div class="line">  Hobbies []<span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">  http.HandleFunc(<span class="string">"/"</span>, foo)</div><div class="line">  http.ListenAndServe(<span class="string">":3000"</span>, <span class="constant">nil</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> foo(w http.ResponseWriter, r *http.Request) {</div><div class="line">  profile := Profile{<span class="string">"Alex"</span>, []<span class="typename">string</span>{<span class="string">"snowboarding"</span>, <span class="string">"programming"</span>}}</div><div class="line"></div><div class="line">  fp := path.Join(<span class="string">"templates"</span>, <span class="string">"index.html"</span>)</div><div class="line">  tmpl, err := template.ParseFiles(fp)</div><div class="line">  <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class="line">    <span class="keyword">return</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">if</span> err := tmpl.Execute(w, profile); err != <span class="constant">nil</span> {</div><div class="line">    http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>测试:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ curl -i localhost:<span class="number">3000</span></div><div class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</div><div class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></div><div class="line">Content-Length: <span class="number">84</span></div><div class="line"></div><div class="line">&lt;h1&gt;Hello Alex&lt;/h1&gt;</div><div class="line">&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt;</div></pre></td></tr></table></figure>

<h3 id="使用HTML模板生成字符串">使用HTML模板生成字符串</h3>
<p>除了上面的把<code>http.ResponseWriter</code>作为模版的执行参数，还可以使用buffer得到渲染的结果。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</div><div class="line"><span class="keyword">if</span> err := tmpl.Execute(buf, profile); err != <span class="constant">nil</span> {</div><div class="line">  http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class="line">}</div><div class="line">templateString := buf.String()</div><div class="line">...</div></pre></td></tr></table></figure>

<h3 id="使用嵌套的模版">使用嵌套的模版</h3>
<p>文件：templates/layout.html</p>
<figure class="highlight html"><figcaption><span>templates/layout.html</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;title&gt;{ { template "title" . } } &lt;/title&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body</div><div class="line">    { { template "content" .  } }</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>

<p>文件：templates/index.html</p>
<figure class="highlight html"><figcaption><span>templates/index.html</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">{ { define "title" } }An example layout{ { end } }</div><div class="line"></div><div class="line">{ { define "content" } }</div><div class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>Hello { { .Name } }<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipisicing elit.<span class="tag">&lt;/<span class="title">p</span>&gt;</span></div><div class="line">{ { end } }</div></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">  <span class="string">"html/template"</span></div><div class="line">  <span class="string">"net/http"</span></div><div class="line">  <span class="string">"path"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> {</div><div class="line">  Name    <span class="typename">string</span></div><div class="line">  Hobbies []<span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">  http.HandleFunc(<span class="string">"/"</span>, foo)</div><div class="line">  http.ListenAndServe(<span class="string">":3000"</span>, <span class="constant">nil</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> foo(w http.ResponseWriter, r *http.Request) {</div><div class="line">  profile := Profile{<span class="string">"Alex"</span>, []<span class="typename">string</span>{<span class="string">"snowboarding"</span>, <span class="string">"programming"</span>}}</div><div class="line"></div><div class="line">  lp := path.Join(<span class="string">"templates"</span>, <span class="string">"layout.html"</span>)</div><div class="line">  fp := path.Join(<span class="string">"templates"</span>, <span class="string">"index.html"</span>)</div><div class="line"></div><div class="line">  <span class="comment">// Note that the layout file must be the first parameter in ParseFiles</span></div><div class="line">  tmpl, err := template.ParseFiles(lp, fp)</div><div class="line">  <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class="line">    <span class="keyword">return</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">if</span> err := tmpl.Execute(w, profile); err != <span class="constant">nil</span> {</div><div class="line">    http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>测试:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ curl -i localhost:<span class="number">3000</span></div><div class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</div><div class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></div><div class="line">Content-Length: <span class="number">180</span></div><div class="line"></div><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;title&gt;An example layout&lt;/title&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;h1&gt;Hello Alex&lt;/h1&gt;</div><div class="line">    &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="http://www.alexedwards.net/blog/golang-response-snippets" target="_blank" rel="external">HTTP Response Snippets for Go</a> by <a href="http://www.alexedwards.net/blog/golang-response-snippets" target="_blank" rel="external">Alex Edwards</a>.</p>
<p>受 Rails <a href="http://guides.rubyonrails.org/layouts_and_rendering.html" target="_blank" rel="external">layouts and rendering</a>启发, 我觉得写一个关于Go HTTP Response的代码片段集合是一个不错的主意， 它可以用来说明Go web应用程序中通用的HTTP Response的使用。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编写地道的Go代码]]></title>
    <link href="http://colobu.com/2017/02/07/write-idiomatic-golang-codes/"/>
    <id>http://colobu.com/2017/02/07/write-idiomatic-golang-codes/</id>
    <published>2017-02-07T09:43:19.000Z</published>
    <updated>2017-03-10T02:36:26.000Z</updated>
    <content type="html"><![CDATA[<p>在阅读本文之前，我先推荐你阅读官方的 <a href="https://golang.org/doc/effective_go.html" target="_blank" rel="external">Effective Go</a>文档，或者是中文翻译版: <a href="https://go-zh.org/doc/effective_go.html" target="_blank" rel="external">高效Go编程</a>，它提供了很多编写标准而高效的Go代码指导，本文不会再重复介绍这些内容。</p>
<p>最地道的Go代码就是Go的标准库的代码，你有空的时候可以多看看Google的工程师是如何实现的。</p>
<p>本文仅作为一个参考，如果你有好的建议和意见，欢迎添加评论。</p>
<a id="more"></a>
<h3 id="注释">注释</h3>
<p>可以通过 <code>/* …… */</code> 或者 <code>// ……</code>增加注释， <code>//</code>之后应该加一个空格。</p>
<p>如果你想在每个文件中的头部加上注释，需要在版权注释和 Package前面加一个空行，否则版权注释会作为Package的注释。  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// Copyright <span class="number">2009</span> The Go Authors. <span class="keyword">All</span> rights reserved.</div><div class="line">// <span class="keyword">Use</span> <span class="keyword">of</span> this source code <span class="keyword">is</span> governed by a BSD-style</div><div class="line">// license that can be found <span class="keyword">in</span> the LICENSE <span class="keyword">file</span>.</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">Package net provides a portable interface for network I/O, including</div><div class="line">TCP/IP, UDP, domain name resolution, and Unix domain sockets.</div><div class="line">......</div><div class="line"></div><div class="line">*/</div><div class="line"><span class="keyword">package</span> net</div><div class="line"></div><div class="line">......</div></pre></td></tr></table></figure>

<p>注释应该用一个完整的句子，注释的第一个单词应该是要注释的指示符，以便在godoc中容易查找。</p>
<p>注释应该以一个句点<code>.</code>结束。</p>
<h3 id="声明slice">声明slice</h3>
<p>声明空的slice应该使用下面的格式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> t []<span class="typename">string</span></div></pre></td></tr></table></figure>

<p>而不是这种格式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t := []<span class="typename">string</span>{}</div></pre></td></tr></table></figure>

<p>前者声明了一个<code>nil</code> slice而后者是一个长度为0的非nil的slice。</p>
<!--
###  crypto/rand

https://github.com/golang/go/issues/11871   
https://zh.wikipedia.org/wiki/密码学安全伪随机数生成器
https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator-->
<h3 id="关于字符串大小写">关于字符串大小写</h3>
<p>错误字符串不应该大写。<br>应该写成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fmt.Errorf(<span class="string">"failed to write data"</span>)</div></pre></td></tr></table></figure>

<p>而不是写成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fmt.Errorf(<span class="string">"Failed to write data"</span>)</div></pre></td></tr></table></figure>

<p>这是因为这些字符串可能和其它字符串相连接，组合后的字符串如果中间有大写字母开头的单词很突兀，除非这些首字母大写单词是固定使用的单词。</p>
<p>缩写词必须保持一致，比如都大写<code>URL</code>或者小写<code>url</code>。比如<code>HTTP</code>、<code>ID</code>等。<br>例如<code>sendOAuth</code>或者<code>oauthSend</code>。</p>
<p>常量一般声明为<code>MaxLength</code>,而不是以下划线分隔<code>MAX_LENGTH</code>或者<code>MAXLENGTH</code>。</p>
<p>也就是Go语言一般使用<code>MixedCaps</code>或者<code>mixedCaps</code>命名的方式区分包含多个单词的名称。</p>
<h3 id="处理error而不是panic或者忽略">处理error而不是panic或者忽略</h3>
<p>为了编写强壮的代码，不用使用<code>_</code>忽略错误，而是要处理每一个错误，尽管代码写起来可能有些繁琐。</p>
<p>尽量不要使用panic。</p>
<h3 id="一些名称">一些名称</h3>
<p>有些单词可能有多种写法，在项目中应该保持一致，比如Golang采用的写法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// marshaling</span></div><div class="line"><span class="comment">// unmarshaling</span></div><div class="line"><span class="comment">// canceling</span></div><div class="line"><span class="comment">// cancelation</span></div></pre></td></tr></table></figure>

<p>而不是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// marshalling</span></div><div class="line"><span class="comment">// unmarshalling</span></div><div class="line"><span class="comment">// cancelling</span></div><div class="line"><span class="comment">// cancellation</span></div></pre></td></tr></table></figure>

<p>包名应该用单数的形式，比如<code>util</code>、<code>model</code>,而不是<code>utils</code>、<code>models</code>。</p>
<p>Receiver 的名称应该缩写，一般使用一个或者两个字符作为Receiver的名称，如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (f foo) method() {</div><div class="line">	...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果方法中没有使用receiver,还可以省略receiver name,这样更清晰的表明方法中没有使用它:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (foo) method() {</div><div class="line">	...</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="package级的Error变量">package级的Error变量</h3>
<p>通常会把自定义的Error放在package级别中，统一进行维护:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">	ErrCacheMiss = errors.New(<span class="string">"memcache: cache miss"</span>)</div><div class="line">	ErrCASConflict = errors.New(<span class="string">"memcache: compare-and-swap conflict"</span>)</div><div class="line">	ErrNotStored = errors.New(<span class="string">"memcache: item not stored"</span>)</div><div class="line">	ErrServerError = errors.New(<span class="string">"memcache: server error"</span>)</div><div class="line">	ErrNoStats = errors.New(<span class="string">"memcache: no statistics available"</span>)</div><div class="line">	ErrMalformedKey = errors.New(<span class="string">"malformed: key is too long or contains invalid characters"</span>)</div><div class="line">	ErrNoServers = errors.New(<span class="string">"memcache: no servers configured or available"</span>)</div><div class="line">)</div></pre></td></tr></table></figure>

<p>并且变量以<code>Err</code>开头。</p>
<h3 id="空字符串检查">空字符串检查</h3>
<p>不要使用下面的方式检查空字符串:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) ==<span class="number"> 0</span> {</div><div class="line">	...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>而是使用下面的方式 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> s == <span class="string">""</span> {</div><div class="line">	...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面的方法更是语法不对：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> s == nil || s == <span class="string">""</span> {</div><div class="line">	<span class="keyword">...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="非空slice检查">非空slice检查</h3>
<p>不要使用下面的方式检查空的slice:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> s != <span class="constant">nil</span> && <span class="built_in">len</span>(s) &gt;<span class="number"> 0</span> {</div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>直接比较长度即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &gt;<span class="number"> 0</span> {</div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>同样的道理也适用 <code>map</code>和<code>channel</code>。</p>
<h3 id="省略不必要的变量">省略不必要的变量</h3>
<p>比如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> whitespaceRegex, _ = regexp.Compile(<span class="string">"\\s+"</span>)</div></pre></td></tr></table></figure>

<p>可以简写为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> whitespaceRegex = regexp.MustCompile(<span class="string">`\s+`</span>)</div></pre></td></tr></table></figure>

<p>有时候你看到的一些第三方的类提供了类似的方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Foo(...) (...,error)</div><div class="line"><span class="keyword">func</span> MustFoo(...) (...)</div></pre></td></tr></table></figure>

<p>MustFoo一般提供了一个不带error返回的类型。</p>
<h3 id="直接使用bool值">直接使用bool值</h3>
<p>对于bool类型的变量<code>var b bool</code>,直接使用它作为判断条件，而不是使用它和true/false进行比较</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> b {</div><div class="line">    ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">if</span> !b {</div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>而不是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> b == <span class="constant">true</span> {</div><div class="line">    ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">if</span> b == <span class="constant">false</span> {</div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="byte/string_slice相等性比较">byte/string slice相等性比较</h3>
<p>不要使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">var</span> s1 []<span class="typename">byte</span></div><div class="line">   <span class="keyword">var</span> s2 []<span class="typename">byte</span></div><div class="line">   ...</div><div class="line">bytes.Compare(s1, s2) ==<span class="number"> 0</span></div><div class="line">bytes.Compare(s1, s2) !=<span class="number"> 0</span></div></pre></td></tr></table></figure>

<p>而是:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">var</span> s1 []<span class="typename">byte</span></div><div class="line">   <span class="keyword">var</span> s2 []<span class="typename">byte</span></div><div class="line">   ...</div><div class="line">bytes.Equal(s1, s2) ==<span class="number"> 0</span></div><div class="line">bytes.Equal(s1, s2) !=<span class="number"> 0</span></div></pre></td></tr></table></figure>

<h3 id="检查是否包含子字符串">检查是否包含子字符串</h3>
<p>不要使用 <code>strings.IndexRune(s1, &#39;x&#39;) &gt; -1</code>及其类似的方法<code>IndexAny</code>、<code>Index</code>检查字符串包含，<br>而是使用<code>strings.ContainsRune</code>、<code>strings.ContainsAny</code>、<code>strings.Contains</code>来检查。</p>
<h3 id="使用类型转换而不是struct字面值">使用类型转换而不是struct字面值</h3>
<p>对于两个类型:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> t1 <span class="keyword">struct</span> {</div><div class="line">	a <span class="typename">int</span></div><div class="line">	b <span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> t2 <span class="keyword">struct</span> {</div><div class="line">	a <span class="typename">int</span></div><div class="line">	b <span class="typename">int</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以使用类型转换将类型t1的变量转换成类型t2的变量，而不是像下面的代码进行转换</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">v1 := t1<span class="number">{1</span>,<span class="number"> 2</span>}</div><div class="line">_ = t2{v1.a, v1.b}</div></pre></td></tr></table></figure>

<p>应该使用类型转换，因为这两个struct底层的数据结构是一致的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_ = t2(v1)</div></pre></td></tr></table></figure>

<h3 id="复制slice">复制slice</h3>
<p>不要使用下面的复制slice的方式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b1, b2 []<span class="typename">byte</span></div><div class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> b1 { </div><div class="line">		b2[i] = v</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> b1 { </div><div class="line">		b2[i] = b1[i]</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>而是使用内建的<code>copy</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">copy</span>(b2, b1)</div></pre></td></tr></table></figure>

<h3 id="不要在for中使用多此一举的true">不要在for中使用多此一举的true</h3>
<p>不要这样:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> <span class="constant">true</span> {</div><div class="line">}</div></pre></td></tr></table></figure>

<p>而是要这样:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> {</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="尽量缩短if">尽量缩短if</h3>
<p>下面的代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   x := <span class="constant">true</span></div><div class="line"><span class="keyword">if</span> x {</div><div class="line">	<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">}</div><div class="line"><span class="keyword">return</span> <span class="constant">false</span></div></pre></td></tr></table></figure>

<p>可以用<code>return x</code>代替。</p>
<p>同样下面的代码也可以使用<code>return err</code>代替：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fn1() error {</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fn1() <span class="typename">bool</span>{</div><div class="line">    ...</div><div class="line">    b := fn()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> b {</div><div class="line">		... </div><div class="line">        <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">return</span> <span class="constant">false</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>应该写成:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fn1() <span class="typename">bool</span>{</div><div class="line">    ...</div><div class="line">    b := fn()</div><div class="line"></div><div class="line">    <span class="keyword">if</span> !b {</div><div class="line">        <span class="keyword">return</span> <span class="constant">false</span></div><div class="line">    }</div><div class="line">	</div><div class="line">	... </div><div class="line">    <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	</div><div class="line">}</div></pre></td></tr></table></figure>

<p>也就是减少if的分支／缩进。</p>
<h3 id="append_slice">append slice</h3>
<p>不要这样:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">var</span> a, b []<span class="typename">int</span></div><div class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a {</div><div class="line">	b = <span class="built_in">append</span>(b, v)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>而是要这样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a, b []<span class="typename">int</span></div><div class="line">b = <span class="built_in">append</span>(b, a...)</div></pre></td></tr></table></figure>

<h3 id="简化range">简化range</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span></div><div class="line">   <span class="keyword">for</span> _ = <span class="keyword">range</span> m { </div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> _, _ = <span class="keyword">range</span> m {</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以简化为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> <span class="keyword">range</span> m {</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>对<code>slice</code>和<code>channel</code>也适用。</p>
<h3 id="正则表达式中使用raw字符串避免转义字符">正则表达式中使用<code>raw</code>字符串避免转义字符</h3>
<p>在使用正则表达式时，不要:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">regexp.MustCompile(<span class="string">"\\."</span>) </div><div class="line">regexp.Compile(<span class="string">"\\."</span>)</div></pre></td></tr></table></figure>

<p>而是直接使用raw字符串，可以避免大量的<code>\</code>出现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">regexp.MustCompile(<span class="string">`\.`</span>) </div><div class="line">regexp.Compile(<span class="string">`\.`</span>)</div></pre></td></tr></table></figure>

<h3 id="简化只包含单个case的select">简化只包含单个case的select</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> &lt;-ch:</div><div class="line">}</div></pre></td></tr></table></figure>

<p>直接写成<code>&lt;-ch</code>即可。send也一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">for</span> { </div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> x := &lt;-ch:</div><div class="line">		_ = x</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>直接改成 <code>for-range</code>即可。</p>
<p>这种简化只适用包含单个case的情况。</p>
<h3 id="slice的索引">slice的索引</h3>
<p>有时可以忽略slice的第一个索引或者第二个索引：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s []<span class="typename">int</span></div><div class="line">_ = s[:<span class="built_in">len</span>(s)]</div><div class="line">_ = s<span class="number">[0</span>:<span class="built_in">len</span>(s)]</div></pre></td></tr></table></figure>

<p>可以写成<code>s[:]</code></p>
<h3 id="使用time-Since">使用time.Since</h3>
<p>下面的代码经常会用到：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_ = time.Now().Sub(t1)</div></pre></td></tr></table></figure>

<p>可以简写为:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_ = time.Since(t1)</div></pre></td></tr></table></figure>

<h3 id="使用strings-TrimPrefix／strings-TrimSuffix_掐头去尾">使用strings.TrimPrefix／strings.TrimSuffix 掐头去尾</h3>
<p>不要自己判断字符串是否以XXX开头或者结尾，然后自己再去掉XXX,而是使用现成的<code>strings.TrimPrefix／strings.TrimSuffix</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">var</span> s1 = <span class="string">"a string value"</span></div><div class="line">   <span class="keyword">var</span> s2 = <span class="string">"a "</span></div><div class="line">   <span class="keyword">var</span> s3 <span class="typename">string</span></div><div class="line"><span class="keyword">if</span> strings.HasPrefix(s1, s2) { </div><div class="line">	s3 = s1[<span class="built_in">len</span>(s2):]</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以简化为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="string">"a string value"</span></div><div class="line"><span class="keyword">var</span> s2 = <span class="string">"a "</span></div><div class="line"><span class="keyword">var</span> s3 = strings.TrimPrefix(s1, s2)</div></pre></td></tr></table></figure>

<h3 id="使用工具检查你的代码">使用工具检查你的代码</h3>
<p>以上的很多优化规则都可以通过工具检查，下面列出了一些有用的工具：</p>
<ol>
<li><a href="https://golang.org/pkg/fmt/" target="_blank" rel="external">go fmt</a></li>
<li><a href="https://golang.org/cmd/vet/" target="_blank" rel="external">go vet</a></li>
<li><a href="https://github.com/dominikh/go-tools/blob/master/cmd/gosimple" target="_blank" rel="external">gosimple</a></li>
<li><a href="https://github.com/dominikh/go-tools/blob/master/cmd/keyify" target="_blank" rel="external">keyify</a></li>
<li><a href="https://github.com/dominikh/go-tools/blob/master/cmd/staticcheck" target="_blank" rel="external">staticcheck</a></li>
<li><a href="https://github.com/dominikh/go-tools/blob/master/cmd/unused" target="_blank" rel="external">unused</a></li>
<li><a href="https://github.com/golang/lint" target="_blank" rel="external">golint</a></li>
<li><a href="https://github.com/client9/misspell" target="_blank" rel="external">misspell</a></li>
<li><a href="https://godoc.org/golang.org/x/tools/cmd/goimports" target="_blank" rel="external">goimports</a></li>
<li><a href="https://github.com/kisielk/errcheck" target="_blank" rel="external">errcheck</a></li>
<li><a href="https://github.com/opennota/check" target="_blank" rel="external">aligncheck</a></li>
<li><a href="https://github.com/opennota/check" target="_blank" rel="external">structcheck</a></li>
<li><a href="https://github.com/opennota/check" target="_blank" rel="external">varcheck</a></li>
</ol>
<h3 id="参考文档">参考文档</h3>
<ol>
<li><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="external">https://golang.org/doc/effective_go.html</a></li>
<li><a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="external">https://github.com/golang/go/wiki/CodeReviewComments</a></li>
<li><a href="https://dmitri.shuralyov.com/idiomatic-go" target="_blank" rel="external">https://dmitri.shuralyov.com/idiomatic-go</a></li>
<li><a href="https://talks.golang.org/2014/readability.slide#1" target="_blank" rel="external">https://talks.golang.org/2014/readability.slide#1</a></li>
<li><a href="https://github.com/dominikh/go-tools/tree/master/simple" target="_blank" rel="external">https://github.com/dominikh/go-tools/tree/master/simple</a></li>
<li><a href="https://github.com/dominikh/go-tools/tree/master/cmd/structlayout-optimize" target="_blank" rel="external">https://github.com/dominikh/go-tools/tree/master/cmd/structlayout-optimize</a></li>
<li><a href="https://go-zh.org" target="_blank" rel="external">https://go-zh.org</a></li>
<li><a href="https://docs.google.com/presentation/d/1OT-dMNbiwOPeaivQOldok2hUUNMTvSC0GJ67JohLt5U/pub?start=false&amp;loop=false&amp;delayms=3000&amp;slide=id.g18b1f95882_1_135" target="_blank" rel="external">https://docs.google.com/presentation/d/1OT-dMNbiwOPeaivQOldok2hUUNMTvSC0GJ67JohLt5U/pub?start=false&amp;loop=false&amp;delayms=3000&amp;slide=id.g18b1f95882_1_135</a></li>
<li><a href="https://github.com/d-smith/go-training/blob/master/idiomatic-go.md" target="_blank" rel="external">https://github.com/d-smith/go-training/blob/master/idiomatic-go.md</a></li>
<li><a href="https://github.com/opennota/check" target="_blank" rel="external">https://github.com/opennota/check</a></li>
<li><a href="http://golang-sizeof.tips" target="_blank" rel="external">http://golang-sizeof.tips</a></li>
<li><a href="https://github.com/mibk/dupl" target="_blank" rel="external">https://github.com/mibk/dupl</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>在阅读本文之前，我先推荐你阅读官方的 <a href="https://golang.org/doc/effective_go.html" target="_blank" rel="external">Effective Go</a>文档，或者是中文翻译版: <a href="https://go-zh.org/doc/effective_go.html" target="_blank" rel="external">高效Go编程</a>，它提供了很多编写标准而高效的Go代码指导，本文不会再重复介绍这些内容。</p>
<p>最地道的Go代码就是Go的标准库的代码，你有空的时候可以多看看Google的工程师是如何实现的。</p>
<p>本文仅作为一个参考，如果你有好的建议和意见，欢迎添加评论。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Golang 知识点总结]]></title>
    <link href="http://colobu.com/2017/02/01/golang-summaries/"/>
    <id>http://colobu.com/2017/02/01/golang-summaries/</id>
    <published>2017-02-01T13:55:02.000Z</published>
    <updated>2017-02-03T00:53:19.000Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="http://www.tapirgames.com/blog/golang-summaries" target="_blank" rel="external">Golang Summaries</a> by <a href="http://twitter.com/TapirLiu" target="_blank" rel="external">TapirLiu</a></p>
<p>本文是由TapirLiu总结的Golang中的一些知识点，对于深入学习Golang很有帮助，所以我特意翻译了一下。</p>
<a id="more"></a>
<h3 id="各种类型复制的时候的花费">各种类型复制的时候的花费</h3>
<p>本节标题也可以叫做“各种类型的值的大小” (the sizes of values of all kinds of types),底层可被不同的值共享的数据的大小未被计算。</p>
<p>下面的表格中一个 <code>word</code>在32bit操作系统中代表4个字节，在64bit操作系统中代表8个字节，内容基于官方的Go 1.7的编译器。</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Cost Of Value Copying (Value Size)</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>1 byte</td>
</tr>
<tr>
<td>int8, uint8, byte</td>
<td>1 byte</td>
</tr>
<tr>
<td>int16, uint16</td>
<td>2 bytes</td>
</tr>
<tr>
<td>int32, uint32, rune</td>
<td>4 bytes</td>
</tr>
<tr>
<td>int64, uint64</td>
<td>8 bytes</td>
</tr>
<tr>
<td>int, uint, uintptr</td>
<td>1 word</td>
</tr>
<tr>
<td>string</td>
<td>2 words</td>
</tr>
<tr>
<td>pointer</td>
<td>1 word</td>
</tr>
<tr>
<td>slice</td>
<td>3 words</td>
</tr>
<tr>
<td>map</td>
<td>1 word</td>
</tr>
<tr>
<td>channel</td>
<td>1 word</td>
</tr>
<tr>
<td>function</td>
<td>1 word</td>
</tr>
<tr>
<td>interface</td>
<td>2 words</td>
</tr>
<tr>
<td>struct</td>
<td>the sum of sizes of all fields</td>
</tr>
<tr>
<td>array</td>
<td>(element value size) * (array length)</td>
</tr>
</tbody>
</table>
<h3 id="可使用内建函数的类型_(len、cap、close、delete、make)">可使用内建函数的类型 (<code>len</code>、<code>cap</code>、<code>close</code>、<code>delete</code>、<code>make</code>)</h3>
<table>
<thead>
<tr>
<th></th>
<th>len</th>
<th>cap</th>
<th>close</th>
<th>delete</th>
<th>make</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>array (and array pointer)</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>slice</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
<td></td>
<td>Yes</td>
</tr>
<tr>
<td>map</td>
<td>Yes</td>
<td></td>
<td></td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>channel</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>上面的所有类型都可以使用 <code>range</code>遍历。</p>
<p>可以用作<code>len</code>函数参数的类型也叫做容器类型。</p>
<h3 id="内建容器类型的值比较">内建容器类型的值比较</h3>
<p>假定容器的值可寻址(addressable)。</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>长度可变</th>
<th>元素可更新</th>
<th>元素可寻址</th>
<th>查找会更改容器的长度</th>
<th>底层元素可以共享</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>array</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>slice</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>map</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>channel</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<h3 id="组合类型T{-}的值比较">组合类型<code>T{...}</code>的值比较</h3>
<table>
<thead>
<tr>
<th>Type (<code>T</code>)</th>
<th><code>T{}</code>是类型<code>T</code>的零值?</th>
</tr>
</thead>
<tbody>
<tr>
<td>struct</td>
<td>Yes</td>
</tr>
<tr>
<td>array</td>
<td>Yes</td>
</tr>
<tr>
<td>slice</td>
<td>No (零值是 <code>nil</code>)</td>
</tr>
<tr>
<td>map</td>
<td>No (零值是 <code>nil</code>)</td>
</tr>
</tbody>
</table>
<h3 id="零值是nil的类型">零值是<code>nil</code>的类型</h3>
<table>
<thead>
<tr>
<th>Type (T)</th>
<th>Size Of T(nil)</th>
</tr>
</thead>
<tbody>
<tr>
<td>pointer</td>
<td>1 word</td>
</tr>
<tr>
<td>slice</td>
<td>3 words</td>
</tr>
<tr>
<td>map</td>
<td>1 word</td>
</tr>
<tr>
<td>channel</td>
<td>1 word</td>
</tr>
<tr>
<td>function</td>
<td>1 word</td>
</tr>
<tr>
<td>interface</td>
<td>2 words</td>
</tr>
</tbody>
</table>
<p>这些类型的零值的大小和上面类型的大小保持一致。</p>
<h3 id="编译时被执行的函数">编译时被执行的函数</h3>
<p>如果函数在编译时被执行，那么它的返回值是常量。</p>
<table class="table table-bordered text-center" style="width: auto !important;"><thead>    <tr>    <th class="text-center">Function</th>    <th class="text-center">返回值</th>    <th class="text-center">编译时便计算?</th>    </tr></thead><tbody>    <tr class="active">    <th scope="row" class="text-center">unsafe.Sizeof</th>    <td rowspan="3" style="vertical-align: middle"><code>uintptr</code></td>    <td rowspan="3" style="vertical-align: middle">Yes, 总是</td>    </tr>    <tr class="active">    <th scope="row" class="text-center" style="vertical-align: middle">unsafe.Alignof</th>    </tr>    <tr class="active">    <th scope="row" class="text-center" style="vertical-align: middle">unsafe.Offsetof</th>    </tr>    <tr>    <th scope="row" class="text-center" style="vertical-align: middle">len</th>    <td rowspan="2" style="vertical-align: middle"><code>int</code></td>    <td rowspan="2">        有时候是        <br><br>        <div class="text-left">        <a href="https://golang.org/ref/spec#Length_and_capacity" target="_blank" rel="external">Go 规范中讲到</a>:         <ul>        <li>        如果s是字符串常量，则<code>len(s)</code>是常量.         </li>        <li>        如果s是数组或者是数组指针，则<code>len(s)</code>是常量.         </li>        </ul>        </div>    </td>    </tr>    <tr>    <th scope="row" class="text-center" style="vertical-align: middle">cap</th>    </tr>    <tr class="active">    <th scope="row" class="text-center" style="vertical-align: middle">real</th>    <td rowspan="2" style="vertical-align: middle"><code>float64</code><br>(默认类型)</td>    <td rowspan="2">        有时候是        <br><br>        <div class="text-left">        <a href="https://golang.org/ref/spec#Constants" target="_blank" rel="external">Go 规范中讲到</a>:        如果<code>s</code>是复数常量，则<code>real(s)</code> 和<code>imag(s)</code> 是常量.        </div>    </td>    </tr>    <tr class="active">    <th scope="row" class="text-center" style="vertical-align: middle">imag</th>    </tr>    <tr>    <th scope="row" class="text-center" style="vertical-align: middle">complex</th>    <td style="vertical-align: middle"><code>complex128</code><br>(默认类型)</td>    <td>        有时候是        <br><br>        <div class="text-left">        <a href="https://golang.org/ref/spec#Constants" target="_blank" rel="external">Go 规范中讲到</a>:        如果<code>sr</code> 和<code>si</code>都是常量，则<code>complex(sr, si)</code>是常量.        </div>    </td>    </tr></tbody></table>

<h3 id="不能被寻址的值">不能被寻址的值</h3>
<p>下面的值不能被寻址(addresses):</p>
<ul>
<li>bytes in strings：字符串中的字节</li>
<li>map elements：map中的元素</li>
<li>dynamic values of interface values (exposed by type assertions)：接口的动态值</li>
<li>constant values：常量</li>
<li>literal values：字面值</li>
<li>package level functions：包级别的函数</li>
<li>methods (used as function values)：方法</li>
<li>intermediate values：中间值<ul>
<li>function callings</li>
<li>explicit value conversions</li>
<li>all sorts of operations, except pointer dereference operations, but including:<ul>
<li>channel receive operations</li>
<li>sub-string operations</li>
<li>sub-slice operations</li>
<li>addition, subtraction, multiplication, and division, etc.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注意， <code>&amp;T{}</code>相当于<code>tmp := T{}; (&amp;tmp)</code>的语法糖，所以<code>&amp;T{}</code>可合法不意味着<code>T{}</code>可寻址。</p>
<p>下面的值可以寻址:</p>
<ul>
<li>variables</li>
<li>fields of addressable structs</li>
<li>elements of addressable arrays</li>
<li>elements of any slices (whether the slices are addressable or not)</li>
<li>pointer dereference operations</li>
</ul>
<h3 id="不支持比较的类型">不支持比较的类型</h3>
<p>下面的类型不支持直接比较:</p>
<ul>
<li>map</li>
<li>slice</li>
<li>function</li>
<li>struct types containing incomparable fields</li>
<li>array types with incomparable elements</li>
</ul>
<p>这些不能直接比较的类型不能用做map的key值。</p>
<p>注意：尽管map、slice、function类型不支持直接比较，但是它们的值却可以和<code>nil</code>直接比较。如果两个接口的动态类型不能比较，运行时比较这两个接口会panic,除非其中一个的动态值是untyped nil。</p>
<h3 id="可命名的源代码元素">可命名的源代码元素</h3>
<p>下面的源代码元素可以命名，名称必须是 <a href="https://golang.org/ref/spec#Identifiers" target="_blank" rel="external">Identifier</a></p>
<table>
<thead>
<tr>
<th></th>
<th>可以使用 <code>_</code> 做名称？</th>
</tr>
</thead>
<tbody>
<tr>
<td>package</td>
<td>No</td>
</tr>
<tr>
<td>import</td>
<td>Yes</td>
</tr>
<tr>
<td>type</td>
<td>Yes</td>
</tr>
<tr>
<td>variable</td>
<td>Yes</td>
</tr>
<tr>
<td>constant</td>
<td>Yes</td>
</tr>
<tr>
<td>function</td>
<td>Yes</td>
</tr>
<tr>
<td>label</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<h3 id="命名的源代码元素可以使用_()分组声明">命名的源代码元素可以使用 <code>()</code>分组声明</h3>
<p>下面的类型可以使用<code>()</code>分组生命</p>
<ul>
<li>import</li>
<li>type</li>
<li>variable</li>
<li>constant</li>
</ul>
<p>函数和标签(label)不能使用<code>()</code>分组声明。</p>
<h3 id="可以在函数内外声明的源代码元素">可以在函数内外声明的源代码元素</h3>
<p>下面的类型可以声明在函数内，也可以声明在函数外：</p>
<ul>
<li>type</li>
<li>variable</li>
<li>constant</li>
</ul>
<p><code>import</code>必须在其它元素的声明的前面(<code>package</code>语句的后面)。</p>
<p>函数在其它函数的外面声明。(译者注:函数变量/匿名函数可以在函数内声明)</p>
<p>标签(label)必须声明在函数内。</p>
<h3 id="可以返回一个可选bool返回值的表达式">可以返回一个可选bool返回值的表达式</h3>
<p>下面的表达式可以返回一个可选的bool值：</p>
<table>
<thead>
<tr>
<th></th>
<th>可选的bool返回值的意义</th>
<th>忽略可选值会影响程序的行为?</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>map element access</strong></td>
<td>map中是否包含要</td>
<td>No</td>
</tr>
<tr>
<td><strong>channel value receive</strong></td>
<td>在channel关闭前收到的值是否已发出</td>
<td>No</td>
</tr>
<tr>
<td><strong>type assertion</strong></td>
<td>接口的动态类型是否符合asserted type</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>(当可选值被忽略时，如果类型不match则会抛出panic)|</p>
<h3 id="使用channel机制永远阻塞当前goroutine的方法">使用channel机制永远阻塞当前goroutine的方法</h3>
<p>下面的方法都可以永远阻塞当前的goroutine:</p>
<p>1、receive from a channel which no values will be sent to</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;-<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})　</div><div class="line"><span class="comment">// or</span></div><div class="line">&lt;-<span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{})</div></pre></td></tr></table></figure>

<p>2、send value to a channel which no ones will receive values from</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{}) &lt;- <span class="keyword">struct</span>{}{}</div><div class="line"><span class="comment">// or</span></div><div class="line"><span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>{}) &lt;- <span class="keyword">struct</span>{}{}</div></pre></td></tr></table></figure>

<p>3、receive value from a nil channel</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}(<span class="constant">nil</span>)</div></pre></td></tr></table></figure>

<p>4、send value to a nil channel</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">chan</span> <span class="keyword">struct</span>{}(<span class="constant">nil</span>) &lt;- <span class="keyword">struct</span>{}{}</div></pre></td></tr></table></figure>

<p>5、use a bare select block</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span>{}</div></pre></td></tr></table></figure>

<h3 id="连接字符串的几种方法">连接字符串的几种方法</h3>
<p>下面几种方法都可以连接字符串(译者注:不考虑性能)：</p>
<p>1、使用<code>+</code>连接字符串。如果连接的字符串少于6个，官方的编译器会对此优化，所以通常使用<code>+</code>简便而有效。<br>2、使用<code>strings</code>包中的<a href="https://golang.org/pkg/strings/#Join" target="_blank" rel="external">strings.Join</a>连接字符串。<br>3、使用<code>fmt</code>包中的<code>fmt.Sprintf</code>, <code>fmt.Sprint</code> 和 <code>fmt.Sprintln</code>连接字符串。这三个方法可以将任意的类型连接成字符串。<code>fmt.Sprintln</code>会在字符串之间加空格，在字符串尾部加新的换行符。如果两个值中的至少一个不是字符串，<code>fmt.Sprint</code>会在它们之间加空格。<br>4、包<code>bytes</code>的<code>Buffer</code>类型(或者内建函数<code>copy</code>)可以用来构建 byte slice, byte slice可以方便地转换成字符串。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="http://www.tapirgames.com/blog/golang-summaries" target="_blank" rel="external">Golang Summaries</a> by <a href="http://twitter.com/TapirLiu" target="_blank" rel="external">TapirLiu</a></p>
<p>本文是由TapirLiu总结的Golang中的一些知识点，对于深入学习Golang很有帮助，所以我特意翻译了一下。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kafka通讯协议指南]]></title>
    <link href="http://colobu.com/2017/01/26/A-Guide-To-The-Kafka-Protocol/"/>
    <id>http://colobu.com/2017/01/26/A-Guide-To-The-Kafka-Protocol/</id>
    <published>2017-01-26T15:12:17.000Z</published>
    <updated>2017-01-28T03:39:42.000Z</updated>
    <content type="html"><![CDATA[<p>官方英文版本: <a href="https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol" target="_blank" rel="external">A Guide To The Kafka Protocol</a></p>
<p>中文翻译： <a href="http://watchword.space" target="_blank" rel="external">watchword</a> 翻译于2016年1月31日，修改于6月17日，基于原文2016年5月5日修改版本（v.106）修改翻译： <a href="http://watchword.space/blog/?p=39" target="_blank" rel="external">Kafka通讯协议指南</a></p>
<p><a href="http://colobu.com" target="_blank" rel="external">smallnest</a> 基于原文 Jan 20, 2017版本修改。</p>
<p>如果想深入了解Kafka的通讯协议的话，这篇文章不可不读。感谢 watchword 将原文翻译成了中文，我基于最新版进行了修订,修订和完善翻译中的错误。</p>
<a id="more"></a>
<h2 id="简介">简介</h2>
<p>此文档涵盖了Kafka 0.8及之后版本实现的通讯协议。其目的是提供一个易读的协议文档， 包含可用的请求API及其二进制格式， 以及如何正确使用他们来实现一个客户端。本文假设您已经了解了Kafka基本的设计以及<a href="https://kafka.apache.org/documentation.html#design" target="_blank" rel="external">术语</a>。</p>
<p><a href="https://cwiki.apache.org/confluence/display/KAFKA/Wire+Format" target="_blank" rel="external">0.7</a>和更早的版本所使用的协议与此类似，但我们（希望）通过一次性地斩断兼容性，以便清理原有设计上的沉疴，并且泛化一些概念。</p>
<h2 id="概述">概述</h2>
<p>Kafka协议是相当简单的，只有六种核心的客户端请求的API：</p>
<ol>
<li>元数据（Metadata） – 描述可用的brokers，包括他们的主机和端口信息，并给出了每个broker上分别存有哪些分区Partition；</li>
<li>发送（Send） – 发送消息到broker；</li>
<li>获取（Fetch） – 从broker获取消息，其中，一个获取数据，一个获取集群的元数据，还有一个获取topic的偏移量信息；</li>
<li>偏移量（Offsets） – 获取给定topic的分区的可用偏移量信息；</li>
<li>偏移量提交（Offset Commit） – 提交消费者组（Consumer Group）的一组偏移量；</li>
<li>偏移量获取（Offset Fetch） – 获取一个消费者组的一组偏移量；</li>
</ol>
<p>每一种API都将在下面详细说明。此外，从0.9版本开始，Kafka支持为消费者和Kafka Connect提供通用的分组管理。为此客户端API又提供五个请求：</p>
<ol>
<li>分组协调者（GroupCoordinator） – 用来定位一个分组当前的协调者。</li>
<li>加入分组（JoinGroup） – 成为某一个分组的一个成员，当分组不存在（没有一个成员时）创建分组。</li>
<li>同步分组（SyncGroup） – 同步分组中所有成员的状态（例如分发分区分配信息(Partition Assignments)到各个组员）。</li>
<li>心跳（Heartbeat） – 保持组内成员的活跃状态。</li>
<li>离开分组（LeaveGroup） – 直接离开一个组。</li>
</ol>
<p>最后，有几个管理API，可用于监控/管理的Kafka集群（<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-4+-+Command+line+and+centralized+administrative+operations" target="_blank" rel="external">KIP-4</a>完成时，这个列表将变长）：</p>
<ol>
<li>描述消费者组（DescribeGroups） – 用于检查一组群体的当前状态（如：查看消费者分区分配）。 </li>
<li>列出组（ListGroups） – 列出某一个broker当前管理的所有组</li>
</ol>
<h2 id="开场白">开场白</h2>
<h3 id="网络">网络</h3>
<p>Kafka使用基于TCP的二进制协议。该协议定义了所有API的请求及响应消息。所有消息都是通过长度来分隔，并且由后面描述的基本类型组成。</p>
<p>客户端初始化一个socket连接，并且写入请求的消息序列和读回相应的响应消息。连接和断开时均不需要握手消息。如果保持长连接，那么TCP协议本身将会节省很多TCP握手时间，但如果真的重新建立连接，那么代价也相当小。</p>
<p>客户可能需要维持到多个broker的连接，因为数据是被分区的，而客户端需要和存储这些分区的broker服务器进行通讯。当然，一般而言，不需要为单个服务端和单个客户端间维护多个连接（即连接池技术）。</p>
<p>服务器保证单一的TCP连接中，请求将被顺序处理，响应也将按该顺序返回。为保证broker的处理请求的顺序，单个连接同时也只会处理一个请求指令。请注意，客户端可以（也应该）使用非阻塞IO实现请求流水线，从而实现更高的吞吐量。也就是说，客户可以在等待上次请求应答的同时发送下个请求，因为待完成的请求将会在底层操作系统套接字缓冲区进行缓冲。除非特别说明，所有的请求是由客户端启动，并从服务器获取到相应的响应消息。</p>
<p>服务器能够配置请求大小的最大限制，超过这个限制将导致socket连接被断开。</p>
<h3 id="分区和引导（Partitioning_and_bootstrapping）">分区和引导（Partitioning and bootstrapping）</h3>
<p>Kafka是一个分区系统，所以不是所有的服务器都有完整的数据集。Topic被分为P（预先定义的分区数量）个分区，每个分区被复制N（复制因子）份，Topic Partition根据顺序在“提交日志”中编号为0，1，…，P。</p>
<p>所有具有这种特性的系统都有一个如何制定某个特定数据应该被分配给哪个特定的分区的问题。Kafka中它由客户端直接控制分配策略，broker则没有特别的语义来决定消息发布到哪个分区。相反，生产者直接将消息发送到一个特定的分区，获取消息时，消费者也直接从某个特定的分区获取。如果两个生产者要使用相同的分区方案，那么他们必须用同样的方法来计算Key到分区映射关系。</p>
<p>这些发布或获取数据的请求必须发送到指定分区的 leader broker中。此条件同时也会由broker检查，发送到不正确的broker的请求将会返回NotLeaderForPartition 错误代码（后文所描述的）。</p>
<p>那么客户端如何找出存在的topic呢，这些topic有哪些分区，以及这些分区被哪些broker保存，以便它可以直接将请求发送到正确的主机上？这个信息是动态的，因此你不能只是为每个客户端配置一些静态映射。相反所有的Kafka broker都可以回答描述集群当前状态的数据请求：有哪些topic，这些topic都有多少分区，哪个broker是这些分区的Leader，以及这些broker主机的地址和端口信息。</p>
<p>换句话说，客户端只需要找到一个broker，broker将会告知客户端所有其他存在的broker，以及这些broker上面的所有分区。这个broker本身也可能会掉线，因此客户端实现的最佳做法是保存两三个broker地址。用户可以选择使用负载均衡器或只是静态地配置两个或三个客户的Kafka主机。</p>
<p>客户并不需要轮询地查看集群是否已经改变；它可以获取元数据一次然后缓存起来，等到它接收到所用的元数据过期的错误信息时再更新元数据。这种错误有两种形式：（1）套接字错误指示客户端不能与特定的broker进行通信，<br>（2）请求响应表明该broker不再是其请求数据分区的Leader的错误。</p>
<p>轮询“初始”Kafka的URL列表，直到我们找到一个我们可以连接到的broker，获取集群元数据。<br>处理获取数据或者生产消息请求，根据这些请求所发送的topic和分区，将这些请求发送到合适的broker。<br>如果我们得到一个合适的错误(显示元数据已经过期时)，刷新元数据，然后再试一次。</p>
<h3 id="分区策略（Partitioning_Strategies">分区策略（Partitioning Strategies</h3>
<p>上面提到消息的分区分配是由生产者客户端控制，那么，这个功能是如何暴露给最终用户的？</p>
<p>在Kafka中，分区有两个目的：</p>
<ol>
<li>它平衡了broker的数据和请求的负载</li>
<li>它允许多个消费者之间处理分发消息的同时，能够维护本地状态，并且在分区中维持消息的顺序。我们称之为语义的分区（semantic partitioning）。</li>
</ol>
<p>对于给定的使用场景下，你可能只关心其中的一个或两个。</p>
<p>为了实现简单的负载均衡，一个简单的策略是客户端发布消息是对所有broker进行轮询请求(round robin requests)。另一种选择，在那些生产者比消费者多的场景下，给每个客户机随机选择一个分区并发布消息到该分区。后一种的策略能够使用少得多的TCP连接。</p>
<p>语义分区是指使用消息中的 key 来决定分配的分区。例如，如果你正在处理一个点击消息流时，你可能想通过用户ID来划分流，使得特定用户的所有数据会被单个消费者消费。要做到这一点，客户端可以采取与消息相关联的key，并使用key的某种Hash值来选择要发送的分区。</p>
<h3 id="批处理（Batching）">批处理（Batching）</h3>
<p>我们的API鼓励将小的请求批量处理以提高效率。我们发现这能非常显著地提升性能。我们两个用来发送消息和获取消息的API，总是鼓励处理一连串的消息，而不是单一的消息。聪明的客户端可以利用这一点，并支持“异步”操作模式，以此进行批处理哪些单独发送的消息，并把它们以较大的块进行发送。我们可以进一步允许跨多个主题和分区的批处理，所以生产请求可能包含追加到许多分区的数据，一个读取请求可以一次性从多个分区提取数据的。</p>
<p>当然，如果他们喜欢，客户端实现者可以选择忽略这一点，所有消息一次都发送一个。</p>
<h3 id="版本和兼容性（Versioning_and_Compatibility）">版本和兼容性（Versioning and Compatibility）</h3>
<p>该协议的目的要达到在向后兼容的基础上渐进演化。我们的版本是基于每个API基础之上，每个版本包括一个请求和响应对。每个请求包含API Key，里面包含了被调用的API标识，以及表示这些请求和响应格式的版本号。</p>
<p>这样做的目的是允许客户端实现相应特定版本的请求，在请求中标志版本信息。目标主要是为了在不允许停机的环境下进行更新，这种环境下，客户端和服务器不能一次性都切换所使用的API。</p>
<p>服务器会拒绝它不支持的版本的请求，并始终返回它期望收到的能够完成请求响应的版本的协议格式。建议的升级路径方式是，新功能将首先部署到服务器（老客户端无法完全利用他们的新功能），然后随着新的客户端的部署，这些新功能将逐步被利用。</p>
<p>目前，所有版本从0开始，当我们介绍这些API时，我们将分别显示每个版本的格式。</p>
<h2 id="通讯协议（The_Protocol）">通讯协议（The Protocol）</h2>
<h3 id="基本数据类型（Protocol_Primitive_Types）">基本数据类型（Protocol Primitive Types）</h3>
<p>该协议是建立在下列基本类型之上。</p>
<ul>
<li><p><strong>定长基本类型</strong>（Fixed Width Primitives）<br>int8, int16, int32, int64 – 不同精度(以bit数区分)的带符号整数，以大端（Big Endiam）方式存储.</p>
</li>
<li><p><strong>变长基本类型</strong>（Variable Length Primitives）<br>bytes, string – 这些类型由一个表示长度的带符号整数N以及后续N字节的内容组成。长度如果为-1表示空（null）. string 使用int16表示长度，bytes使用int32.</p>
</li>
<li><p><strong>数组</strong>（Arrays）<br>这个类型用来处理重复的结构体数据。他们总是由一个代表元素个数int32整数N，以及后续的N个重复结构体组成，这些结构体自身是有其他的基本数据类型组成。我们后面会用BNF语法展示一个foo的结构体数组[foo]</p>
</li>
</ul>
<h3 id="请求格式语法要点">请求格式语法要点</h3>
<p>后面的<a href="http://en.wikipedia.org/wiki/Backus–Naur_Form" target="_blank" rel="external">BNF</a>明确地以上下文无关的语法展示了请求和响应的二进制格式。每个API都会一起给出请求和响应定义，以及所有的子定义（sub-definitions）。BNF使用没有经过缩写的便于阅读的名称（比如我使用一个符号化了的名称来定义了一个production 错误码，即便它只是int16整数）。一般在BNF中，一个production序列表示一个连接，所以下面给出的MetadataRequest将是一个含有VersionId，然后clientId，然后TopicNames的数组（每一个都有其自身的定义）。自定义类型一般使用驼峰法拼写，基本类型使用全小写方式拼写。当存在多中可能的自定义类型时，使用’|’符号分割，并且用括号表示分组。顶级定义不缩进，后续的子部分会被缩进。</p>
<h3 id="通用的请求和响应格式">通用的请求和响应格式</h3>
<p>所有请求和响应都从以下语法为基础，其余的会在本文剩下部分中进行增量描述：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="constant">RequestOrResponse</span> =&gt; Size (RequestMessage | ResponseMessage)</div><div class="line"><span class="constant">  Size</span> =&gt; <span class="built_in">int32</span></div></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>域（FIELD）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>MessageSize</td>
<td>MessageSize 域给出了后续请求或响应消息的字节(bytes)长度。客户端可以先读取4字节的长度N，然后读取并解析后续的N字节请求内容。</td>
</tr>
</tbody>
</table>
<h4 id="请求（Requests）">请求（Requests）</h4>
<p>所有请求都具有以下格式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="constant">RequestMessage</span> =&gt; ApiKey ApiVersion CorrelationId ClientId RequestMessage</div><div class="line"><span class="constant">  ApiKey</span> =&gt; int16</div><div class="line"><span class="constant">  ApiVersion</span> =&gt; int16</div><div class="line"><span class="constant">  CorrelationId</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  ClientId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  RequestMessage</span> =&gt; MetadataRequest | ProduceRequest | FetchRequest | OffsetRequest | OffsetCommitRequest | OffsetFetchRequest</div></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>域（FIELD）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ApiKey</td>
<td>这是一个表示所调用的API的数字id（即它表示是一个元数据请求？生产请求？获取请求等）.</td>
</tr>
<tr>
<td>ApiVersion</td>
<td>这是该API的一个数字版本号。我们为每个API定义一个版本号，该版本号允许服务器根据版本号正确地解释请求内容。响应消息也始终对应于所述请求的版本的格式。</td>
</tr>
<tr>
<td>CorrelationId</td>
<td>这是一个用户提供的整数。它将会被服务器原封不动地回传给客户端。用于匹配客户机和服务器之间的请求和响应。</td>
</tr>
<tr>
<td>ClientId</td>
<td>这是为客户端应用程序的自定义的标识。用户可以使用他们喜欢的任何标识符，他们会被用在记录错误时，监测统计信息等场景。例如，你可能不仅想要监视每秒的总体请求，还要根据客户端应用程序进行监视，那它就可以被用上（其中每一个都将驻留在多个服务器上）。这个ID作为特定的客户端对所有的请求的逻辑分组。</td>
</tr>
</tbody>
</table>
<p>下面我们就来描述各种请求和响应消息。</p>
<h4 id="响应（Responses）">响应（Responses）</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="constant">Response</span> =&gt; CorrelationId ResponseMessage</div><div class="line"><span class="constant">CorrelationId</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">ResponseMessage</span> =&gt; MetadataResponse | ProduceResponse | FetchResponse | OffsetResponse | OffsetCommitResponse | OffsetFetchResponse</div></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>域（FIELD）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CorrelationId</td>
<td>服务器传回给客户端它所提供用作关联请求和响应消息的整数。</td>
</tr>
</tbody>
</table>
<p>所有响应都是与请求成对匹配（例如，我们将发送回一个元数据请求，会得到一个元数据响应）。</p>
<h4 id="消息集（Message_sets）">消息集（Message sets）</h4>
<p>生产和获取消息指令请求共享同一个消息集结构。在Kafka中，消息是由一个键值对以及少量相关的元数据组成。消息只是一个有偏移量和大小信息的消息序列。这种格式正好即用于在broker上的磁盘上存储，也用在线上数据交换。</p>
<p>消息集也是Kafka中的压缩单元，我们也允许消息递归包含压缩消息从而允许批量压缩。</p>
<p>注意, 在通讯协议中，消息集之前没有类似的其他数组元素的int32。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="constant">MessageSet</span> =&gt; [Offset MessageSize Message]</div><div class="line"><span class="constant">  Offset</span> =&gt; <span class="built_in">int64</span></div><div class="line"><span class="constant">  MessageSize</span> =&gt; <span class="built_in">int32</span></div></pre></td></tr></table></figure>

<p>消息格式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">v0</div><div class="line"><span class="constant">Message</span> =&gt; Crc MagicByte Attributes Key Value</div><div class="line"><span class="constant">  Crc</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  MagicByte</span> =&gt; int8</div><div class="line"><span class="constant">  Attributes</span> =&gt; int8</div><div class="line"><span class="constant">  Key</span> =&gt; <span class="built_in">bytes</span></div><div class="line"><span class="constant">  Value</span> =&gt; <span class="built_in">bytes</span></div><div class="line"> </div><div class="line">v1 (supported since <span class="number">0.10</span>.<span class="number">0</span>)</div><div class="line"><span class="constant">Message</span> =&gt; Crc MagicByte Attributes Key Value</div><div class="line"><span class="constant">  Crc</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  MagicByte</span> =&gt; int8</div><div class="line"><span class="constant">  Attributes</span> =&gt; int8</div><div class="line"><span class="constant">  Timestamp</span> =&gt; <span class="built_in">int64</span></div><div class="line"><span class="constant">  Key</span> =&gt; <span class="built_in">bytes</span></div><div class="line"><span class="constant">  Value</span> =&gt; <span class="built_in">bytes</span></div></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>域（FIELD）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Offset</td>
<td>这是在Kafka中作为日志序列号使用的偏移量。当生产者发送非压缩消息，这时候它可以填写任意值。当生产者发送压缩消息，为了避免服务端重新压缩，每个压缩消息的内部消息的偏移量应该从0开始，然后依次增加（kafka压缩消息详见后面的描述）。</td>
</tr>
<tr>
<td>Crc</td>
<td>Crc是的剩余消息字节的CRC32值。broker和消费者可用来检查信息的完整性。</td>
</tr>
<tr>
<td>MagicByte</td>
<td>这是一个用于允许消息二进制格式的向后兼容演化的版本id。当前值是0。</td>
</tr>
<tr>
<td>Attributes</td>
<td>这个字节保存有关信息的元数据属性。最低的3位包含用于消息的压缩编解码器。第四位表示时间戳类型，0代表CreateTime，1代表LogAppendTime。生产者必须把这个位设成0。所有其他位必须被设置为0。</td>
</tr>
<tr>
<td>Timestamp</td>
<td>消息的时间戳。时间戳类型在Attributes域中体现。单位为从UTC标准准时间1970年1月1日0点到所在时间的毫秒数。</td>
</tr>
<tr>
<td>Key</td>
<td>Key是一个可选项，它主要用来进行指派分区。Key可以为null。</td>
</tr>
<tr>
<td>Value</td>
<td>Value是消息的实际内容，类型是字节数组。Kafka支持本身递归包含，因此本身也可能是一个消息集。消息可以为null。</td>
</tr>
</tbody>
</table>
<h4 id="压缩（Compression）">压缩（Compression）</h4>
<p>Kafka支持压缩多条消息以提高效率，当然，这比压缩一条原始消息要来得复杂。因为单个消息可能没有足够的冗余信息以达到良好的压缩比，压缩的多条信息必须以特殊方式批量发送（当然，如果真的需要的话，你可以自己压缩批处理的一个消息）。要被发送的消息被包装（未压缩）在一个MessageSet结构中，然后将其压缩并存储在一个单一的“消息”中，一起保存的还有相应的压缩编解码集。接收系统通过解压缩得到实际的消息集。外层MessageSet应该只包含一个压缩的“消息”（详情见<a href="https://issues.apache.org/jira/browse/KAFKA-1718" target="_blank" rel="external">Kafka-1718</a>）。</p>
<p>Kafka目前支持一下两种压缩算法：</p>
<table>
<thead>
<tr>
<th>压缩算法（COMPRESSION）</th>
<th>编码器编号（CODEC）</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>0</td>
</tr>
<tr>
<td>GZIP</td>
<td>1</td>
</tr>
<tr>
<td>Snappy</td>
<td>2</td>
</tr>
</tbody>
</table>
<h3 id="接口_(API)">接口 (API)</h3>
<p>本节将给出每个API的用法、二进制格式，以及它们的字段的含义的细节。</p>
<h4 id="元数据接口（Metadata_API）">元数据接口（Metadata API）</h4>
<p>这个API回答下列问题：</p>
<ul>
<li>存在哪些Topic？</li>
<li>每个主题有几个分区（Partition）？</li>
<li>每个分区的Leader分别是哪个broker？</li>
<li>这些broker的地址和端口分别是什么？</li>
</ul>
<p>这是唯一一个能发往集群中任意一个broker的请求消息。</p>
<p>因为可能有很多topic，客户端可以给一个的可选topic列表，以便只返回一组topic元数据。</p>
<p>返回的元数据信息是分区级别的信息，为了方便和以避免冗余，以topic为组集中在一起。每个分区的元数据中包含了leader以及所有副本以及正在同步的副本的信息。</p>
<p><strong>注意</strong>: 如果broker配置中设置了”auto.create.topics.enable”, topic元数据请求将会以默认的复制因子和默认的分区数为参数创建topic。</p>
<h5 id="topic元数据请求（Topic_Metadata_Request）">topic元数据请求（Topic Metadata Request）</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="constant">TopicMetadataRequest</span> =&gt; [TopicName]</div><div class="line"><span class="constant">  TopicName</span> =&gt; <span class="built_in">string</span></div></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>域（FIELD</th>
<th>）    描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>TopicName</td>
<td>要获取元数据的主题数组。 如果为空，就返回所有主题的元数据</td>
</tr>
</tbody>
</table>
<h5 id="元数据响应（Metadata_Response）">元数据响应（Metadata Response）</h5>
<p>响应包含的每个分区的元数据，这些分区元数据以topic为组组装在一起。该元数据以broker id来指向具体的broker。每个broker有一个地址和端口。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="constant">MetadataResponse</span> =&gt; [Broker][TopicMetadata]</div><div class="line"><span class="constant">  Broker</span> =&gt; NodeId Host Port  (any number of brokers may be returned)</div><div class="line"><span class="constant">    NodeId</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">    Host</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">    Port</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  TopicMetadata</span> =&gt; TopicErrorCode TopicName [PartitionMetadata]</div><div class="line"><span class="constant">    TopicErrorCode</span> =&gt; int16</div><div class="line"><span class="constant">  PartitionMetadata</span> =&gt; PartitionErrorCode PartitionId Leader Replicas Isr</div><div class="line"><span class="constant">    PartitionErrorCode</span> =&gt; int16</div><div class="line"><span class="constant">    PartitionId</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">    Leader</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">    Replicas</span> =&gt; [<span class="built_in">int32</span>]</div><div class="line"><span class="constant">    Isr</span> =&gt; [<span class="built_in">int32</span>]</div></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>域（FIELD）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Leader</td>
<td>该分区作为Leader节点的Kafka broker id。如果在一个Leader选举过程中，没有Leader存在，这个id将是-1。</td>
</tr>
<tr>
<td>Replicas</td>
<td>该分区中，其他活着的作为slave的节点集合。</td>
</tr>
<tr>
<td>Isr</td>
<td>副本集合中，所有处在与Leader跟随（“caught up”，表示数据已经完全复制到这些节点）状态的子集</td>
</tr>
<tr>
<td>Broker</td>
<td>kafka broker节点的id, 主机名, 端口信息</td>
</tr>
</tbody>
</table>
<p><strong>可能的错误码（Possible Error Codes）</strong></p>
<ul>
<li>UnknownTopic (3)</li>
<li>LeaderNotAvailable (5)</li>
<li>InvalidTopic (17)</li>
<li>TopicAuthorizationFailed (29)</li>
</ul>
<h4 id="生产接口（Produce_API）">生产接口（Produce API）</h4>
<p>生产者API用于将消息集发送到服务器。为了提高效率，它允许在单个请求中发送多个不同topic的不同分区的消息。</p>
<p>生产者API使用通用的消息集格式，但由于发送时还没有被分配偏移量，因此可以任意填写该值。</p>
<h5 id="Produce_Request">Produce Request</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">v0, v1 (supported <span class="keyword">in</span> <span class="number">0.9</span>.<span class="number">0</span> <span class="constant">or</span> later) <span class="constant">and</span> v2 (supported <span class="keyword">in</span> <span class="number">0.10</span>.<span class="number">0</span> <span class="constant">or</span> later)</div><div class="line"><span class="variable">ProduceRequest =</span>&gt; RequiredAcks Timeout [TopicName [Partition MessageSetSize MessageSet]]</div><div class="line">  <span class="variable">RequiredAcks =</span>&gt; int16</div><div class="line">  <span class="variable">Timeout =</span>&gt; int32</div><div class="line">  <span class="variable">Partition =</span>&gt; int32</div><div class="line">  <span class="variable">MessageSetSize =</span>&gt; int32</div></pre></td></tr></table></figure>

<p>v1及以后版本表示客户端可以在response中解析quota throttle time。</p>
<p>v2及以后版本表示客户端可以解析response中的时间戳域。</p>
<table>
<thead>
<tr>
<th>域（FIELD）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>RequiredAcks</td>
<td>这个值表示服务端收到多少确认后才发送反馈消息给客户端。如果设置为0，那么服务端将不发送response（这是唯一的服务端不发送response的情况）。如果这个值为1，那么服务器将等到数据写入到本地日之后发送response。如果这个值是-1，那么服务端将阻塞，知道这个消息被所有的同步副本写入后再发送response。</td>
</tr>
<tr>
<td>Timeout</td>
<td>这个值提供了以毫秒为单位的超时时间，服务器可以在这个时间内可以等待接收所需的Ack确认的数目。超时并非一个确切的限制，有以下原因：（1）不包括网络延迟，（2）计时器开始在这一请求的处理开始，所以如果有很多请求，由于服务器负载而导致的排队等待时间将不被包括在内，（3）如果本地写入时间超过超时，我们将不会终止本地写操作，这样这个超时时间就不会得到遵守。要使硬超时时间，客户端应该使用套接字超时。</td>
</tr>
<tr>
<td>TopicName</td>
<td>该数据将会发布到的topic名称</td>
</tr>
<tr>
<td>Partition</td>
<td>该数据将会发布到的分区</td>
</tr>
<tr>
<td>MessageSetSize</td>
<td>后续消息集的长度，字节为单位</td>
</tr>
<tr>
<td>MessageSet</td>
<td>上面描述的标准格式的消息集合</td>
</tr>
</tbody>
</table>
<h5 id="Produce_Response">Produce Response</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">v0</div><div class="line"><span class="constant">ProduceResponse</span> =&gt; [TopicName [Partition ErrorCode Offset]]</div><div class="line"><span class="constant">  TopicName</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  Partition</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  ErrorCode</span> =&gt; int16</div><div class="line"><span class="constant">  Offset</span> =&gt; <span class="built_in">int64</span></div><div class="line"> </div><div class="line">v1 (supported in <span class="number">0.9</span>.<span class="number">0</span> or later)</div><div class="line"><span class="constant">ProduceResponse</span> =&gt; [TopicName [Partition ErrorCode Offset]] ThrottleTime</div><div class="line"><span class="constant">  TopicName</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  Partition</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  ErrorCode</span> =&gt; int16</div><div class="line"><span class="constant">  Offset</span> =&gt; <span class="built_in">int64</span></div><div class="line"><span class="constant">  ThrottleTime</span> =&gt; <span class="built_in">int32</span></div><div class="line"> </div><div class="line">v2 (supported in <span class="number">0.10</span>.<span class="number">0</span> or later)</div><div class="line"><span class="constant">ProduceResponse</span> =&gt; [TopicName [Partition ErrorCode Offset Timestamp]] ThrottleTime</div><div class="line"><span class="constant">  TopicName</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  Partition</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  ErrorCode</span> =&gt; int16</div><div class="line"><span class="constant">  Offset</span> =&gt; <span class="built_in">int64</span></div><div class="line"><span class="constant">  Timestamp</span> =&gt; <span class="built_in">int64</span></div><div class="line"><span class="constant">  ThrottleTime</span> =&gt; <span class="built_in">int32</span></div></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>域</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Topic</td>
<td>此响应对应的主题。</td>
</tr>
<tr>
<td>Partition</td>
<td>此响应对应的分区。</td>
</tr>
<tr>
<td>ErrorCode</td>
<td>如果有，此分区对应的错误信息。错误以分区为单位提供，因为可能存在给定的分区不可用或者被其他的主机维护（非Leader），但是其他的分区的请求操作成功的情况</td>
</tr>
<tr>
<td>Offset</td>
<td>追加到该分区的消息集中的分配给第一个消息的偏移量。</td>
</tr>
<tr>
<td>Timestamp</td>
<td>如果该主题使用了LogAppendTime，这个时间戳就是broker分配给这个消息集。这个消息集中的所有消息都有相同的时间戳。如果使用的是CreateTime，这个域始终是-1。如果没有返回错误码，生产者可以假定消息的时间戳已经被broker接受。单位为从UTC标准准时间1970年1月1日0点到所在时间的毫秒数。</td>
</tr>
<tr>
<td>ThrottleTime</td>
<td>由于限额冲突而导致的时间延迟长度，以毫秒为单位。（如果没有违反限额条件，此值为0）</td>
</tr>
</tbody>
</table>
<p><strong>可能的错误码</strong>（Possible Error Codes）:( TODO)</p>
<h4 id="获取消息接口（Fetch_API）">获取消息接口（Fetch API）</h4>
<p>获取消息接口用于获取一些topic分区的一个或多个的日志块。逻辑上根据指定topic，分区和消息起始偏移量开始获取一批消息。在一般情况下，返回消息的偏移量将大于或等于开始偏移量。然而，如果是压缩消息，有可能返回的消息的偏移量比起始偏移量小。这类的消息的数量通常较少，并且调用者必须负责过滤掉这些消息。</p>
<p>获取数据指令请求遵循一个长轮询模型，如果没有足够数量的消息可用，它们可以阻塞一段时间。</p>
<p>作为优化，服务器被允许在消息集的末尾返回一个消息的一部分。客户端应处理这种情况。</p>
<p>有一点要注意的是，获取消息API需要指定消费的分区。现在的问题是如何让消费者知道消费哪个分区？特别地，作为一组消费者，如何使得每个消费者获取分区的一个子集，并且平衡这些分区。我们使用zookeeper动态地为Scala和Java客户端完成这个任务。这种方法的缺点是，它需要一个相当胖的客户端并且需要客户端与zookeeper连接。我们尚未创建一个Kafka接口（API），允许该功能被移动到在服务器端并被更方便地访问。一个简单的消费者的客户端可以通过配置指定访问的分区，但这样将不能在某些消费者失效后做到分区的动态重新分配。我们希望能在下一个主要版本解决这一空白。</p>
<h5 id="Fetch_Request">Fetch Request</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="constant">FetchRequest</span> =&gt; ReplicaId MaxWaitTime MinBytes [TopicName [Partition FetchOffset MaxBytes]]</div><div class="line"><span class="constant">  ReplicaId</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  MaxWaitTime</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  MinBytes</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  TopicName</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  Partition</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  FetchOffset</span> =&gt; <span class="built_in">int64</span></div><div class="line"><span class="constant">  MaxBytes</span> =&gt; <span class="built_in">int32</span></div></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>域</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ReplicaId</td>
<td>副本ID的是发起这个请求的副本节点ID。普通消费者客户端应该始终将其指定为-1，因为他们没有节点ID。其他broker设置他们自己的节点ID。基于调试目的，以非代理身份模拟副本broker发出获取数据指令请求时，这个值填-2。</td>
</tr>
<tr>
<td>MaxWaitTime</td>
<td>如果没有足够的数据可发送时，最大阻塞等待时间，以毫秒为单位。</td>
</tr>
<tr>
<td>MinBytes</td>
<td>返回响应消息的最小字节数目，必须设置。如果客户端将此值设为0，服务器将会立即返回，但如果没有新的数据，服务端会返回一个空消息集。如果它被设置为1，则服务器将在至少一个分区收到一个字节的数据的情况下立即返回，或者等到超时时间达到。通过设置较高的值，结合超时设置，消费者可以在牺牲一点实时性能的情况下通过一次读取较大的字节的数据块从而提高的吞吐量（例如，设置MaxWaitTime至100毫秒，设置MinBytes为64K，将允许服务器累积数据达到64K前等待长达100ms再响应）。</td>
</tr>
<tr>
<td>TopicName</td>
<td>topic名称</td>
</tr>
<tr>
<td>Partition</td>
<td>获取数据的Partition id</td>
</tr>
<tr>
<td>FetchOffset</td>
<td>获取数据的起始偏移量</td>
</tr>
<tr>
<td>MaxBytes</td>
<td>此分区返回消息集所能包含的最大字节数。这有助于限制响应消息的大小。</td>
</tr>
</tbody>
</table>
<h5 id="Fetch_Response">Fetch Response</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">v0</div><div class="line"><span class="constant">FetchResponse</span> =&gt; [TopicName [Partition ErrorCode HighwaterMarkOffset MessageSetSize MessageSet]]</div><div class="line"><span class="constant">  TopicName</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  Partition</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  ErrorCode</span> =&gt; int16</div><div class="line"><span class="constant">  HighwaterMarkOffset</span> =&gt; <span class="built_in">int64</span></div><div class="line"><span class="constant">  MessageSetSize</span> =&gt; <span class="built_in">int32</span></div><div class="line"> </div><div class="line">v1 (supported in <span class="number">0.9</span>.<span class="number">0</span> or later) and v2 (supported in <span class="number">0.10</span>.<span class="number">0</span> or later)</div><div class="line"><span class="constant">FetchResponse</span> =&gt; ThrottleTime [TopicName [Partition ErrorCode HighwaterMarkOffset MessageSetSize MessageSet]]</div><div class="line"><span class="constant">  ThrottleTime</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  TopicName</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  Partition</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  ErrorCode</span> =&gt; int16</div><div class="line"><span class="constant">  HighwaterMarkOffset</span> =&gt; <span class="built_in">int64</span></div><div class="line"><span class="constant">  MessageSetSize</span> =&gt; <span class="built_in">int32</span></div></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>域</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ThrottleTime</td>
<td>由于限额冲突而导致的时间延迟长度，以毫秒为单位。（如果没有违反限额条件，此值为0）</td>
</tr>
<tr>
<td>TopicName</td>
<td>返回消息所对应的Topic名称。</td>
</tr>
<tr>
<td>Partition</td>
<td>返回消息所对应的分区id。</td>
</tr>
<tr>
<td>HighwaterMarkOffset</td>
<td>此分区日志中最末尾的偏移量。此信息可被客户端用来确定后面还有多少条消息。</td>
</tr>
<tr>
<td>MessageSetSize</td>
<td>此分区中消息集的字节长度</td>
</tr>
<tr>
<td>MessageSet</td>
<td>此分区获取到的消息集，格式与之前描述相同</td>
</tr>
</tbody>
</table>
<p>v1只会包含v0格式的消息.<br>v2可能即包含v0又包含v1版本格式的消息.</p>
<p><strong>可能的错误码</strong>（Possible Error Codes）</p>
<ul>
<li>OFFSET_OUT_OF_RANGE (1)</li>
<li>UNKNOWN_TOPIC_OR_PARTITION (3)</li>
<li>NOT_LEADER_FOR_PARTITION (6)</li>
<li>REPLICA_NOT_AVAILABLE (9)</li>
<li>UNKNOWN (-1)</li>
</ul>
<h4 id="偏移量接口（又称ListOffset）（Offset_API）">偏移量接口（又称ListOffset）（Offset API）</h4>
<p>此API描述了一组topic分区的偏移量有效范围。生产者和获取数据API的请求必须发送到分区Leader所在的broker上，这需要通过使用元数据的API来确定。</p>
<p>自版本0, response包含请求的分区的起始偏移量以及“log end offset”，即，将被追加到给定分区中的下一个消息的偏移量。kafka 0.10.1.0开始支持版本1, 它开始支持根据时间戳进行基于时间索引的查找，API做了一点改变来支持这个特性。注意这个API只支持开启 0.10消息格式的topic，否则返回UNSUPPORTED_FOR_MESSAGE_FORMAT错误。</p>
<h5 id="Offset_Request">Offset Request</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// v0</span></div><div class="line"><span class="constant">ListOffsetRequest</span> =&gt; ReplicaId [TopicName [Partition Time MaxNumberOfOffsets]]</div><div class="line"><span class="constant">  ReplicaId</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  TopicName</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  Partition</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  Time</span> =&gt; <span class="built_in">int64</span></div><div class="line"><span class="constant">  MaxNumberOfOffsets</span> =&gt; <span class="built_in">int32</span></div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">// v1 (supported in 0.10.1.0 and later)</span></div><div class="line"><span class="constant">ListOffsetRequest</span> =&gt; ReplicaId [TopicName [Partition Time]]</div><div class="line"><span class="constant">  ReplicaId</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  TopicName</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  Partition</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  Time</span> =&gt; <span class="built_in">int64</span></div></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>域</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Time</td>
<td>用来请求一定时间(毫秒)前的所有消息。这里有两个特殊取值：-1表示获取最后一个offset（也就是后面即将到来消息的offset值）； -2表示获取最早的有效偏移量。注意，因为获取到偏移值都是降序排序，因此请求最早Offset的请求将总是返回一个值</td>
</tr>
</tbody>
</table>
<h5 id="Offset_Response">Offset Response</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// v0</span></div><div class="line"><span class="constant">OffsetResponse</span> =&gt; [TopicName [PartitionOffsets]]</div><div class="line"><span class="constant">  PartitionOffsets</span> =&gt; Partition ErrorCode [Offset]</div><div class="line"><span class="constant">  Partition</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  ErrorCode</span> =&gt; int16</div><div class="line"><span class="constant">  Offset</span> =&gt; <span class="built_in">int64</span></div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">// v1</span></div><div class="line"><span class="constant">ListOffsetResponse</span> =&gt; [TopicName [PartitionOffsets]]</div><div class="line"><span class="constant">  PartitionOffsets</span> =&gt; Partition ErrorCode Timestamp [Offset]</div><div class="line"><span class="constant">  Partition</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  ErrorCode</span> =&gt; int16</div><div class="line"><span class="constant">  Timestamp</span> =&gt; <span class="built_in">int64</span></div><div class="line"><span class="constant">  Offset</span> =&gt; <span class="built_in">int64</span></div></pre></td></tr></table></figure>

<p>可能的错误码（Possible Error Codes）</p>
<ul>
<li>UNKNOWN_TOPIC_OR_PARTITION (3)</li>
<li>NOT_LEADER_FOR_PARTITION (6)</li>
<li>UNKNOWN (-1)</li>
<li>UNSUPPORTED_FOR_MESSAGE_FORMAT (43)</li>
</ul>
<h4 id="偏移量提交/获取接口（Offset_Commit/Fetch_API）">偏移量提交/获取接口（Offset Commit/Fetch API）</h4>
<p>这些API使得偏移量的能够集中管理。了解更多<a href="https://cwiki.apache.org/confluence/display/KAFKA/Offset+Management" target="_blank" rel="external">偏移量管理</a>。按照<a href="https://issues.apache.org/jira/browse/KAFKA-993" target="_blank" rel="external">Kafka-993</a>的评论，直到Kafka 0.8.1.1，这些API调用无法全部正常使用，他们这将在0.8.2版本中提供。</p>
<h5 id="消费者组协调员请求（Group_Coordinator_Request）">消费者组协调员请求（Group Coordinator Request）</h5>
<p>消费者组（Consumer Group）偏移量信息，由一个特定的broker维护，这个broker称为消费者组协调员。即消费者需要向从这个特定的broker提交和获取偏移量。可以通过发出一组协调员发现请求从而获得当前协调员信息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="constant">GroupCoordinatorRequest</span> =&gt; GroupId</div><div class="line"><span class="constant">  GroupId</span> =&gt; <span class="built_in">string</span></div></pre></td></tr></table></figure>

<h5 id="消费者组协调员响应（Group_Coordinator_Response）">消费者组协调员响应（Group Coordinator Response）</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="constant">GroupCoordinatorResponse</span> =&gt; ErrorCode CoordinatorId CoordinatorHost CoordinatorPort</div><div class="line"><span class="constant">  ErrorCode</span> =&gt; int16</div><div class="line"><span class="constant">  CoordinatorId</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  CoordinatorHost</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  CoordinatorPort</span> =&gt; <span class="built_in">int32</span></div></pre></td></tr></table></figure>

<p>可能的错误码（Possible Error Codes）</p>
<ul>
<li>GROUP_COORDINATOR_NOT_AVAILABLE (15)</li>
<li>GROUP_AUTHORIZATION_FAILED (30)</li>
</ul>
<h5 id="偏移量提交请求（Offset_Commit_Request）">偏移量提交请求（Offset Commit Request）</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">v0 (supported in <span class="number">0.8</span>.<span class="number">1</span> or later)</div><div class="line"><span class="constant">OffsetCommitRequest</span> =&gt; ConsumerGroupId [TopicName [Partition Offset Metadata]]</div><div class="line"><span class="constant">  ConsumerGroupId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  TopicName</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  Partition</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  Offset</span> =&gt; <span class="built_in">int64</span></div><div class="line"><span class="constant">  Metadata</span> =&gt; <span class="built_in">string</span></div><div class="line"> </div><div class="line"> </div><div class="line">v1 (supported in <span class="number">0.8</span>.<span class="number">2</span> or later)</div><div class="line"><span class="constant">OffsetCommitRequest</span> =&gt; ConsumerGroupId ConsumerGroupGenerationId ConsumerId [TopicName [Partition Offset TimeStamp Metadata]]</div><div class="line"><span class="constant">  ConsumerGroupId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  ConsumerGroupGenerationId</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  ConsumerId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  TopicName</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  Partition</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  Offset</span> =&gt; <span class="built_in">int64</span></div><div class="line"><span class="constant">  TimeStamp</span> =&gt; <span class="built_in">int64</span></div><div class="line"><span class="constant">  Metadata</span> =&gt; <span class="built_in">string</span></div><div class="line"> </div><div class="line">v2 (supported in <span class="number">0.9</span>.<span class="number">0</span> or later)</div><div class="line"><span class="constant">OffsetCommitRequest</span> =&gt; ConsumerGroup ConsumerGroupGenerationId ConsumerId RetentionTime [TopicName [Partition Offset Metadata]]</div><div class="line"><span class="constant">  ConsumerGroupId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  ConsumerGroupGenerationId</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  ConsumerId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  RetentionTime</span> =&gt; <span class="built_in">int64</span></div><div class="line"><span class="constant">  TopicName</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  Partition</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  Offset</span> =&gt; <span class="built_in">int64</span></div><div class="line"><span class="constant">  Metadata</span> =&gt; <span class="built_in">string</span></div></pre></td></tr></table></figure>

<p>在V0和v1版本中，每个分区的时间戳作为提交时间戳定义，偏移量协调员将保存消费者所提交的偏移量，直到当前时间超过提交时间戳+偏移量保留时间，此偏移量保留时间在broker配置中指定；如果时间戳域没有设值，那么broker会将此值设定为接收到提交偏移量请求的时间，用户可以通过设置这个提交时间戳达到延长偏移量保存时间的目的。</p>
<p>在v2版本中，我们移除了时间戳域，但是增加了一个全局保存时间域（详情参见<a href="https://issues.apache.org/jira/browse/KAFKA-1634" target="_blank" rel="external">KAFKA-1634</a>）；broker会设置提交时间戳为接收到请求的时间，但是提交的偏移量能被保存到提交请求中用户指定的保存时间，如果这个保存时间没有设值(-1)，那么broker会使用默认的保存时间。</p>
<p>注意，当这个API在“simple consumer”模式下使用，并非作为消费者组一员时，那么generationId必须被设置成-1，并且memberId必须为空（非null）。另外，如果有一个活动的消费者组有同样的groupId，那么提交Offset的请求将会被拒绝（一般会返回UNKNOWN_MEMBER_ID或者ILLEGAL_GENERATION错误）。</p>
<h5 id="Offset_Commit_Response">Offset Commit Response</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">v0, v1 and v2:</div><div class="line"><span class="constant">OffsetCommitResponse</span> =&gt; [TopicName [Partition ErrorCode]]]</div><div class="line"><span class="constant">  TopicName</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  Partition</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  ErrorCode</span> =&gt; int16</div></pre></td></tr></table></figure>

<p>可能的错误码（Possible Error Codes）</p>
<p>OFFSET_METADATA_TOO_LARGE (12)<br>GROUP_LOAD_IN_PROGRESS (14)<br>GROUP_COORDINATOR_NOT_AVAILABLE (15)<br>NOT_COORDINATOR_FOR_GROUP (16)<br>ILLEGAL_GENERATION (22)<br>UNKNOWN_MEMBER_ID (25)<br>REBALANCE_IN_PROGRESS (27)<br>INVALID_COMMIT_OFFSET_SIZE (28)<br>TOPIC_AUTHORIZATION_FAILED (29)<br>GROUP_AUTHORIZATION_FAILED (30)</p>
<h5 id="Offset_Fetch_Request">Offset Fetch Request</h5>
<p>根据<a href="https://issues.apache.org/jira/browse/KAFKA-1841" target="_blank" rel="external">KAFKA-1841</a>的注释，V0和V1是相同的，但V0（0.8.1或更高版本支持）从zookeeper读取的偏移量，而V1（0.8.2或更高版本支持）从Kafka读偏移量。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">v0 and v1 (supported in <span class="number">0.8</span>.<span class="number">2</span> or after):</div><div class="line"><span class="constant">OffsetFetchRequest</span> =&gt; ConsumerGroup [TopicName [Partition]]</div><div class="line"><span class="constant">  ConsumerGroup</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  TopicName</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  Partition</span> =&gt; <span class="built_in">int32</span></div></pre></td></tr></table></figure>

<h5 id="Offset_Fetch_Response">Offset Fetch Response</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">v0 and v1 (supported in <span class="number">0.8</span>.<span class="number">2</span> or after):</div><div class="line"><span class="constant">OffsetFetchResponse</span> =&gt; [TopicName [Partition Offset Metadata ErrorCode]]</div><div class="line"><span class="constant">  TopicName</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  Partition</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  Offset</span> =&gt; <span class="built_in">int64</span></div><div class="line"><span class="constant">  Metadata</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  ErrorCode</span> =&gt; int16</div></pre></td></tr></table></figure>

<p>请注意，消费者组中一个topic的分区如果没有偏移量，broker不会设定一个错误码（因为它不是一个真正的错误），但会返回空的元数据并将偏移字段为-1。</p>
<p>偏移量获取请求v0和v1版本之间没有格式上的区别。功能实现上来说，v0版本从zookeeper获取偏移量，v1版本从Kafka中获取偏移量。</p>
<p>可能的错误码（Possible Error Codes）</p>
<ul>
<li>UNKNOWN_TOPIC_OR_PARTITION (3) &lt;- 只在v0版本的请求中出现</li>
<li>GROUP_LOAD_IN_PROGRESS (14)</li>
<li>NOT_COORDINATOR_FOR_GROUP (16)</li>
<li>ILLEGAL_GENERATION (22)</li>
<li>UNKNOWN_MEMBER_ID (25)</li>
<li>TOPIC_AUTHORIZATION_FAILED (29)</li>
<li>GROUP_AUTHORIZATION_FAILED (30)</li>
</ul>
<h4 id="组成员管理接口（Group_Membership_API）">组成员管理接口（Group Membership API）</h4>
<p>这些请求用于客户端参加Kafka所管理的消费者组。从更高层次上看，集群中每个消费者组都会分配一个broker（即消费者组协调员），以简化消费者组管理。一旦得到了组协调员地址（使用上面的消费者组协调员请求），组成员可以加入该组，同步状态，然后用心跳消息保持在组中的活跃状态。当客户端关闭时，它会使用离开组请求从消费者组中注销。此协议的语义在Kafka客户端分配协议中有详细描述。</p>
<p>组建管理接口的主要使用场景是消费者组，但这些请求也尽量设计得一般化以便支持其他应用场景（例如，Kafka Connect组）。这种设计的带来的代价就是是一些特定的组语义(group semantics)被推到了客户端实现。例如，下面定义的JoinGroup和SyncGroup请求无明确定义的字段以支持消费者组分区分配。相反，它们在其中包含有一些通用的字节数组（byte arrays），用这些字节数组就可以使得分区分配切入在消费者客户端实现。</p>
<p>但是，尽管这种实现允许每个客户端来实现来定义它们自己的嵌入schema，但是Kafka工具的兼容性要求这些客户端使用Kafka客户端使用的标准方案。例如，consumer-groups.sh这个应用程序会假定用这种格式来显示分区分配。因此，我们建议客户遵循相同的模式，使这些工具对所有客户端实现都可以正常工作。</p>
<h5 id="Join_Group_Request">Join Group Request</h5>
<p>加入组请求用于让客户端成为组的成员。当新成员加入一个现有组，之前加入的所有的会员必须通过发送一个新加入组的要求来重新入组。当成员第一次加入该组，成员编号将是空的（即“”），但重新加入的成员都应该使用与之前生成的相同的会员ID。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">v0 supported in <span class="number">0.9</span>.<span class="number">0.0</span> and greater</div><div class="line"><span class="constant">JoinGroupRequest</span> =&gt; GroupId SessionTimeout MemberId ProtocolType GroupProtocols</div><div class="line"><span class="constant">  GroupId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  SessionTimeout</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  MemberId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  ProtocolType</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  GroupProtocols</span> =&gt; [ProtocolName ProtocolMetadata]</div><div class="line"><span class="constant">    ProtocolName</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">    ProtocolMetadata</span> =&gt; <span class="built_in">bytes</span></div><div class="line"> </div><div class="line">v1 supported in <span class="number">0.10</span>.<span class="number">1.0</span> and greater</div><div class="line"><span class="constant">JoinGroupRequest</span> =&gt; GroupId SessionTimeout MemberId ProtocolType GroupProtocols</div><div class="line"><span class="constant">  GroupId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  SessionTimeout</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  RebalanceTimeout</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  MemberId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  ProtocolType</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  GroupProtocols</span> =&gt; [ProtocolName ProtocolMetadata]</div><div class="line"><span class="constant">    ProtocolName</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">    ProtocolMetadata</span> =&gt; <span class="built_in">bytes</span></div></pre></td></tr></table></figure>

<p>SessionTimeout字段指示客户端的存活。如果组协调员在session过期前没有收到一个心跳， 那么组员会被移除组。0.10.1前的版本， session timeout也被用作完成所需的 rebalance。一旦组管理员开始rebalance， 每一个组员会触发session timeout以便发送新的JoinGroup请求。 如果它们失败了，它们会从组中移除。 在0.10.1中，新版JoinGroup会使用一个独立的RebalanceTimeout来创建，一旦rebanlance开始，每个客户端触发过期以便重新加入，但是如果session timeout小于rebalance timeout, 客户端还是会持续发送heatbeat。</p>
<p>ProtocolType字段定义了该组实现的嵌入协议。组协调器确保该组中的所有成员都支持相同的协议类型。组中包含的协议（GroupProtocols）字段中的协议名称和元数据的含义取决于协议类型。请注意，加入群请求允许多协议/元数据对。这使得滚动升级时无需停机。协调器会选择所有成员支持的一种协议，升级后的成员既包括新版本和老版本的协议，一旦所有成员都升级，协调器将选择列在数组中最前面的组协议（GroupProtocol）。 </p>
<p><strong>消费者组</strong>: 下文我们定义了消费者组使用的嵌入协议。我们建议所有消费者客户端实现遵循这个格式，以便Kafka工具能够对所有的客户端正常工作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="constant">ProtocolType</span> =&gt; <span class="string">"consumer"</span></div><div class="line"><span class="constant"> </span></div><div class="line">ProtocolName =&gt; AssignmentStrategy</div><div class="line"><span class="constant">  AssignmentStrategy</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant"> </span></div><div class="line">ProtocolMetadata =&gt; Version Subscription UserData</div><div class="line"><span class="constant">  Version</span> =&gt; int16</div><div class="line"><span class="constant">  Subscription</span> =&gt; [Topic]</div><div class="line"><span class="constant">    Topic</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  UserData</span> =&gt; <span class="built_in">bytes</span></div></pre></td></tr></table></figure>

<p>UserData域的可以用来自定义分配策略。例如，在一个粘性分区策略实现中，这个字段可以包含之前的分配。在基于资源的分配策略，也可以包括每个运行消费者主机上的CPU个数等信息。</p>
<p>Kafka Connect使用“connect”的协议类型，和协议细节也是基于Connect的内部实现。</p>
<h5 id="Join_Group_Response">Join Group Response</h5>
<p>接收到来自该组中的所有成员组的加入组请求后，协调器将选择一个成员作为Leader，并且选择所有成员支持的协议。Leader将收到会员的完整列表与选择的协议相关的元数据。其他追随者成员，会收到一个空会员数组。Leader需要检查每个成员的元数据，并且使用下文中描述的SyncGroup请求来分配状态。</p>
<p>一旦加入组阶段完成，协调器会增加该组的GenerationId，这个Id是发送给每个成员的response中的一个字段，同时也会在心跳和偏移量提交请求中。当协调器重新rebalance了一个组，协调器将发送一个错误码，表示客户端成员需要重新加入组。如果重新平衡完成前成员未重入组（rejoin），那么它将有一个旧generationId，在新的请求使用这个旧Id时，这将导致ILLEGAL_GENERATION错误。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">v0 and v1 supported in <span class="number">0.9</span>.<span class="number">0</span> and greater</div><div class="line"><span class="constant">JoinGroupResponse</span> =&gt; ErrorCode GenerationId GroupProtocol LeaderId MemberId Members</div><div class="line"><span class="constant">  ErrorCode</span> =&gt; int16</div><div class="line"><span class="constant">  GenerationId</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  GroupProtocol</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  LeaderId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  MemberId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  Members</span> =&gt; [MemberId MemberMetadata]</div><div class="line"><span class="constant">    MemberId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">    MemberMetadata</span> =&gt; <span class="built_in">bytes</span></div></pre></td></tr></table></figure>

<p><strong>消费者组</strong>: 协调器负责选择所有成员都兼容协议（即分区分配策略），Leader是实际执行分配的成员，加入群请求可以包含多个分配策略，从而支持现有版本升级或者更改不同的分配策略。</p>
<p>可能的错误码（Possible Error Codes）:</p>
<ul>
<li>GROUP_LOAD_IN_PROGRESS (14)</li>
<li>GROUP_COORDINATOR_NOT_AVAILABLE (15)</li>
<li>NOT_COORDINATOR_FOR_GROUP (16)</li>
<li>INCONSISTENT_GROUP_PROTOCOL (23)</li>
<li>UNKNOWN_MEMBER_ID (25)</li>
<li>INVALID_SESSION_TIMEOUT (26)</li>
<li>GROUP_AUTHORIZATION_FAILED (30)</li>
</ul>
<h5 id="SyncGroup_Request">SyncGroup Request</h5>
<p>组长（group leader）使用同步组请求用来向当前组中的所有成员进行状态分配（例如分区分配）。所有成员加入该组后，立即发送SyncGroup，但只有Leader承担这个工作。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="constant">SyncGroupRequest</span> =&gt; GroupId GenerationId MemberId GroupAssignment</div><div class="line"><span class="constant">  GroupId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  GenerationId</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  MemberId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  GroupAssignment</span> =&gt; [MemberId MemberAssignment]</div><div class="line"><span class="constant">    MemberId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">    MemberAssignment</span> =&gt; <span class="built_in">bytes</span></div></pre></td></tr></table></figure>

<p>消费者组: 消费则组中MemberAssignment字段的格式如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="constant">MemberAssignment</span> =&gt; Version PartitionAssignment</div><div class="line"><span class="constant">  Version</span> =&gt; int16</div><div class="line"><span class="constant">  PartitionAssignment</span> =&gt; [Topic [Partition]]</div><div class="line"><span class="constant">    Topic</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">    Partition</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  UserData</span> =&gt; <span class="built_in">bytes</span></div></pre></td></tr></table></figure>

<p>所有实现了“consumer”协议类型的客户端实现都需要支持这个scheme。</p>
<h5 id="Sync_Group_Response">Sync Group Response</h5>
<p>组中的每个成员都会接收到leader发出的同步组响应。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="constant">SyncGroupResponse</span> =&gt; ErrorCode MemberAssignment</div><div class="line"><span class="constant">  ErrorCode</span> =&gt; int16</div><div class="line"><span class="constant">  MemberAssignment</span> =&gt; <span class="built_in">bytes</span></div></pre></td></tr></table></figure>

<p><strong>可能的错误代码</strong>（Possible Error Codes）:</p>
<ul>
<li>GROUP_COORDINATOR_NOT_AVAILABLE (15)</li>
<li>NOT_COORDINATOR_FOR_GROUP (16)</li>
<li>ILLEGAL_GENERATION (22)</li>
<li>UNKNOWN_MEMBER_ID (25)</li>
<li>REBALANCE_IN_PROGRESS (27)</li>
<li>GROUP_AUTHORIZATION_FAILED (30)</li>
</ul>
<h5 id="Heartbeat_Request">Heartbeat Request</h5>
<p>每当一个成员加入并同步完成，他将开始发送心跳请求使自己留在组里。当协调器在配置的会话超时时间内没有他的收到心跳请求，该成员会被踢出该组。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="constant">HeartbeatRequest</span> =&gt; GroupId GenerationId MemberId</div><div class="line"><span class="constant">  GroupId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  GenerationId</span> =&gt; <span class="built_in">int32</span></div><div class="line"><span class="constant">  MemberId</span> =&gt; <span class="built_in">string</span></div></pre></td></tr></table></figure>

<h5 id="Heartbeat_Response">Heartbeat Response</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="constant">HeartbeatResponse</span> =&gt; ErrorCode</div><div class="line"><span class="constant">  ErrorCode</span> =&gt; int16</div></pre></td></tr></table></figure>

<p><strong>可能的错误代码</strong>（Possible Error Codes）:</p>
<ul>
<li>GROUP_COORDINATOR_NOT_AVAILABLE (15)</li>
<li>NOT_COORDINATOR_FOR_GROUP (16)</li>
<li>ILLEGAL_GENERATION (22)</li>
<li>UNKNOWN_MEMBER_ID (25)</li>
<li>REBALANCE_IN_PROGRESS (27)</li>
<li>GROUP_AUTHORIZATION_FAILED (30)</li>
</ul>
<h5 id="LeaveGroup_Request">LeaveGroup Request</h5>
<p>当想要离开组群时，用户可以发送一个退组请求。这优先于会话超时，因为它能使该组快速再平衡，这对于消费者而言这意味着可以用更短的时间将分区分配到一个活动的成员。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="constant">LeaveGroupRequest</span> =&gt; GroupId MemberId</div><div class="line"><span class="constant">  GroupId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  MemberId</span> =&gt; <span class="built_in">string</span></div></pre></td></tr></table></figure>

<h5 id="LeaveGroup_Response">LeaveGroup Response</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="constant">LeaveGroupResponse</span> =&gt; ErrorCode</div><div class="line"><span class="constant">  ErrorCode</span> =&gt; int16</div></pre></td></tr></table></figure>

<p><strong>可能的错误代码</strong>（Possible Error Codes）:</p>
<ul>
<li>GROUP_LOAD_IN_PROGRESS (14)</li>
<li>CONSUMER_COORDINATOR_NOT_AVAILABLE (15)</li>
<li>NOT_COORDINATOR_FOR_CONSUMER (16)</li>
<li>UNKNOWN_CONSUMER_ID (25)</li>
<li>GROUP_AUTHORIZATION_FAILED (30)</li>
</ul>
<h4 id="管理接口（Administrative_API）">管理接口（Administrative API）</h4>
<h5 id="ListGroups_Request">ListGroups Request</h5>
<p>该API可用于找到当前被broker管理的组群。为了得到集群内的所有组列表，你必须向所有broker发送组列表请求。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ListGroupsRequest </span>=<span class="string">&gt;</span></div></pre></td></tr></table></figure>

<h5 id="ListGroups_Response">ListGroups Response</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="constant">ListGroupsResponse</span> =&gt; ErrorCode Groups</div><div class="line"><span class="constant">  ErrorCode</span> =&gt; int16</div><div class="line"><span class="constant">  Groups</span> =&gt; [GroupId ProtocolType]</div><div class="line"><span class="constant">    GroupId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">    ProtocolType</span> =&gt; <span class="built_in">string</span></div></pre></td></tr></table></figure>

<p><strong>可能的错误代码</strong>（Possible Error Codes）:</p>
<ul>
<li>GROUP_COORDINATOR_NOT_AVAILABLE (15)</li>
<li>AUTHORIZATION_FAILED (29)</li>
</ul>
<h5 id="DescribeGroups_Request">DescribeGroups Request</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="constant">DescribeGroupsRequest</span> =&gt; [GroupId]</div><div class="line"><span class="constant">  GroupId</span> =&gt; <span class="built_in">string</span></div></pre></td></tr></table></figure>

<h5 id="DescribeGroups_Response">DescribeGroups Response</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="constant">DescribeGroupsResponse</span> =&gt; [ErrorCode GroupId State ProtocolType Protocol Members]</div><div class="line"><span class="constant">  ErrorCode</span> =&gt; int16</div><div class="line"><span class="constant">  GroupId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  State</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  ProtocolType</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  Protocol</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">  Members</span> =&gt; [MemberId ClientId ClientHost MemberMetadata MemberAssignment]</div><div class="line"><span class="constant">    MemberId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">    ClientId</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">    ClientHost</span> =&gt; <span class="built_in">string</span></div><div class="line"><span class="constant">    MemberMetadata</span> =&gt; <span class="built_in">bytes</span></div><div class="line"><span class="constant">    MemberAssignment</span> =&gt; <span class="built_in">bytes</span></div></pre></td></tr></table></figure>

<p><strong>可能的错误代码</strong>（Possible Error Codes）:</p>
<ul>
<li>GROUP_LOAD_IN_PROGRESS (14)</li>
<li>GROUP_COORDINATOR_NOT_AVAILABLE (15)</li>
<li>NOT_COORDINATOR_FOR_GROUP (16)</li>
<li>AUTHORIZATION_FAILED (29)</li>
</ul>
<h3 id="常量（Constants）">常量（Constants）</h3>
<h4 id="Api_Keys_And_Current_Versions">Api Keys And Current Versions</h4>
<p>下面是请求中ApiKey的数字值，用来表示上面所述的请求类型。</p>
<table>
<thead>
<tr>
<th>接口名称（API NAME）</th>
<th>APIKEY值</th>
</tr>
</thead>
<tbody>
<tr>
<td>ProduceRequest</td>
<td>0</td>
</tr>
<tr>
<td>FetchRequest</td>
<td>1</td>
</tr>
<tr>
<td>OffsetRequest</td>
<td>2</td>
</tr>
<tr>
<td>MetadataRequest</td>
<td>3</td>
</tr>
<tr>
<td>Non-user facing control APIs</td>
<td>4-7</td>
</tr>
<tr>
<td>OffsetCommitRequest</td>
<td>8</td>
</tr>
<tr>
<td>OffsetFetchRequest</td>
<td>9</td>
</tr>
<tr>
<td>GroupCoordinatorRequest</td>
<td>10</td>
</tr>
<tr>
<td>JoinGroupRequest</td>
<td>11</td>
</tr>
<tr>
<td>HeartbeatRequest</td>
<td>12</td>
</tr>
<tr>
<td>LeaveGroupRequest</td>
<td>13</td>
</tr>
<tr>
<td>SyncGroupRequest</td>
<td>14</td>
</tr>
<tr>
<td>DescribeGroupsRequest</td>
<td>15</td>
</tr>
<tr>
<td>ListGroupsRequest</td>
<td>16</td>
</tr>
</tbody>
</table>
<h4 id="Error_Codes">Error Codes</h4>
<p>我们用数字代码表示服务器发生的问题。这些可以由客户端转换成客户端中的异常(Exceptions)或者其他任何适当的错误处理机制。这里是当前正在使用的错误代码表：</p>
<table><thead><tr><th>错误名称（Error）</th><th>编码（Code）</th><th>是否可重试（Retriable）</th><th>Description</th><th>描述</th></tr></thead><tbody><tr><td>NoError</td><td>0</td><td></td><td>No error–it worked!</td><td>没有错误</td></tr><tr><td>Unknown</td><td>-1</td><td></td><td>An unexpected server error</td><td>服务器未知错误</td></tr><tr><td>OffsetOutOfRange</td><td>1</td><td></td><td>The requested offset is outside the range of offsets maintained by the server for the given topic/partition.</td><td>请求的偏移量超过服务器维护的主题分区的偏移量。</td></tr><tr><td>InvalidMessage / CorruptMessage</td><td>2</td><td>Yes</td><td>This indicates that a message contents does not match its CRC</td><td>这个错误表示消息的内容与它的CRC校验码不符合。</td></tr><tr><td>UnknownTopicOrPartition</td><td>3</td><td>Yes</td><td>This request is for a topic or partition that does not exist on this broker.</td><td>broker上不存在所请求的主题或者分区。</td></tr><tr><td>InvalidMessageSize</td><td>4</td><td></td><td>The message has a negative size</td><td>消息长度为负数。</td></tr><tr><td>LeaderNotAvailable</td><td>5</td><td>Yes</td><td>This error is thrown if we are in the middle of a leadership election and there is currently no leader for this partition and hence it is unavailable for writes.</td><td>这个错误会在leader选举之间抛出，一样那位此时这个分区没有leader因此不能被写入。</td></tr><tr><td>NotLeaderForPartition</td><td>6</td><td>Yes</td><td>This error is thrown if the client attempts to send messages to a replica that is not the leader for some partition. It indicates that the clients metadata is out of date.</td><td>这个错误表示客户端正在把消息发送给副本，而不是分区的leader。这说明客户端的元数据已经过期。</td></tr><tr><td>RequestTimedOut</td><td>7</td><td>Yes</td><td>This error is thrown if the request exceeds the user-specified time limit in the request.</td><td>当这个请求超过了用户自定义的请求时间限制抛出此错误</td></tr><tr><td>BrokerNotAvailable</td><td>8</td><td></td><td>This is not a client facing error and is used mostly by tools when a broker is not alive.</td><td>这个不是客户端所能接受到的错误，一般被工具用在broker没有活动的场合。</td></tr><tr><td>ReplicaNotAvailable</td><td>9</td><td></td><td>If replica is expected on a broker, but is not (this can be safely ignored).</td><td>当broker希望有副本而实际上并没有时抛出（这个错误可以被安全地忽略）。</td></tr><tr><td>MessageSizeTooLarge</td><td>10</td><td></td><td>The server has a configurable maximum message size to avoid unbounded memory allocation. This error is thrown if the client attempt to produce a message larger than this maximum.</td><td>当服务器配置了一个最大消息长度以避免无限制的内存分配时，客户端产生了一个超过这个最大值的消息会抛出此错误。</td></tr><tr><td>StaleControllerEpochCode</td><td>11</td><td></td><td>Internal error code for broker-to-broker communication.</td><td>broker之间内部通讯是的错误。</td></tr><tr><td>OffsetMetadataTooLargeCode</td><td>12</td><td></td><td>If you specify a string larger than configured maximum for offset metadata</td><td>如果你赋了一个超过所配置的最大偏移量元数据的字符串时触发。</td></tr><tr><td>GroupLoadInProgressCode</td><td>14</td><td>Yes</td><td>The broker returns this error code for an offset fetch request if it is still loading offsets (after a leader change for that offsets topic partition), or in response to group membership requests (such as heartbeats) when group metadata is being loaded by the coordinator.</td><td>broker会在以下情况下返回这个错误：当broker人在加载偏移量时（主题分区的leader发生变化后）请求偏移量获取请求；或者正在反馈组成员请求（比如心跳）时，组的元数据正在被协调器加载。</td></tr><tr><td>GroupCoordinatorNotAvailableCode</td><td>15</td><td>Yes</td><td>The broker returns this error code for group coordinator requests, offset commits, and most group management requests if the offsets topic has not yet been created, or if the group coordinator is not active.</td><td>组协调器请求，偏移量提交和大部分组管理请求时，偏移量主题还没有被建立或者组协调器还没有激活是broker会返回此错误。</td></tr><tr><td>NotCoordinatorForGroupCode</td><td>16</td><td>Yes</td><td>The broker returns this error code if it receives an offset fetch or commit request for a group that it is not a coordinator for.</td><td>非该组协调器的broker接收到一个偏移量获取或提交请求时返回此错误。</td></tr><tr><td>InvalidTopicCode</td><td>17</td><td></td><td>For a request which attempts to access an invalid topic (e.g. one which has an illegal name), or if an attempt is made to write to an internal topic (such as the consumer offsets topic).</td><td>请求指令尝试访问一个非法的主题（例如，一个包含非法名称的主题），或者尝试写入一个内部主题（例如消费者偏移量主题）。</td></tr><tr><td>RecordListTooLargeCode</td><td>18</td><td></td><td>If a message batch in a produce request exceeds the maximum configured segment size.</td><td>批处理消息片段数组的长度超过了配置的最大消息片段数。</td></tr><tr><td>NotEnoughReplicasCode</td><td>19</td><td>Yes</td><td>Returned from a produce request when the number of in-sync replicas is lower than the configured minimum and requiredAcks is -1.</td><td>当同步中的副本数量小于配置的最小数量，并且requiredAcks设置为-1时返回此错误</td></tr><tr><td>NotEnoughReplicasAfterAppendCode</td><td>20</td><td>Yes</td><td>Returned from a produce request when the message was written to the log, but with fewer in-sync replicas than required.</td><td>消息已经写入日志文件，但是同步中的副本数量比请求中要求的数量少时返回此错误码</td></tr><tr><td>InvalidRequiredAcksCode</td><td>21</td><td></td><td>Returned from a produce request if the requested requiredAcks is invalid (anything other than -1, 1, or 0).</td><td>请求的requiredAcks非法（任何非-1，1或者0）时返回此错误码。</td></tr><tr><td>IllegalGenerationCode</td><td>22</td><td></td><td>Returned from group membership requests (such as heartbeats) when the generation id provided in the request is not the current generation.</td><td>组籍管理请求（诸如心跳请求）时generation id不是与当前不一致时返回此错误码</td></tr><tr><td>InconsistentGroupProtocolCode</td><td>23</td><td></td><td>Returned in join group when the member provides a protocol type or set of protocols which is not compatible with the current group.</td><td>加入组请求时成员提供的协议类型或者协议类型组与当前组不兼容时返回。</td></tr><tr><td>InvalidGroupIdCode</td><td>24</td><td></td><td>Returned in join group when the groupId is empty or null.</td><td>加入组请求时groupId为空或者null是返回。</td></tr><tr><td>UnknownMemberIdCode</td><td>25</td><td></td><td>Returned from group requests (offset commits/fetches, heartbeats, etc) when the memberId is not in the current generation.</td><td>组请求（偏移量提交/获取，心跳等）时memberId不在当前的generation。</td></tr><tr><td>InvalidSessionTimeoutCode</td><td>26</td><td></td><td>Return in join group when the requested session timeout is outside of the allowed range on the broker</td><td>加入组请求时请求的会话超时超过broker允许的限制。</td></tr><tr><td>RebalanceInProgressCode</td><td>27</td><td></td><td>Returned in heartbeat requests when the coordinator has begun rebalancing the group. This indicates to the client that it should rejoin the group.</td><td>心跳请求时协调器已经开始了组的再平衡，这意味着客户端必须重新加入组。</td></tr><tr><td>InvalidCommitOffsetSizeCode</td><td>28</td><td></td><td>This error indicates that an offset commit was rejected because of oversize metadata.</td><td>这个错意味着偏移量提交因为超过了元数据大小而被拒绝。</td></tr><tr><td>TopicAuthorizationFailedCode</td><td>29</td><td></td><td>Returned by the broker when the client is not authorized to access the requested topic.</td><td>客户端没有访问请求主题的权限时，broker返回此错误。</td></tr><tr><td>GroupAuthorizationFailedCode</td><td>30</td><td></td><td>Returned by the broker when the client is not authorized to access a particular groupId.</td><td>客户端没有访问特定groupId的权限时，broker返回此错误。</td></tr><tr><td>ClusterAuthorizationFailedCode</td><td>31</td><td></td><td>Returned by the broker when the client is not authorized to use an inter-broker or administrative API.</td><td>客户端没有权限访问broker之间的接口或者管理接口时，broker返回此错误。</td></tr></tbody></table>

<h2 id="一些常见的哲学问题（Some_Common_Philosophical_Questions）">一些常见的哲学问题（Some Common Philosophical Questions）</h2>
<p>有些人问，为什么我们不使用HTTP。有许多原因，最主要的是客户端实现可以使用一些更高级的TCP特性–请求的多工（multiplex）能力（译者注：同一个TCP连接中同时发送多个请求，http长连接必须等到前一次请求结束才能发送后一个请求，否则需要多个http连接），同时轮询多个连接的能力，等等。我们还发现HTTP库在许多编程语言中非常是出奇地破旧（shabby -_-!）。</p>
<p>还有人问，也许我们可以支持许多不同的协议。此前的经验是，多协议支持的是很难添加和测试新功能，因为他们要被移植到许多协议实现中。我们感觉，大多数用户并不在乎支持多个协议这些特性，他们只是希望在自己选择的语言中实现了良好可靠的客户端。</p>
<p>另一个问题是，为什么我们不采用XMPP，STOMP，AMQP或现有的协议。这个问题的不同协议有不同答案，但在共通的问题是，这些协议的确确定了大部分实现，但如果我们没有协议的控制权，我们就实现不了我们的功能。我们相信，我们可以实现比现有消息系统更好的真正的分布式消息系统，但要做到这一点，我们需要建立不同的工作模式。</p>
<p>最后一个问题是，为什么我们不使用的Protocol Buffers或Thrift来定义我们的请求消息格式。这些库擅长帮助您管理非常多的序列化的消息。然而，我们只有几个消息。而且这些库跨语言的支持是有点参差不齐（取决于软件包）。最后，我们颇为谨慎地管理二进制日志格式和传输协议之间的映射，而用如果使用这些系统将变得不太可能。最后，我们比较喜欢让API有明确的版本并且通过检查版来引入原本为空的新值，因为它能更细致地控制兼容性。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>官方英文版本: <a href="https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol" target="_blank" rel="external">A Guide To The Kafka Protocol</a></p>
<p>中文翻译： <a href="http://watchword.space" target="_blank" rel="external">watchword</a> 翻译于2016年1月31日，修改于6月17日，基于原文2016年5月5日修改版本（v.106）修改翻译： <a href="http://watchword.space/blog/?p=39" target="_blank" rel="external">Kafka通讯协议指南</a></p>
<p><a href="http://colobu.com" target="_blank" rel="external">smallnest</a> 基于原文 Jan 20, 2017版本修改。</p>
<p>如果想深入了解Kafka的通讯协议的话，这篇文章不可不读。感谢 watchword 将原文翻译成了中文，我基于最新版进行了修订,修订和完善翻译中的错误。</p>
]]>
    
    </summary>
    
      <category term="Kafka" scheme="http://colobu.com/tags/Kafka/"/>
    
      <category term="大数据" scheme="http://colobu.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在长城后面go get一些库]]></title>
    <link href="http://colobu.com/2017/01/26/how-to-go-get-behind-GFW/"/>
    <id>http://colobu.com/2017/01/26/how-to-go-get-behind-GFW/</id>
    <published>2017-01-26T03:03:31.000Z</published>
    <updated>2017-01-26T03:30:56.000Z</updated>
    <content type="html"><![CDATA[<p>国内的Go开发已然蔚然成风，但是Go开发者比较痛苦的是，golang.org网站以及其它的一些相关的开发网站被GFW屏蔽了。下载Go开发包海容易些，国内有一些镜像站点，或者通过一些代理也能访问，但是下载一些开发库的时候，这些库可能直接或者间接引用了 ｀golang.org/x/...｀等依赖库， 通过<code>go get</code>命令确没有办法下载下来。</p>
<p>我原先在Comcast，这是一家外企，在国内有vpn可以直接访问这些网站，所以以前没有觉得<code>go get</code>是一个问题，看到大家被GFW弄的焦头烂额的时候也没觉得是一件大事情，现在换到国内的互联网企业，切切实实的感觉到GFW的威力。首先是google.com, golang.org等网站被屏蔽掉了，其次 <code>go get</code> 一些库如<code>golangorg/x/net</code>失败。</p>
<a id="more"></a>
<p>总得想些办法吧。如果有自己的VPN的话，应该比较好的解决，我没有，不过我比较熟悉的是shadowsocks，所以基于shadowsocks想了一些办法，总算能正常的下载了，本文纪录一下这曲折的过程。</p>
<p>shadowsocks的安装和使用我就不说了，请自行搜索。Shadowsocks虽然能访问一些屏蔽的站点比如golang.org,但是它基于socks5协议，对于<code>go get</code>来说，依然不可用。</p>
<p>下一步就是想办法将socks5代理转为http代理了。</p>
<p>一个方法如 <a href="http://www.jianshu.com/p/f5690454c6e0" target="_blank" rel="external">mac下宿主机和docker内go get代理设置</a>一文中介绍的privoxy,不过我没有试成功。</p>
<p>另一个方法是实用 <a href="https://github.com/cyfdecyf/cow/" target="_blank" rel="external">cow</a>, 这是shadowsocks-go作者的另一个开发项目，根据项目介绍很容易的配置,可以在本机启动一个http代理，以shadowsocks为二级代理。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">listen</span> = <span class="url">http://127.0.0.1:7777</span></div><div class="line">proxy = socks5://<span class="number">127.0.0.1:1080</span></div></pre></td></tr></table></figure>

<p>然后设置环境变量，就可以<code>go get</code>被屏蔽的库了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> http_proxy=http:<span class="comment">//127.0.0.1:7777</span></div><div class="line"><span class="keyword">export</span> https_proxy=http:<span class="comment">//127.0.0.1:7777</span></div></pre></td></tr></table></figure>

<p>如果没有代理，而你又需要<code>golang.org/x／...</code>的包，你可以手工在你的GOPATH下创建这些目录，然后 <code>git clone github.com/golang/xxx</code>相应的目录即可(xxx替换成泥需要的库，比如net)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>国内的Go开发已然蔚然成风，但是Go开发者比较痛苦的是，golang.org网站以及其它的一些相关的开发网站被GFW屏蔽了。下载Go开发包海容易些，国内有一些镜像站点，或者通过一些代理也能访问，但是下载一些开发库的时候，这些库可能直接或者间接引用了 ｀golang.org/x/...｀等依赖库， 通过<code>go get</code>命令确没有办法下载下来。</p>
<p>我原先在Comcast，这是一家外企，在国内有vpn可以直接访问这些网站，所以以前没有觉得<code>go get</code>是一个问题，看到大家被GFW弄的焦头烂额的时候也没觉得是一件大事情，现在换到国内的互联网企业，切切实实的感觉到GFW的威力。首先是google.com, golang.org等网站被屏蔽掉了，其次 <code>go get</code> 一些库如<code>golangorg/x/net</code>失败。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[]T 还是 []*T, 这是一个问题]]></title>
    <link href="http://colobu.com/2017/01/05/-T-or-T-it-s-a-question/"/>
    <id>http://colobu.com/2017/01/05/-T-or-T-it-s-a-question/</id>
    <published>2017-01-05T06:56:36.000Z</published>
    <updated>2017-01-05T10:49:26.000Z</updated>
    <content type="html"><![CDATA[<p>在编程语言深入讨论中，经常被大家提起也是争论最多的讨论之一就是按值(by value)还是按引用传递(by reference， by pointer)，你可以在C/C++或者Java的社区经常看到这样的讨论，也会看到很多这样的面试题。</p>
<p>对于Go语言，严格意义上来讲，只有一种传递，也就是按值传递(by value)。当一个变量当作参数传递的时候，会创建一个变量的副本，然后传递给函数或者方法，你可以看到这个副本的地址和变量的地址是不一样的。</p>
<p>当变量当做指针被传递的时候，一个新的指针被创建，它指向变量指向的同样的内存地址，所以你可以将这个指针看成原始变量指针的副本。当这样理解的时候，我们就可以理解成Go总是创建一个副本按值转递，只不过这个副本有时候是变量的副本，有时候是变量指针的副本。</p>
<p>这是Go语言中你理解后续问题的基础。</p>
<p>但是Go语言的情况比较复杂，我们什么时候选择 <code>T</code> 作为参数类型，什么时候选择 <code>*T</code>作为参数类型？ <code>[]T</code>是传递的指针还是值？选择<code>[]T</code>还是<code>[]*T</code>? 哪些类型复制和传递的时候会创建副本？什么情况下会发生副本创建？</p>
<p>本文将详细介绍Go语言的变量的副本创建还是变量指针的副本创建的case以及各种类型在这些case的情况。</p>
<a id="more"></a>
<h2 id="副本的创建">副本的创建</h2>
<p>前面已经讲到，<code>T</code>类型的变量和<code>*T</code>类型的变量在当做函数或者方法的参数时会传递它的副本。我们先看看例子。</p>
<h3 id="T的副本创建">T的副本创建</h3>
<p>首先看一下 参数类型为<code>T</code>的函数调用的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> {</div><div class="line">	Age  <span class="typename">int</span></div><div class="line">	Name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> passV(b Bird) {</div><div class="line">	b.Age++</div><div class="line">	b.Name = <span class="string">"Great"</span> + b.Name</div><div class="line">	fmt.Printf(<span class="string">"传入修改后的Bird:\t %+v, \t内存地址：%p\n"</span>, b, &b)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	parrot := Bird{Age:<span class="number"> 1</span>, Name: <span class="string">"Blue"</span>}</div><div class="line">	fmt.Printf(<span class="string">"原始的Bird:\t\t %+v, \t\t内存地址：%p\n"</span>, parrot, &parrot)</div><div class="line">	passV(parrot)</div><div class="line">	fmt.Printf(<span class="string">"调用后原始的Bird:\t %+v, \t\t内存地址：%p\n"</span>, parrot, &parrot)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行后输入结果(每次运行指针的值可能不同):</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">原始的<span class="tag">Bird</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">1</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xc420012260</span></div><div class="line">传入修改后的<span class="tag">Bird</span>:	 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">2</span> Name:GreatBlue</span></span></span>}, 	内存地址：0<span class="tag">xc4200122c0</span></div><div class="line">调用后原始的<span class="tag">Bird</span>:	 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">1</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xc420012260</span></div></pre></td></tr></table></figure>

<p>可以看到，在<code>T</code>类型作为参数的时候，传递的参数parrot会将它的副本(内存地址0xc4200122c0)传递给函数<code>passV</code>,在这个函数内对参数的改变不会影响原始的对象。</p>
<h3 id="*T的副本创建">*T的副本创建</h3>
<p>修改上面的例子，将函数的参数类型由<code>T</code>改为<code>*T</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> {</div><div class="line">	Age  <span class="typename">int</span></div><div class="line">	Name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> passP(b *Bird) {</div><div class="line">	b.Age++</div><div class="line">	b.Name = <span class="string">"Great"</span> + b.Name</div><div class="line">	fmt.Printf(<span class="string">"传入修改后的Bird:\t %+v, \t内存地址：%p, 指针的内存地址: %p\n"</span>, *b, b, &b)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	parrot := &Bird{Age:<span class="number"> 1</span>, Name: <span class="string">"Blue"</span>}</div><div class="line">	fmt.Printf(<span class="string">"原始的Bird:\t\t %+v, \t\t内存地址：%p, 指针的内存地址: %p\n"</span>, *parrot, parrot, &parrot)</div><div class="line">	passP(parrot)</div><div class="line">	fmt.Printf(<span class="string">"调用后原始的Bird:\t %+v, \t内存地址：%p, 指针的内存地址: %p\n"</span>, *parrot, parrot, &parrot)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行后输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">原始的<span class="tag">Bird</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">1</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xc420076000</span>, 指针的内存地址: 0<span class="tag">xc420074000</span></div><div class="line">传入修改后的<span class="tag">Bird</span>:	 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">2</span> Name:GreatBlue</span></span></span>}, 	内存地址：0<span class="tag">xc420076000</span>, 指针的内存地址: 0<span class="tag">xc420074010</span></div><div class="line">调用后原始的<span class="tag">Bird</span>:	 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">2</span> Name:GreatBlue</span></span></span>}, 	内存地址：0<span class="tag">xc420076000</span>, 指针的内存地址: 0<span class="tag">xc420074000</span></div></pre></td></tr></table></figure>

<p>可以看到在函数<code>passP</code>中，参数<code>p</code>是一个指向Bird的指针，传递参数给它的时候会创建指针的副本(0xc420074010)，只不过指针<code>0xc420074000</code>和<code>0xc420074010</code>都指向内存地址<code>0xc420076000</code>。 函数内对<code>*T</code>的改变显然会影响原始的对象，因为它是对同一个对象的操作。</p>
<p>当然，一位对Go有深入了解的读者都已经对这个知识有所了解，也明白了<code>T</code>和<code>*T</code>作为参数的时候副本创建的不同。</p>
<h2 id="如何选择_T_和_*T">如何选择 <code>T</code> 和 <code>*T</code></h2>
<p>在定义函数和方法的时候，作为一位资深的Go开发人员，一定会对函数的参数和返回值定义成<code>T</code>和<code>*T</code>深思熟虑，有些情况下可能还会有些苦恼。<br>那么什么时候才应该把参数定义成类型<code>T</code>,什么情况下定义成类型<code>*T</code>呢。</p>
<p>一般的判断标准是看副本创建的成本和需求。</p>
<ol>
<li>不想变量被修改。 如果你不想变量被函数和方法所修改，那么选择类型<code>T</code>。相反，如果想修改原始的变量，则选择<code>*T</code></li>
<li>如果变量是一个<strong>大</strong>的struct或者数组，则副本的创建相对会影响性能，这个时候考虑使用<code>*T</code>，只创建新的指针，这个区别是巨大的</li>
<li>(不针对函数参数，只针对本地变量／本地变量)对于函数作用域内的参数，如果定义成<code>T</code>,Go编译器尽量将对象分配到栈上，而<code>*T</code>很可能会分配到对象上，这对垃圾回收会有影响</li>
</ol>
<h2 id="什么时候发生副本创建">什么时候发生副本创建</h2>
<p>上面举的例子都是作为函数参数时发生的副本的创建，还有很多情况下会发生副本的创建，甚至有些“隐蔽”的情况。<br>编程的时候如何小心这些情况呢，一条原则就是：</p>
<p><strong> A go assignment is a copy of the value itself </strong><br><strong> 赋值的时候就会创建对象副本</strong></p>
<p>Assignment的语法表达式如下：</p>
<blockquote>
<p>Assignment = ExpressionList assign_op ExpressionList .<br>assign_op = [ add_op | mul_op ] &quot;=&quot; .</p>
<p>Each left-hand side operand must be addressable, a map index expression, or (for = assignments only) the blank identifier. Operands may be parenthesized.</p>
</blockquote>
<h3 id="最常见的case">最常见的case</h3>
<p>最常见的赋值的例子是对变量的赋值，包括函数内和函数外:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> {</div><div class="line">	Age  <span class="typename">int</span></div><div class="line">	Name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Parrot <span class="keyword">struct</span> {</div><div class="line">	Age  <span class="typename">int</span></div><div class="line">	Name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> parrot1 = Bird{Age:<span class="number"> 1</span>, Name: <span class="string">"Blue"</span>}</div><div class="line"><span class="keyword">var</span> parrot2 = parrot1</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	fmt.Printf(<span class="string">"parrot1:\t\t %+v, \t\t内存地址：%p\n"</span>, parrot1, &parrot1)</div><div class="line">	fmt.Printf(<span class="string">"parrot2:\t\t %+v, \t\t内存地址：%p\n"</span>, parrot2, &parrot2)</div><div class="line"></div><div class="line">	parrot3 := parrot1</div><div class="line">	fmt.Printf(<span class="string">"parrot2:\t\t %+v, \t\t内存地址：%p\n"</span>, parrot3, &parrot3)</div><div class="line"></div><div class="line">	parrot4 := Parrot(parrot1)</div><div class="line">	fmt.Printf(<span class="string">"parrot4:\t\t %+v, \t\t内存地址：%p\n"</span>, parrot4, &parrot4)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">parrot1</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">1</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xfa0a0</span></div><div class="line"><span class="tag">parrot2</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">1</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xfa0c0</span></div><div class="line"><span class="tag">parrot2</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">1</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xc42007e0c0</span></div><div class="line"><span class="tag">parrot4</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">1</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xc42007e100</span></div></pre></td></tr></table></figure>

<p>可以看到这几个变量的内存地址都不相同，说明发生了赋值。</p>
<h3 id="map、slice和数组">map、slice和数组</h3>
<p>slice，map和数组在初始化和按索引设置的时候也会创建副本:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> {</div><div class="line">	Age  <span class="typename">int</span></div><div class="line">	Name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> parrot1 = Bird{Age:<span class="number"> 1</span>, Name: <span class="string">"Blue"</span>}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	fmt.Printf(<span class="string">"parrot1:\t\t %+v, \t\t内存地址：%p\n"</span>, parrot1, &parrot1)</div><div class="line"></div><div class="line">	<span class="comment">//slice</span></div><div class="line">	s := []Bird{parrot1}</div><div class="line">	s = <span class="built_in">append</span>(s, parrot1)</div><div class="line">	parrot1.Age =<span class="number"> 3</span></div><div class="line">	fmt.Printf(<span class="string">"parrot2:\t\t %+v, \t\t内存地址：%p\n"</span>, s<span class="number">[0</span>], &(s<span class="number">[0</span>]))</div><div class="line">	fmt.Printf(<span class="string">"parrot3:\t\t %+v, \t\t内存地址：%p\n"</span>, s<span class="number">[1</span>], &(s<span class="number">[1</span>]))</div><div class="line">	parrot1.Age =<span class="number"> 1</span></div><div class="line"></div><div class="line">	<span class="comment">//map</span></div><div class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">int</span>]Bird)</div><div class="line">	m<span class="number">[0</span>] = parrot1</div><div class="line">	parrot1.Age =<span class="number"> 4</span></div><div class="line">	fmt.Printf(<span class="string">"parrot4:\t\t %+v\n"</span>, m<span class="number">[0</span>])</div><div class="line">	parrot1.Age =<span class="number"> 5</span></div><div class="line">	parrot5 := m<span class="number">[0</span>]</div><div class="line">	fmt.Printf(<span class="string">"parrot5:\t\t %+v, \t\t内存地址：%p\n"</span>, parrot5, &parrot5)</div><div class="line">	parrot1.Age =<span class="number"> 1</span></div><div class="line"></div><div class="line">	<span class="comment">//array</span></div><div class="line">	a := <span class="number">[2</span>]Bird{parrot1}</div><div class="line">	parrot1.Age =<span class="number"> 6</span></div><div class="line">	fmt.Printf(<span class="string">"parrot6:\t\t %+v, \t\t内存地址：%p\n"</span>, a<span class="number">[0</span>], &a<span class="number">[0</span>])</div><div class="line">	parrot1.Age =<span class="number"> 1</span></div><div class="line">	a<span class="number">[1</span>] = parrot1</div><div class="line">	parrot1.Age =<span class="number"> 7</span></div><div class="line">	fmt.Printf(<span class="string">"parrot7:\t\t %+v, \t\t内存地址：%p\n"</span>, a<span class="number">[1</span>], &a<span class="number">[1</span>])</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">parrot1:		 {Age<span class="number">:1</span> Name:Blue}, 		内存地址<span class="number">：0</span>xfa0a0</div><div class="line">parrot2:		 {Age<span class="number">:1</span> Name:Blue}, 		内存地址<span class="number">：0</span>xc4200160f0</div><div class="line">parrot3:		 {Age<span class="number">:1</span> Name:Blue}, 		内存地址<span class="number">：0</span>xc420016108</div><div class="line">parrot4:		 {Age<span class="number">:1</span> Name:Blue}</div><div class="line">parrot5:		 {Age<span class="number">:1</span> Name:Blue}, 		内存地址<span class="number">：0</span>xc420012320</div><div class="line">parrot6:		 {Age<span class="number">:1</span> Name:Blue}, 		内存地址<span class="number">：0</span>xc420016120</div><div class="line">parrot7:		 {Age<span class="number">:1</span> Name:Blue}, 		内存地址<span class="number">：0</span>xc420016138</div></pre></td></tr></table></figure>

<p>可以看到 slice/map/数组 的元素全是原始变量的副本， <strong>副本</strong>。</p>
<h3 id="for－range循环">for－range循环</h3>
<p>for-range循环也是将元素的副本赋值给循环变量，所以变量得到的是集合元素的副本。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> {</div><div class="line">	Age  <span class="typename">int</span></div><div class="line">	Name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> parrot1 = Bird{Age:<span class="number"> 1</span>, Name: <span class="string">"Blue"</span>}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	fmt.Printf(<span class="string">"parrot1:\t\t %+v, \t\t内存地址：%p\n"</span>, parrot1, &parrot1)</div><div class="line"></div><div class="line">	<span class="comment">//slice</span></div><div class="line">	s := []Bird{parrot1, parrot1, parrot1}</div><div class="line">	s<span class="number">[0</span>].Age =<span class="number"> 1</span></div><div class="line">	s<span class="number">[1</span>].Age =<span class="number"> 2</span></div><div class="line">	s<span class="number">[2</span>].Age =<span class="number"> 3</span></div><div class="line">	parrot1.Age =<span class="number"> 4</span></div><div class="line">	<span class="keyword">for</span> i, p := <span class="keyword">range</span> s {</div><div class="line">		fmt.Printf(<span class="string">"parrot%d:\t\t %+v, \t\t内存地址：%p\n"</span>, (i +<span class="number"> 2</span>), p, &p)</div><div class="line">	}</div><div class="line">	parrot1.Age =<span class="number"> 1</span></div><div class="line"></div><div class="line">	<span class="comment">//map</span></div><div class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">int</span>]Bird)</div><div class="line">	parrot1.Age =<span class="number"> 1</span></div><div class="line">	m<span class="number">[0</span>] = parrot1</div><div class="line">	parrot1.Age =<span class="number"> 2</span></div><div class="line">	m<span class="number">[1</span>] = parrot1</div><div class="line">	parrot1.Age =<span class="number"> 3</span></div><div class="line">	m<span class="number">[2</span>] = parrot1</div><div class="line">	parrot1.Age =<span class="number"> 4</span></div><div class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m {</div><div class="line">		fmt.Printf(<span class="string">"parrot%d:\t\t %+v, \t\t内存地址：%p\n"</span>, (k +<span class="number"> 2</span>), v, &v)</div><div class="line">	}</div><div class="line">	parrot1.Age =<span class="number"> 4</span></div><div class="line"></div><div class="line">	<span class="comment">//array</span></div><div class="line">	a := [...]Bird{parrot1, parrot1, parrot1}</div><div class="line">	a<span class="number">[0</span>].Age =<span class="number"> 1</span></div><div class="line">	a<span class="number">[1</span>].Age =<span class="number"> 2</span></div><div class="line">	a<span class="number">[2</span>].Age =<span class="number"> 3</span></div><div class="line">	parrot1.Age =<span class="number"> 4</span></div><div class="line">	<span class="keyword">for</span> i, p := <span class="keyword">range</span> a {</div><div class="line">		fmt.Printf(<span class="string">"parrot%d:\t\t %+v, \t\t内存地址：%p\n"</span>, (i +<span class="number"> 2</span>), p, &p)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">parrot1</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">1</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xfb0a0</span></div><div class="line"><span class="tag">parrot2</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">1</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xc4200122a0</span></div><div class="line"><span class="tag">parrot3</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">2</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xc4200122a0</span></div><div class="line"><span class="tag">parrot4</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">3</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xc4200122a0</span></div><div class="line"><span class="tag">parrot2</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">1</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xc420012320</span></div><div class="line"><span class="tag">parrot3</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">2</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xc420012320</span></div><div class="line"><span class="tag">parrot4</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">3</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xc420012320</span></div><div class="line"><span class="tag">parrot2</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">1</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xc4200123a0</span></div><div class="line"><span class="tag">parrot3</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">2</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xc4200123a0</span></div><div class="line"><span class="tag">parrot4</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">3</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xc4200123a0</span></div></pre></td></tr></table></figure>

<p>注意循环变量是重用的，所以你看到它们的地址是相同的。</p>
<h3 id="channel">channel</h3>
<p>往channel中send对象的时候也会创建对象的副本:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> {</div><div class="line">	Age  <span class="typename">int</span></div><div class="line">	Name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> parrot1 = Bird{Age:<span class="number"> 1</span>, Name: <span class="string">"Blue"</span>}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Bird,<span class="number"> 3</span>)</div><div class="line">	fmt.Printf(<span class="string">"parrot1:\t\t %+v, \t\t内存地址：%p\n"</span>, parrot1, &parrot1)</div><div class="line">	ch &lt;- parrot1</div><div class="line">	parrot1.Age =<span class="number"> 2</span></div><div class="line">	ch &lt;- parrot1</div><div class="line">	parrot1.Age =<span class="number"> 3</span></div><div class="line">	ch &lt;- parrot1</div><div class="line">	parrot1.Age =<span class="number"> 4</span></div><div class="line"></div><div class="line">	p := &lt;-ch</div><div class="line">	fmt.Printf(<span class="string">"parrot%d:\t\t %+v, \t\t内存地址：%p\n"</span>,<span class="number"> 2</span>, p, &p)</div><div class="line">	p = &lt;-ch</div><div class="line">	fmt.Printf(<span class="string">"parrot%d:\t\t %+v, \t\t内存地址：%p\n"</span>,<span class="number"> 3</span>, p, &p)</div><div class="line">	p = &lt;-ch</div><div class="line">	fmt.Printf(<span class="string">"parrot%d:\t\t %+v, \t\t内存地址：%p\n"</span>,<span class="number"> 4</span>, p, &p)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">parrot1</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">1</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xfa0a0</span></div><div class="line"><span class="tag">parrot2</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">1</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xc4200122a0</span></div><div class="line"><span class="tag">parrot3</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">2</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xc4200122a0</span></div><div class="line"><span class="tag">parrot4</span>:		 <span class="rules">{<span class="rule"><span class="attribute">Age</span>:<span class="value"><span class="number">3</span> Name:Blue</span></span></span>}, 		内存地址：0<span class="tag">xc4200122a0</span></div></pre></td></tr></table></figure>

<h3 id="函数参数和返回值">函数参数和返回值</h3>
<p>将变量作为参数传递给函数和方法会发生副本的创建。<br>对于返回值，将返回值赋值给其它变量或者传递给其它的函数和方法，就会创建副本。</p>
<h3 id="Method_Receiver">Method Receiver</h3>
<p>因为方法(method)最终会产生一个receiver作为第一个参数的函数(参看规范)，所以就比较好理解method receiver的副本创建的规则了。<br>当receiver为<code>T</code>类型时，会发生创建副本，调用副本上的方法。<br>当receiver为<code>*T</code>类型时,只是会创建对象的指针，不创建对象的副本，方法内对receiver的改动会影响原始值。</p>
<h2 id="不同类型的副本创建">不同类型的副本创建</h2>
<h3 id="bool,数值和指针">bool,数值和指针</h3>
<p>bool和数值类型一般不必考虑指针类型，原因在于这些对象很小，创建副本的开销可以忽略。只有你在想修改同一个变量的值的时候才考虑它们的指针。</p>
<p>指针类型就不用多说了，和数值类型类似。</p>
<h3 id="数组">数组</h3>
<p>数组是值类型，赋值的时候会发生原始数组的复制，所以对于大的数组的参数传递和赋值，一定要慎重。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	a1 := <span class="number">[3</span>]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>}</div><div class="line">	fmt.Printf(<span class="string">"a1:\t\t %+v, \t\t内存地址：%p\n"</span>, a1, &a1)</div><div class="line">	a2 := a1</div><div class="line">	a1<span class="number">[0</span>] =<span class="number"> 4</span></div><div class="line">	a1<span class="number">[1</span>] =<span class="number"> 5</span></div><div class="line">	a1<span class="number">[2</span>] =<span class="number"> 6</span></div><div class="line">	fmt.Printf(<span class="string">"a2:\t\t %+v, \t\t内存地址：%p\n"</span>, a2, &a2)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">a1</span>:		 <span class="attr_selector">[1 2 3]</span>, 		内存地址：0<span class="tag">xc420012260</span></div><div class="line"><span class="tag">a2</span>:		 <span class="attr_selector">[1 2 3]</span>, 		内存地址：0<span class="tag">xc4200122c0</span></div></pre></td></tr></table></figure>

<p>对于<code>[...]T</code>和<code>[...]*T</code>的区别，我想你也应该清楚了，<code>[...]*T</code>创建的副本的元素时元数组元素指针的副本。</p>
<h3 id="map、slice_和_channel">map、slice 和 channel</h3>
<p>网上一般说， 这三种类型都是指向指针类型，指向一个底层的数据结构。<br>因此呢，在定义类型的时候就不必定义成<code>*T</code>了。</p>
<p>当然你可以这么认为，不过我认为这是不准确的，比如slice,其实你可以看成是<code>SliceHeader</code>对象，只不过它的数据<code>Data</code>是一个指针，所以它的副本的创建对性能的影响可以忽略。</p>
<h3 id="字符串">字符串</h3>
<p>string类型类似slice,它等价<code>StringHeader</code>。所以很多情况下会用｀unsafe.Pointer｀与[]byte类型进行更有效的转换，因为直接进行类型转换<code>string([]byte)</code>会发生数据的复制。</p>
<p>字符串比较特殊，它的值不能修改，任何想对字符串的值做修改都会生成新的字符串。</p>
<p>大部分情况下你不需要定义成<code>*string</code>。唯一的例外你需要 <code>nil</code>值的时候。我们知道，类型<code>string</code>的空值/缺省值为<code>&quot;&quot;</code>,但是如果你需要<code>nil</code>，你就必须定义<code>*string</code>。举个例子，在对象序列化的时候<code>&quot;&quot;</code>和<code>nil</code>表示的意义是不一样的，<code>&quot;&quot;</code>表示字段存在，只不过字符串是空值，而<code>nil</code>表示字段不存在。</p>
<h3 id="函数">函数</h3>
<p>函数也是一个指针类型，对函数对象的赋值只是又创建了一个对次函数对象的指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	f1 := <span class="keyword">func</span>(i <span class="typename">int</span>) {}</div><div class="line">	fmt.Printf(<span class="string">"f1:\t\t %+v, \t\t内存地址：%p\n"</span>, f1, &f1)</div><div class="line">	f2 := f1</div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"f2:\t\t %+v, \t\t内存地址：%p\n"</span>, f2, &f2)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="label">f1:</span>		 <span class="number">0x2200</span>, 		内存地址：<span class="number">0xc420028020</span></div><div class="line"><span class="label">f2:</span>		 <span class="number">0x2200</span>, 		内存地址：<span class="number">0xc420028030</span></div></pre></td></tr></table></figure>

<h2 id="参考文档">参考文档</h2>
<ol>
<li><a href="https://www.reddit.com/r/golang/comments/5lheyg/returning_t_vs_t/?" target="_blank" rel="external">https://www.reddit.com/r/golang/comments/5lheyg/returning_t_vs_t/?</a></li>
<li><a href="https://github.com/google/go-github/issues/180" target="_blank" rel="external">https://github.com/google/go-github/issues/180</a></li>
<li><a href="http://openmymind.net/Things-I-Wish-Someone-Had-Told-Me-About-Go/" target="_blank" rel="external">http://openmymind.net/Things-I-Wish-Someone-Had-Told-Me-About-Go/</a></li>
<li><a href="http://goinbigdata.com/golang-pass-by-pointer-vs-pass-by-value/" target="_blank" rel="external">http://goinbigdata.com/golang-pass-by-pointer-vs-pass-by-value/</a></li>
<li><a href="https://groups.google.com/forum/#!topic/golang-nuts/__BPVgK8LN0" target="_blank" rel="external">https://groups.google.com/forum/#!topic/golang-nuts/__BPVgK8LN0</a></li>
<li><a href="https://golang.org/ref/spec" target="_blank" rel="external">https://golang.org/ref/spec</a></li>
<li><a href="https://golang.org/doc/faq" target="_blank" rel="external">https://golang.org/doc/faq</a></li>
<li><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="external">https://golang.org/doc/effective_go.html</a></li>
<li><a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/" target="_blank" rel="external">https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/</a></li>
<li><a href="https://dhdersch.github.io/golang/2016/01/23/golang-when-to-use-string-pointers.html" target="_blank" rel="external">https://dhdersch.github.io/golang/2016/01/23/golang-when-to-use-string-pointers.html</a></li>
<li><a href="https://dave.cheney.net/2016/03/19/should-methods-be-declared-on-t-or-t" target="_blank" rel="external">https://dave.cheney.net/2016/03/19/should-methods-be-declared-on-t-or-t</a></li>
<li><a href="http://colobu.com/2016/10/28/When-are-function-parameters-passed-by-value/" target="_blank" rel="external">http://colobu.com/2016/10/28/When-are-function-parameters-passed-by-value/</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>在编程语言深入讨论中，经常被大家提起也是争论最多的讨论之一就是按值(by value)还是按引用传递(by reference， by pointer)，你可以在C/C++或者Java的社区经常看到这样的讨论，也会看到很多这样的面试题。</p>
<p>对于Go语言，严格意义上来讲，只有一种传递，也就是按值传递(by value)。当一个变量当作参数传递的时候，会创建一个变量的副本，然后传递给函数或者方法，你可以看到这个副本的地址和变量的地址是不一样的。</p>
<p>当变量当做指针被传递的时候，一个新的指针被创建，它指向变量指向的同样的内存地址，所以你可以将这个指针看成原始变量指针的副本。当这样理解的时候，我们就可以理解成Go总是创建一个副本按值转递，只不过这个副本有时候是变量的副本，有时候是变量指针的副本。</p>
<p>这是Go语言中你理解后续问题的基础。</p>
<p>但是Go语言的情况比较复杂，我们什么时候选择 <code>T</code> 作为参数类型，什么时候选择 <code>*T</code>作为参数类型？ <code>[]T</code>是传递的指针还是值？选择<code>[]T</code>还是<code>[]*T</code>? 哪些类型复制和传递的时候会创建副本？什么情况下会发生副本创建？</p>
<p>本文将详细介绍Go语言的变量的副本创建还是变量指针的副本创建的case以及各种类型在这些case的情况。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个有特色的有限状态机]]></title>
    <link href="http://colobu.com/2016/12/24/a-featured-fsm/"/>
    <id>http://colobu.com/2016/12/24/a-featured-fsm/</id>
    <published>2016-12-24T07:12:48.000Z</published>
    <updated>2017-03-23T02:55:23.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/smallnest/gofsm" target="_blank" rel="external">gofsm</a>是一个简单、小巧而又特色的有限状态机（FSM）。</p>
<p>github已经有了很多状态机的实现，比如文末列出的一些，还为什么要再发明轮子呢？</p>
<p>原因在于这些状态机有一个特点，就是一个状态机维护一个对象的状态，这样一个状态机就和一个具体的图像实例关联在一起，在有些情况下，这没有什么问题，而且是很好的设计，而且比较符合状态机的定义。但是在有些情况下，当我们需要维护成千上百个对象的时候，需要创建成千上百个状态机对象，这其实是很大的浪费，因为在大部分情况下，对象本身自己会维护/保持自己当前的状态，我们只需把对象当前的状态传递给一个共用的状态机就可以了，也就是gofsm本身是“stateless”，本身它包维护一个或者多个对象的状态，所有需要的输入由调用者输入，它只负责状态的转换的逻辑，所以它的实现非常的简洁实用，这是创建gofsm的一个目的。</p>
<p>第二个原因它提供了Moore和Mealy两种状态机的统一接口，并且提供了UML状态机风格的Action处理，以程序员更熟悉的方式处理状态的改变。</p>
<p>第三个原因，当我们谈论起状态机的时候，我们总会画一个状态转换图，大家可以根据这这张图进行讨论、设计、实现和验证状态的迁移。但是对于代码来说，实现真的和你的设计是一致的吗，你怎么保证？gofsm提供了一个简单的方法，那就是它可以输出图片或者pdf文件，你可以利用输出的状态机图和你的设计进行比较，看看实现和设计是否一致。</p>
<p><img src="/2016/12/24/a-featured-fsm/state.png" alt="gofsm生成的闸门状态图"><br><a id="more"></a></p>
<h2 id="有限状态机">有限状态机</h2>
<p>有限状态机（finite-state machine）常常用于计算机程序和时序逻辑电路的设计数学模型。它被看作是一种抽象的机器，可以有有限个状态。任意时刻这个机器只有唯一的一个状态，这个状态称为当前状态。当有外部的事件或者条件被触发，它可以从一个状态转换到另一个状态，这就是转换（transition）。一个FSM就是由所有的状态、初始状态和每个转换的触发条件所定义。有时候，当这个转换发生的时候，我们可以要执行一些事情，我们称之为动作（Action）。</p>
<p>现实情况中，我们实际上遇到了很多的这种状态机的情况，只不过我们并没有把它们抽象出来，比如路口的红绿灯，总是在红、黄、绿的状态之间转变，比如电梯的状态，包括开、关、上、下等几个状态。</p>
<p>有限状态机可以有效清晰的为一大堆的问题建立模型，大量应用于电子设计、通讯协议、语言解析和其它的工程应用中，比如TCP/IP协议栈。</p>
<p><img src="tcpfsm.png" alt="图像来源 http://www.tcpipguide.com"></p>
<p>以一个转门为例，这种专门在一些会展、博物馆、公园的门口很常见，顾客可以投币或者刷卡刷票进入，我们下面以投币(Coin)统称这个触发事件。如果你不投币，闸门是锁着的，你推不动它的转臂，而且投一次币只能进去一个人，过去之后闸门又是锁着的，挺智能的 ：）。</p>
<p><img src="turnstile.jpg" alt="图片来源 wikipedia"></p>
<p>如果我们抽象出来它的状态图，可以用下图表示：<br><img src="wiki-fsm.png" alt="图片来源 wikipedia"></p>
<p>它有两个状态：<code>Locked</code>、<code>Unlocked</code>。有两个输入（input）会影响它的状态，投币(coin)和推动转臂（push）。</p>
<ol>
<li>在Locked状态， push没有作用。不管比push多少次闸门的状态还是lock</li>
<li>在Locked状态，投币会让闸门开锁，闸门可以让一个人通过</li>
<li>在Unlocked状态，投币不起作用，闸门还是开着</li>
<li>在Unlocked状态，如果有人push通过，人通过后闸门会由Unlocked状态转变成Locked状态。</li>
</ol>
<p>这是一个简单的闸门的状态转换，却是一个很好的理解状态的典型例子。</p>
<p>以表格来表示：</p>
<table><tbody><tr><th>Current State</th><th>Input</th><th>Next State</th><th>Output</th></tr><tr><th rowspan="2">Locked</th><td>coin</td><td>Unlocked</td><td>Unlock turnstile so customer can push through</td></tr><tr><td>push</td><td>Locked</td><td>None</td></tr><tr><th rowspan="2">Unlocked</th><td>coin</td><td>Unlocked</td><td>None</td></tr><tr><td>push</td><td>Locked</td><td>When customer has pushed through, lock turnstile</td></tr></tbody></table>


<p>UML也有状态图的改变，它扩展了FSM的概念，提供了层次化的嵌套状态（Hierarchically nested states）和正交区域（orthogonal regions），当然这和本文没有太多的关系，有兴趣的读者可以找UML的资料看看。但是它提供了一个很好的概念，也就是动作（Action）。就像Mealy状态机所需要的一样，动作依赖系统的状态和触发事件，而它的Entry Action和Exit Action，却又像Moore 状态机一样，不依赖输入，只依赖状态。所以UML的动作有三种，一种是事件被处理的时候，状态机会执行特定的动作，比如改变变量、执行I/O、调用方法、触发另一个事件等。而离开一个状态，可以执行Exit action，进入一个状态，则执行Entry action。记住，收到一个事件，对象的状态不会改变，比如上边闸门的例子，在Locked状态下push多少次状态都没改变，这这种情况下，不会执行Exit和Entry action。</p>
<p>gofsm提供了这种扩展的模型，当然如果你不想使用这种扩展，你也可以不去实现Entry和Exit。</p>
<p>可以提到了两种状态机，这两种状态机是这样来区分的：</p>
<ul>
<li><strong>Moore machine</strong><br>Moore状态机只使用entry action，输出只依赖状态，不依赖输入。</li>
<li><strong>Mealy machine</strong><br>Mealy状态机只使用input action，输出依赖输入input和状态state。使用这种状态机通常可以减少状态的数量。</li>
</ul>
<p>gofsm提供了一个通用的接口，你可以根据需要确定使用哪个状态机。从软件开发的实践上来看，有时候你并不一定要关注状态机的区分，而是清晰的抽象、设计你所关注的对象的状态、触发条件以及要执行的动作。</p>
<h2 id="gofsm">gofsm</h2>
<p>gofsm参考了 <a href="https://github.com/elimisteve/fsm" target="_blank" rel="external">elimisteve/fsm</a> 的实现，实现了一种单一状态机处理多个对象的方法，并且提供了输出状态图的功能。</p>
<p>它除了定义对象的状态外，还定义了触发事件以及处理的Action，这些都是通过字符串来表示的，在使用的时候很容易的和你的对象、方法对应起来。</p>
<p>使用gofsm也很简单，当然第一步将库拉到本地：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get -u github.com/smallnest/gofsm</div></pre></td></tr></table></figure>

<p>我们以上面的闸门为例，看看gofsm是如何使用的。</p>
<p>注意下面的单个状态机可以处理并行地的处理多个闸门的状态改变，虽然例子中只生成了一个闸门对象。</p>
<p>首先定义一个闸门对象,它包含一个State，表示它当前的状态：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Turnstile <span class="keyword">struct</span> {</div><div class="line">	ID         <span class="typename">uint64</span></div><div class="line">	EventCount <span class="typename">uint64</span> <span class="comment">//事件统计</span></div><div class="line">	CoinCount  <span class="typename">uint64</span> <span class="comment">//投币事件统计</span></div><div class="line">	PassCount  <span class="typename">uint64</span> <span class="comment">//顾客通过事件统计</span></div><div class="line">	State      <span class="typename">string</span> <span class="comment">//当前状态</span></div><div class="line">	States     []<span class="typename">string</span> <span class="comment">//历史经过的状态</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>状态机的初始化简单直接：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> initFSM() *StateMachine {</div><div class="line">	delegate := &DefaultDelegate{p: &TurnstileEventProcessor{}}</div><div class="line"></div><div class="line">	transitions := []Transition{</div><div class="line">		Transition{From: <span class="string">"Locked"</span>, Event: <span class="string">"Coin"</span>, To: <span class="string">"Unlocked"</span>, Action: <span class="string">"check"</span>},</div><div class="line">		Transition{From: <span class="string">"Locked"</span>, Event: <span class="string">"Push"</span>, To: <span class="string">"Locked"</span>, Action: <span class="string">"invalid-push"</span>},</div><div class="line">		Transition{From: <span class="string">"Unlocked"</span>, Event: <span class="string">"Push"</span>, To: <span class="string">"Locked"</span>, Action: <span class="string">"pass"</span>},</div><div class="line">		Transition{From: <span class="string">"Unlocked"</span>, Event: <span class="string">"Coin"</span>, To: <span class="string">"Unlocked"</span>, Action: <span class="string">"repeat-check"</span>},</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> NewStateMachine(delegate, transitions...)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你定义好转换对应关系<code>transitions</code>,一个<code>Transition</code>代表一个转换，从某个状态到另外一个状态，触发的事件名，要执行的Action。<br>因为Action是字符串，所以你需要实现<code>delegate</code>将Action和对应的要处理的方法对应起来。</p>
<p>注意from和to的状态可以一样，在这种情况下，状态没有发生改变，只是需要处理Action就可以了。</p>
<p>如果Action为空，也就是不需要处理事件，只是发生状态的改变而已。</p>
<p>处理Action的类型如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> TurnstileEventProcessor <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (p *TurnstileEventProcessor) OnExit(fromState <span class="typename">string</span>, args []<span class="keyword">interface</span>{}) {</div><div class="line">	……</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (p *TurnstileEventProcessor) Action(action <span class="typename">string</span>, fromState <span class="typename">string</span>, toState <span class="typename">string</span>, args []<span class="keyword">interface</span>{}) {</div><div class="line">	……</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (p *TurnstileEventProcessor) OnEnter(toState <span class="typename">string</span>, args []<span class="keyword">interface</span>{}) {</div><div class="line">    ……</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后我们就可以触发一些事件看看闸门的状态机是否正常工作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">ts := &Turnstile{</div><div class="line">	ID:    <span class="number"> 1</span>,</div><div class="line">	State:  <span class="string">"Locked"</span>,</div><div class="line">	States: []<span class="typename">string</span>{<span class="string">"Locked"</span>},</div><div class="line">}</div><div class="line">fsm := initFSM()</div><div class="line"></div><div class="line"><span class="comment">//推门</span></div><div class="line"><span class="comment">//没刷卡/投币不可进入</span></div><div class="line">err := fsm.Trigger(ts.State, <span class="string">"Push"</span>, ts)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	t.Errorf(<span class="string">"trigger err: %v"</span>, err)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//推门</span></div><div class="line"><span class="comment">//没刷卡/投币不可进入</span></div><div class="line">err = fsm.Trigger(ts.State, <span class="string">"Push"</span>, ts)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	t.Errorf(<span class="string">"trigger err: %v"</span>, err)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//刷卡或者投币</span></div><div class="line"><span class="comment">//不容易啊，终于解锁了</span></div><div class="line">err = fsm.Trigger(ts.State, <span class="string">"Coin"</span>, ts)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	t.Errorf(<span class="string">"trigger err: %v"</span>, err)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//刷卡或者投币</span></div><div class="line"><span class="comment">//这时才解锁</span></div><div class="line">err = fsm.Trigger(ts.State, <span class="string">"Coin"</span>, ts)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	t.Errorf(<span class="string">"trigger err: %v"</span>, err)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//推门</span></div><div class="line"><span class="comment">//这时才能进入，进入后闸门被锁</span></div><div class="line">err = fsm.Trigger(ts.State, <span class="string">"Push"</span>, ts)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	t.Errorf(<span class="string">"trigger err: %v"</span>, err)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//推门</span></div><div class="line"><span class="comment">//无法进入，闸门已锁</span></div><div class="line">err = fsm.Trigger(ts.State, <span class="string">"Push"</span>, ts)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	t.Errorf(<span class="string">"trigger err: %v"</span>, err)</div><div class="line">}</div><div class="line"></div><div class="line">lastState := Turnstile{</div><div class="line">	ID:        <span class="number"> 1</span>,</div><div class="line">	EventCount:<span class="number"> 6</span>,</div><div class="line">	CoinCount: <span class="number"> 2</span>,</div><div class="line">	PassCount: <span class="number"> 1</span>,</div><div class="line">	State:      <span class="string">"Locked"</span>,</div><div class="line">	States:     []<span class="typename">string</span>{<span class="string">"Locked"</span>, <span class="string">"Unlocked"</span>, <span class="string">"Locked"</span>},</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">if</span> !compareTurnstile(&lastState, ts) {</div><div class="line">	t.Errorf(<span class="string">"Expected last state: %+v, but got %+v"</span>, lastState, ts)</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">	t.Logf(<span class="string">"最终的状态: %+v"</span>, ts)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果想将状态图输出图片，可以调用下面的方法，它实际是调用graphviz生成的，所以请确保你的机器上是否安装了这个软件，你可以执行<code>dot -h</code>检查一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fsm.Export(<span class="string">"state.png"</span>)</div></pre></td></tr></table></figure>

<p>生成的图片就是文首的闸门的状态机的图片。</p>
<p>如果你想定制graphviz的参数，你可以调用另外一个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *StateMachine) ExportWithDetails(outfile <span class="typename">string</span>, format <span class="typename">string</span>, layout <span class="typename">string</span>, scale <span class="typename">string</span>, more <span class="typename">string</span>) error</div></pre></td></tr></table></figure>

<h2 id="其它Go语言实现的FSM">其它Go语言实现的FSM</h2>
<p>如果你发现gofsm的功能需要改进，或者有一些想法、或者发现了bug，请不用迟疑，在<a href="https://github.com/smallnest/gofsm/issues" target="_blank" rel="external">issue</a>中提交你的意见和建议，我会及时的进行反馈。</p>
<p>如果你觉得本项目有用，或者将来可能会使用，请star这个项目 <a href="https://github.com/smallnest/gofsm" target="_blank" rel="external">smallnest/gofsm</a>。</p>
<p>如果你想比较其它的Go语言实现的fsm，可以参考下面的列表：</p>
<ul>
<li><a href="https://github.com/elimisteve/fsm" target="_blank" rel="external">elimisteve/fsm</a></li>
<li><a href="https://github.com/looplab/fsm" target="_blank" rel="external">looplab/fsm</a></li>
<li><a href="https://github.com/vaughan0/go-fsm" target="_blank" rel="external">vaughan0/go-fsm</a></li>
<li><a href="https://github.com/WatchBeam/fsm" target="_blank" rel="external">WatchBeam/fsm</a></li>
<li><a href="https://github.com/DiscoViking/fsm" target="_blank" rel="external">DiscoViking/fsm</a></li>
<li><a href="https://github.com/autocube/hsm" target="_blank" rel="external">autocube/hsm</a></li>
<li><a href="https://github.com/theckman/go-fsm" target="_blank" rel="external">theckman/go-fsm</a></li>
<li><a href="https://github.com/Zumata/fsm" target="_blank" rel="external">Zumata/fsm</a></li>
<li><a href="https://github.com/syed/go-fsm" target="_blank" rel="external">syed/go-fsm</a></li>
<li><a href="https://github.com/go-rut/fsm" target="_blank" rel="external">go-rut/fsm</a></li>
<li><a href="https://github.com/yandd/fsm" target="_blank" rel="external">yandd/fsm</a></li>
<li><a href="https://github.com/go-trellis/fsm" target="_blank" rel="external">go-trellis/fsm</a></li>
<li>……</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Finite-state_machine" target="_blank" rel="external">https://en.wikipedia.org/wiki/Finite-state_machine</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/smallnest/gofsm" target="_blank" rel="external">gofsm</a>是一个简单、小巧而又特色的有限状态机（FSM）。</p>
<p>github已经有了很多状态机的实现，比如文末列出的一些，还为什么要再发明轮子呢？</p>
<p>原因在于这些状态机有一个特点，就是一个状态机维护一个对象的状态，这样一个状态机就和一个具体的图像实例关联在一起，在有些情况下，这没有什么问题，而且是很好的设计，而且比较符合状态机的定义。但是在有些情况下，当我们需要维护成千上百个对象的时候，需要创建成千上百个状态机对象，这其实是很大的浪费，因为在大部分情况下，对象本身自己会维护/保持自己当前的状态，我们只需把对象当前的状态传递给一个共用的状态机就可以了，也就是gofsm本身是“stateless”，本身它包维护一个或者多个对象的状态，所有需要的输入由调用者输入，它只负责状态的转换的逻辑，所以它的实现非常的简洁实用，这是创建gofsm的一个目的。</p>
<p>第二个原因它提供了Moore和Mealy两种状态机的统一接口，并且提供了UML状态机风格的Action处理，以程序员更熟悉的方式处理状态的改变。</p>
<p>第三个原因，当我们谈论起状态机的时候，我们总会画一个状态转换图，大家可以根据这这张图进行讨论、设计、实现和验证状态的迁移。但是对于代码来说，实现真的和你的设计是一致的吗，你怎么保证？gofsm提供了一个简单的方法，那就是它可以输出图片或者pdf文件，你可以利用输出的状态机图和你的设计进行比较，看看实现和设计是否一致。</p>
<p><img src="/2016/12/24/a-featured-fsm/state.png" alt="gofsm生成的闸门状态图"><br>]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[调试利器：dump goroutine 的 stacktrace]]></title>
    <link href="http://colobu.com/2016/12/21/how-to-dump-goroutine-stack-traces/"/>
    <id>http://colobu.com/2016/12/21/how-to-dump-goroutine-stack-traces/</id>
    <published>2016-12-21T05:33:37.000Z</published>
    <updated>2016-12-21T11:26:20.000Z</updated>
    <content type="html"><![CDATA[<p>Stack trace是指堆栈回溯信息，在当前时间，以当前方法的执行点开始，回溯调用它的方法的方法的执行点，然后继续回溯，这样就可以跟踪整个方法的调用,大家比较熟悉的是JDK所带的<code>jstack</code>工具，可以把Java的所有线程的stack trace都打印出来。</p>
<p>它有什么用呢？用处非常的大，当应用出现一些状况的时候，比如某个模块不执行， 锁竞争、CPU占用非常高等问题， 又没有足够的log信息可以分析，那么可以查看stack trace信息，看看线程都被阻塞或者运行在那些代码上，然后定位问题所在。</p>
<p>对于Go开发的程序，有没有类似<code>jstack</code>这样的利器呢，目前我还没有看到，但是我们可以通过其它途径也很方便的输出goroutine的stack trace信息。</p>
<p>本文介绍了几种方法，尤其是最后介绍的方法比较有用。</p>
<a id="more"></a>
<h2 id="异常退出情况下输出stacktrace">异常退出情况下输出stacktrace</h2>
<h3 id="通过panic">通过panic</h3>
<p>如果应用中有没recover的panic,或者应用在运行的时候出现运行时的异常，那么程序自动会将当前的goroutine的stack trace打印出来。</p>
<p>比如下面的程序，如果你运行会抛出一个panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">go</span> a()</div><div class="line">	m1()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> m1() {</div><div class="line">	m2()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> m2() {</div><div class="line">	m3()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> m3() {</div><div class="line">	<span class="built_in">panic</span>(<span class="string">"panic from m3"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> a() {</div><div class="line">	time.Sleep(time.Hour)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出下面的stack trace:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">dump <span class="keyword">go</span> run p.<span class="keyword">go</span></div><div class="line"><span class="built_in">panic</span>: <span class="built_in">panic</span> from m3</div><div class="line"></div><div class="line">goroutine<span class="number"> 1</span> [running]:</div><div class="line"><span class="built_in">panic</span><span class="number">(0</span>x596a0,<span class="number"> 0</span>xc42000a1a0)</div><div class="line">	/usr/local/Cellar/<span class="keyword">go</span><span class="number">/1.7</span><span class="number">.4</span>/libexec/src/runtime/<span class="built_in">panic</span>.<span class="keyword">go</span><span class="number">:500</span><span class="number"> +0</span>x1a1</div><div class="line">main.m3()</div><div class="line">	/Users/yuepan/<span class="keyword">go</span>/src/github.com/smallnest/dump/p.<span class="keyword">go</span><span class="number">:21</span><span class="number"> +0</span>x6d</div><div class="line">main.m2()</div><div class="line">	/Users/yuepan/<span class="keyword">go</span>/src/github.com/smallnest/dump/p.<span class="keyword">go</span><span class="number">:17</span><span class="number"> +0</span>x14</div><div class="line">main.m1()</div><div class="line">	/Users/yuepan/<span class="keyword">go</span>/src/github.com/smallnest/dump/p.<span class="keyword">go</span><span class="number">:13</span><span class="number"> +0</span>x14</div><div class="line">main.main()</div><div class="line">	/Users/yuepan/<span class="keyword">go</span>/src/github.com/smallnest/dump/p.<span class="keyword">go</span><span class="number">:9</span><span class="number"> +0</span>x3a</div><div class="line">exit status<span class="number"> 2</span></div></pre></td></tr></table></figure>

<p>从这个信息中我们可以看到p.go的第9行是main方法，它在这一行调用m1方法，m1方法在第13行调用m2方法，m2方法在第17行调用m3方法，m3方法在第21出现panic， 它们运行在goroutine 1中，当前goroutine 1的状态是running状态。</p>
<p>如果想让它把所有的goroutine信息都输出出来，可以设置 <code>GOTRACEBACK=1</code>:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">GOTRACEBACK<span class="number">=1</span> <span class="keyword">go</span> run p.<span class="keyword">go</span></div><div class="line"><span class="built_in">panic</span>: <span class="built_in">panic</span> from m3</div><div class="line"></div><div class="line">goroutine<span class="number"> 1</span> [running]:</div><div class="line"><span class="built_in">panic</span><span class="number">(0</span>x596a0,<span class="number"> 0</span>xc42000a1b0)</div><div class="line">	/usr/local/Cellar/<span class="keyword">go</span><span class="number">/1.7</span><span class="number">.4</span>/libexec/src/runtime/<span class="built_in">panic</span>.<span class="keyword">go</span><span class="number">:500</span><span class="number"> +0</span>x1a1</div><div class="line">main.m3()</div><div class="line">	/Users/yuepan/<span class="keyword">go</span>/src/github.com/smallnest/dump/p.<span class="keyword">go</span><span class="number">:21</span><span class="number"> +0</span>x6d</div><div class="line">main.m2()</div><div class="line">	/Users/yuepan/<span class="keyword">go</span>/src/github.com/smallnest/dump/p.<span class="keyword">go</span><span class="number">:17</span><span class="number"> +0</span>x14</div><div class="line">main.m1()</div><div class="line">	/Users/yuepan/<span class="keyword">go</span>/src/github.com/smallnest/dump/p.<span class="keyword">go</span><span class="number">:13</span><span class="number"> +0</span>x14</div><div class="line">main.main()</div><div class="line">	/Users/yuepan/<span class="keyword">go</span>/src/github.com/smallnest/dump/p.<span class="keyword">go</span><span class="number">:9</span><span class="number"> +0</span>x3a</div><div class="line"></div><div class="line">goroutine<span class="number"> 4</span> [sleep]:</div><div class="line">time.Sleep<span class="number">(0</span>x34630b8a000)</div><div class="line">	/usr/local/Cellar/<span class="keyword">go</span><span class="number">/1.7</span><span class="number">.4</span>/libexec/src/runtime/time.<span class="keyword">go</span><span class="number">:59</span><span class="number"> +0</span>xe1</div><div class="line">main.a()</div><div class="line">	/Users/yuepan/<span class="keyword">go</span>/src/github.com/smallnest/dump/p.<span class="keyword">go</span><span class="number">:25</span><span class="number"> +0</span>x30</div><div class="line">created by main.main</div><div class="line">	/Users/yuepan/<span class="keyword">go</span>/src/github.com/smallnest/dump/p.<span class="keyword">go</span><span class="number">:8</span><span class="number"> +0</span>x35</div><div class="line">exit status<span class="number"> 2</span></div></pre></td></tr></table></figure>

<p>同样你也可以分析这个stack trace的信息，得到方法调用点的情况，同时这个信息将两个goroutine的stack trace都打印出来了，而且goroutine 4的状态是sleep状态。</p>
<p>Go官方文档对这个环境变量有<a href="https://golang.org/pkg/runtime/" target="_blank" rel="external">介绍</a>：</p>
<blockquote>
<p>The GOTRACEBACK variable controls the amount of output generated when a Go program fails due to an unrecovered panic or an unexpected runtime condition. By default, a failure prints a stack trace for the current goroutine, eliding functions internal to the run-time system, and then exits with exit code 2. The failure prints stack traces for all goroutines if there is no current goroutine or the failure is internal to the run-time. GOTRACEBACK=none omits the goroutine stack traces entirely. GOTRACEBACK=single (the default) behaves as described above. GOTRACEBACK=all adds stack traces for all user-created goroutines. GOTRACEBACK=system is like “all” but adds stack frames for run-time functions and shows goroutines created internally by the run-time. GOTRACEBACK=crash is like “system” but crashes in an operating system-specific manner instead of exiting. For example, on Unix systems, the crash raises SIGABRT to trigger a core dump. For historical reasons, the GOTRACEBACK settings 0, 1, and 2 are synonyms for none, all, and system, respectively. The runtime/debug package&#39;s SetTraceback function allows increasing the amount of output at run time, but it cannot reduce the amount below that specified by the environment variable. See <a href="https://golang.org/pkg/runtime/debug/#SetTraceback" target="_blank" rel="external">https://golang.org/pkg/runtime/debug/#SetTraceback</a>.</p>
</blockquote>
<p>你可以设置 <code>none</code>、<code>all</code>、<code>system</code>、<code>single</code>、<code>crash</code>，历史原因， 你可以可是设置数字<code>0</code>、<code>1</code>、<code>2</code>，分别代表<code>none</code>、<code>all</code>、<code>system</code>。</p>
<h3 id="通过SIGQUIT信号">通过SIGQUIT信号</h3>
<p>如果程序没有发生panic,但是程序有问题，&quot;假死“不工作，我们想看看哪儿出现了问题，可以给程序发送<code>SIGQUIT</code>信号，也可以输出stack trace信息。<br>比如下面的程序:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">go</span> a()</div><div class="line">	m1()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> m1() {</div><div class="line">	m2()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> m2() {</div><div class="line">	m3()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> m3() {</div><div class="line">	time.Sleep(time.Hour)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> a() {</div><div class="line">	time.Sleep(time.Hour)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你可以运行<code>kill -SIGQUIT &lt;pid&gt;</code> 杀死这个程序，程序在退出的时候输出strack trace。</p>
<h2 id="正常情况下输出stacktrace">正常情况下输出stacktrace</h2>
<p>上面的情况是必须要求程序退出才能打印出stack trace信息，但是有时候我们只是需要跟踪分析一下程序的问题，而不希望程序中断运行。所以我们需要其它的方法来执行。</p>
<p>你可以暴漏一个命令、一个API或者监听一个信号，然后调用相应的方法把stack trace打印出来。</p>
<h3 id="打印出当前goroutine的_stacktrace">打印出当前goroutine的 stacktrace</h3>
<p>通过<code>debug.PrintStack()</code>方法可以将当前所在的goroutine的stack trace打印出来，如下面的程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"runtime/debug"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">go</span> a()</div><div class="line">	m1()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> m1() {</div><div class="line">	m2()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> m2() {</div><div class="line">	m3()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> m3() {</div><div class="line">	debug.PrintStack()</div><div class="line">	time.Sleep(time.Hour)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> a() {</div><div class="line">	time.Sleep(time.Hour)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="打印出所有goroutine的_stacktrace">打印出所有goroutine的 stacktrace</h3>
<p>可以通过<code>pprof.Lookup(&quot;goroutine&quot;).WriteTo</code>将所有的goroutine的stack trace都打印出来，如下面的程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"runtime/pprof"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">go</span> a()</div><div class="line">	m1()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> m1() {</div><div class="line">	m2()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> m2() {</div><div class="line">	m3()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> m3() {</div><div class="line">	pprof.Lookup(<span class="string">"goroutine"</span>).WriteTo(os.Stdout,<span class="number"> 1</span>)</div><div class="line">	time.Sleep(time.Hour)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> a() {</div><div class="line">	time.Sleep(time.Hour)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="较完美的输出_stacktrace">较完美的输出 stacktrace</h3>
<p>你可以使用<code>runtime.Stack</code>得到所有的goroutine的stack trace信息，事实上前面<code>debug.PrintStack()</code>也是通过这个方法获得的。</p>
<p>为了更方便的随时的得到应用所有的goroutine的stack trace信息，我们可以监听<code>SIGUSER1</code>信号，当收到这个信号的时候就将stack trace打印出来。发送信号也很简单，通过<code>kill -SIGUSER1 &lt;pid&gt;</code>就可以，不必担心<code>kill</code>会将程序杀死，它只是发了一个信号而已。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"os/signal"</span></div><div class="line">	<span class="string">"runtime"</span></div><div class="line">	<span class="string">"syscall"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	setupSigusr1Trap()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> a()</div><div class="line">	m1()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> m1() {</div><div class="line">	m2()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> m2() {</div><div class="line">	m3()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> m3() {</div><div class="line">	time.Sleep(time.Hour)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> a() {</div><div class="line">	time.Sleep(time.Hour)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> setupSigusr1Trap() {</div><div class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal,<span class="number"> 1</span>)</div><div class="line">	signal.Notify(c, syscall.SIGUSR1)</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">for</span> <span class="keyword">range</span> c {</div><div class="line">			DumpStacks()</div><div class="line">		}</div><div class="line">	}()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> DumpStacks() {</div><div class="line">	buf := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 16384</span>)</div><div class="line">	buf = buf[:runtime.Stack(buf, <span class="constant">true</span>)]</div><div class="line">	fmt.Printf(<span class="string">"=== BEGIN goroutine stack dump ===\n%s\n=== END goroutine stack dump ==="</span>, buf)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果很直观，方便检查。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">=== <span class="operator"><span class="keyword">BEGIN</span> goroutine stack dump ===</span></div><div class="line">goroutine <span class="number">36</span> [running]:</div><div class="line">main.DumpStacks()</div><div class="line">	/Users/yuepan/<span class="keyword">go</span>/src/github.com/smallnest/dump/d3.<span class="keyword">go</span>:<span class="number">47</span> +<span class="number">0x77</span></div><div class="line">main.setupSigusr1Trap.func1(<span class="number">0xc420070060</span>)</div><div class="line">	/Users/yuepan/<span class="keyword">go</span>/src/github.com/smallnest/dump/d3.<span class="keyword">go</span>:<span class="number">40</span> +<span class="number">0x73</span></div><div class="line">created <span class="keyword">by</span> main.setupSigusr1Trap</div><div class="line">	/Users/yuepan/<span class="keyword">go</span>/src/github.com/smallnest/dump/d3.<span class="keyword">go</span>:<span class="number">42</span> +<span class="number">0xec</span></div><div class="line"></div><div class="line">goroutine <span class="number">1</span> [<span class="keyword">sleep</span>]:</div><div class="line"><span class="keyword">time</span>.<span class="keyword">Sleep</span>(<span class="number">0x34630b8a000</span>)</div><div class="line">	/usr/<span class="keyword">local</span>/Cellar/<span class="keyword">go</span>/<span class="number">1.7</span><span class="number">.4</span>/libexec/src/runtime/<span class="keyword">time</span>.<span class="keyword">go</span>:<span class="number">59</span> +<span class="number">0xe1</span></div><div class="line">main.m3()</div><div class="line">	/Users/yuepan/<span class="keyword">go</span>/src/github.com/smallnest/dump/d3.<span class="keyword">go</span>:<span class="number">28</span> +<span class="number">0x30</span></div><div class="line">main.m2()</div><div class="line">	/Users/yuepan/<span class="keyword">go</span>/src/github.com/smallnest/dump/d3.<span class="keyword">go</span>:<span class="number">24</span> +<span class="number">0x14</span></div><div class="line">main.m1()</div><div class="line">	/Users/yuepan/<span class="keyword">go</span>/src/github.com/smallnest/dump/d3.<span class="keyword">go</span>:<span class="number">20</span> +<span class="number">0x14</span></div><div class="line">main.main()</div><div class="line">	/Users/yuepan/<span class="keyword">go</span>/src/github.com/smallnest/dump/d3.<span class="keyword">go</span>:<span class="number">16</span> +<span class="number">0x3f</span></div><div class="line"></div><div class="line">goroutine <span class="number">34</span> [syscall]:</div><div class="line">os/signal.signal_recv(<span class="number">0xff280</span>)</div><div class="line">	/usr/<span class="keyword">local</span>/Cellar/<span class="keyword">go</span>/<span class="number">1.7</span><span class="number">.4</span>/libexec/src/runtime/sigqueue.<span class="keyword">go</span>:<span class="number">116</span> +<span class="number">0x157</span></div><div class="line">os/signal.loop()</div><div class="line">	/usr/<span class="keyword">local</span>/Cellar/<span class="keyword">go</span>/<span class="number">1.7</span><span class="number">.4</span>/libexec/src/os/signal/signal_unix.<span class="keyword">go</span>:<span class="number">22</span> +<span class="number">0x22</span></div><div class="line">created <span class="keyword">by</span> os/signal.init<span class="number">.1</span></div><div class="line">	/usr/<span class="keyword">local</span>/Cellar/<span class="keyword">go</span>/<span class="number">1.7</span><span class="number">.4</span>/libexec/src/os/signal/signal_unix.<span class="keyword">go</span>:<span class="number">28</span> +<span class="number">0x41</span></div><div class="line"></div><div class="line">goroutine <span class="number">35</span> [<span class="keyword">select</span>, locked <span class="keyword">to</span> thread]:</div><div class="line">runtime.gopark(<span class="number">0xb5cc8</span>, <span class="number">0x0</span>, <span class="number">0xab3ef</span>, <span class="number">0x6</span>, <span class="number">0x18</span>, <span class="number">0x2</span>)</div><div class="line">	/usr/<span class="keyword">local</span>/Cellar/<span class="keyword">go</span>/<span class="number">1.7</span><span class="number">.4</span>/libexec/src/runtime/proc.<span class="keyword">go</span>:<span class="number">259</span> +<span class="number">0x13a</span></div><div class="line">runtime.selectgoImpl(<span class="number">0xc42008d730</span>, <span class="number">0x0</span>, <span class="number">0x18</span>)</div><div class="line">	/usr/<span class="keyword">local</span>/Cellar/<span class="keyword">go</span>/<span class="number">1.7</span><span class="number">.4</span>/libexec/src/runtime/<span class="keyword">select</span>.<span class="keyword">go</span>:<span class="number">423</span> +<span class="number">0x11d9</span></div><div class="line">runtime.selectgo(<span class="number">0xc42008d730</span>)</div><div class="line">	/usr/<span class="keyword">local</span>/Cellar/<span class="keyword">go</span>/<span class="number">1.7</span><span class="number">.4</span>/libexec/src/runtime/<span class="keyword">select</span>.<span class="keyword">go</span>:<span class="number">238</span> +<span class="number">0x1c</span></div><div class="line">runtime.ensureSigM.func1()</div><div class="line">	/usr/<span class="keyword">local</span>/Cellar/<span class="keyword">go</span>/<span class="number">1.7</span><span class="number">.4</span>/libexec/src/runtime/signal1_unix.<span class="keyword">go</span>:<span class="number">304</span> +<span class="number">0x2d1</span></div><div class="line">runtime.goexit()</div><div class="line">	/usr/<span class="keyword">local</span>/Cellar/<span class="keyword">go</span>/<span class="number">1.7</span><span class="number">.4</span>/libexec/src/runtime/asm_amd64.s:<span class="number">2086</span> +<span class="number">0x1</span></div><div class="line"></div><div class="line">goroutine <span class="number">37</span> [<span class="keyword">sleep</span>]:</div><div class="line"><span class="keyword">time</span>.<span class="keyword">Sleep</span>(<span class="number">0x34630b8a000</span>)</div><div class="line">	/usr/<span class="keyword">local</span>/Cellar/<span class="keyword">go</span>/<span class="number">1.7</span><span class="number">.4</span>/libexec/src/runtime/<span class="keyword">time</span>.<span class="keyword">go</span>:<span class="number">59</span> +<span class="number">0xe1</span></div><div class="line">main.a()</div><div class="line">	/Users/yuepan/<span class="keyword">go</span>/src/github.com/smallnest/dump/d3.<span class="keyword">go</span>:<span class="number">32</span> +<span class="number">0x30</span></div><div class="line">created <span class="keyword">by</span> main.main</div><div class="line">	/Users/yuepan/<span class="keyword">go</span>/src/github.com/smallnest/dump/d3.<span class="keyword">go</span>:<span class="number">15</span> +<span class="number">0x3a</span></div><div class="line"></div><div class="line">=== <span class="keyword">END</span> goroutine stack dump ===</div></pre></td></tr></table></figure>

<p>当然，这段代码也不是我原创的，这是docker代码库中的一段<a href="https://github.com/docker/docker/blob/95fcf76cc64a4acf95c168e8d8607e3acf405c13/pkg/signal/trap.go" target="_blank" rel="external">代码</a>，很简单，也很强大。</p>
<h2 id="参考文档">参考文档</h2>
<ol>
<li><a href="http://stackoverflow.com/questions/19094099/how-to-dump-goroutine-stacktraces" target="_blank" rel="external">http://stackoverflow.com/questions/19094099/how-to-dump-goroutine-stacktraces</a></li>
<li><a href="https://golang.org/pkg/runtime/" target="_blank" rel="external">https://golang.org/pkg/runtime/</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Stack trace是指堆栈回溯信息，在当前时间，以当前方法的执行点开始，回溯调用它的方法的方法的执行点，然后继续回溯，这样就可以跟踪整个方法的调用,大家比较熟悉的是JDK所带的<code>jstack</code>工具，可以把Java的所有线程的stack trace都打印出来。</p>
<p>它有什么用呢？用处非常的大，当应用出现一些状况的时候，比如某个模块不执行， 锁竞争、CPU占用非常高等问题， 又没有足够的log信息可以分析，那么可以查看stack trace信息，看看线程都被阻塞或者运行在那些代码上，然后定位问题所在。</p>
<p>对于Go开发的程序，有没有类似<code>jstack</code>这样的利器呢，目前我还没有看到，但是我们可以通过其它途径也很方便的输出goroutine的stack trace信息。</p>
<p>本文介绍了几种方法，尤其是最后介绍的方法比较有用。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
</feed>
